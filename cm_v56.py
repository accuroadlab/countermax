
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Traffic Counter Enterprise MAX — CLEAN BUILD (v5)
- 전면 정리: 자동정지/책갈피/구간자동멈춤 관련 기능과 버튼, 마커슬라이더 완전 제거
- 핵심 유지: 로그인/권한, 15분 슬롯 카운팅, 단축키(방향/차종), 파일/폴더, 시트/엑셀 저장, 로그 내보내기
- git 사용법을 위한 주석 추가 
"""
import os, sys, re, sqlite3, hashlib, json

# =========================
# DEBUG / DIAGNOSTICS (v36)
# =========================
DEBUG_SITE_HOTKEYS = True

def dlog(msg: str):
    """Lightweight debug logger (prints only when DEBUG_SITE_HOTKEYS=True)."""
    if not DEBUG_SITE_HOTKEYS:
        return
    try:
        print(f"[DBG] {msg}", flush=True)
    except Exception:
        pass

from dataclasses import dataclass, field
from typing import List, Dict, Tuple, Optional
from pathlib import Path
import base64
# ==== Embedded ENV settings script (single-file distribution) ====
EMBEDDED_ENV_B64 = (
    "IyAtKi0gY29kaW5nOiB1dGYtOCAtKi0KIiIiCu2ZmOqyveyEpOyglSAo7ZSE66GcIO2UjOufrOyKpCkg4oCUIGFsbOKAkWlu4oCRb25lIHBhdGNoOArsmpTs"
    "lb0KLSDssKjsooXqtIDrpqw6IOywqOyihSDshKTsoJUgLyDsubTsmrTthLAg64uo7LaV7YKkIOyEpOyglSjsoozCt+yngcK37JqwLCDstpTqsIAv7IiY7KCV"
    "L+yCreygnCkgLyDsubTsmrTthLAg7YWc7ZSM66a/IOq0gOumrAotIOyhsOyCrOq0gOumrDog7KGw7IKs7KCV67O0KOyaqeuPhC/sp4Ttlonsg4Htg5wvU04g"
    "7J6Q64+ZL+uTseuhneydvC/rsJzso7zsspgv6riw6rCEL+yEpOuqhSksCiAgICAgICAgICAgIOyhsOyCrOyLnOqwhCDshKTsoJUo6rWs6rCEIOuIhOyggSDs"
    "tpTqsIAgKyDsnpDrj5nsg53shLEgKyDtlokg7LaU6rCAL+yCreygnCksCiAgICAgICAgICAgIOyhsOyCrOywqOyihSDshKTsoJUo7ZSE66Gc7KCd7Yq4IOyw"
    "uOyhsCArIOuhnOy7rO2OuOynkSksCiAgICAgICAgICAgIOyhsOyCrOyngOygkCDshKTsoJUo7KKMOiDsp4DsoJAg66as7Iqk7Yq4LCDsmrA6IOuwqe2WpeKG"
    "kuq3uOujuSwg7Lm07Jq07YSwLCDsi5ztirgg66+466as67O06riwKQotIOyLnO2KuCDrr7jrpqzrs7TquLA6IO2DrT3rsKntlqUo6re466O5KSwg7Je0PeyL"
    "nOqwhOuMgCArIO2YhOyerCDsobDsgqzssKjsooUo7LCo7KKF66qFKSDsu6zrn7zrk6QK642w7J207YSwIO2MjOydvDogZW52X2RhdGFfcGx1c19hbGxpbm9u"
    "ZS5qc29uCiIiIgppbXBvcnQgb3MsIHN5cywganNvbiwgZGF0ZXRpbWUgYXMgZHQKZnJvbSBQeVF0NSBpbXBvcnQgUXRXaWRnZXRzLCBRdENvcmUsIFF0R3Vp"
    "CgpBUFBfVkVSID0gIjEuMS42LXBhdGNoOCIKCiMgLS0tLS0gTkFTIC8gU3VydmV5IOuNsOydtO2EsCDro6jtirgg7ISk7KCVIC0tLS0tCiMg7Jm467aAL+uC"
    "tOu2gOyXkOyEnCDruIzrnbzsmrDsoIDroZwg7KCR6re87ZWgIOuVjCDsgqzsmqntlZjripQgSFRUUCDro6jtirggKOywuOqzoOyaqSDsg4HsiJgpCkVYVEVS"
    "TkFMX0hUVFBfUk9PVCA9ICJodHRwOi8vYWNjdXJvYWQuc3lub2xvZ3kubWU6NTA5Ni9TdXJ2ZXkiCklOVEVSTkFMX0hUVFBfUk9PVCA9ICJodHRwOi8vMTky"
    "LjE2OC4zNS4yMzk6NTA5Ni9TdXJ2ZXkiCgojIOyLpOygnCDtjIzsnbwg7J6F7Lac66Cl7J2AIOyciOuPhOyasOyXkOyEnCDsnbjsi53tlZjripQg6rK966Gc"
    "KOuTnOudvOydtOu4jC9VTkMp66W8IOyCrOyaqe2VqeuLiOuLpC4KIyAx7Iic7JyEOiDtmZjqsr3rs4DsiJggQ09VTlRFUk1BWF9EQVRBX1JPT1QKIyAy7Iic"
    "7JyEOiDslYTrnpggU01CX0NBTkRJREFURVMg7KSRIOyLpOygnOuhnCDsobTsnqztlZjripQg6rK966GcCiMgM+yInOychDog7J20IGVudl9zZXR0aW5ncyDt"
    "jIzsnbzsnbQg7JyE7LmY7ZWcIO2PtOuNlAppbXBvcnQgb3MgYXMgX29zCgpMT0NBTF9ST09UID0gX29zLnBhdGguZGlybmFtZShfX2ZpbGVfXykKClNNQl9D"
    "QU5ESURBVEVTID0gWwogICAgciJLOlxTdXJ2ZXkiLCAgICAgICAgICAgICAgICAgICAgIyBXZWJEQVbrgpggU01C66W8IEs666GcIOyXsOqysO2VnCDqsr3s"
    "mrAKICAgIHIiWjpcU3VydmV5IiwgICAgICAgICAgICAgICAgICAgICMg7JiI67mEIOuTnOudvOydtOu4jCDrrLjsnpAKICAgIHIiWTpcU3VydmV5IiwgICAg"
    "ICAgICAgICAgICAgICAgICMg7JiI67mEIOuTnOudvOydtOu4jCDrrLjsnpAKCiAgICAjIFdlYkRBViBVTkMg7ZuE67O0ICjrk5zrnbzsnbTruIwg66ek7ZWR"
    "IOyXhuydtOuPhCDsoJHqt7wg6rCA64ql7ZWgIOuVjCkKICAgIHIiXFxhY2N1cm9hZC5zeW5vbG9neS5tZUA1MDk2XERhdldXV1Jvb3RcU3VydmV5IiwKICAg"
    "IHIiXFwxOTIuMTY4LjM1LjIzOUA1MDk2XERhdldXV1Jvb3RcU3VydmV5IiwKICAgICMgU01CIOqzteycoCDtm4Trs7QKICAgIHIiXFwxOTIuMTY4LjM1LjIz"
    "OVxTdXJ2ZXkiLApdCgpkZWYgZGV0ZWN0X2RhdGFfcm9vdCgpOgogICAgZW52ID0gX29zLmVudmlyb24uZ2V0KCJDT1VOVEVSTUFYX0RBVEFfUk9PVCIpCiAg"
    "ICBpZiBlbnYgYW5kIF9vcy5wYXRoLmlzZGlyKGVudik6CiAgICAgICAgcmV0dXJuIGVudgogICAgZm9yIGNhbmQgaW4gU01CX0NBTkRJREFURVM6CiAgICAg"
    "ICAgdHJ5OgogICAgICAgICAgICBpZiBfb3MucGF0aC5pc2RpcihjYW5kKToKICAgICAgICAgICAgICAgIHJldHVybiBjYW5kCiAgICAgICAgZXhjZXB0IEV4"
    "Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgcmV0dXJuIExPQ0FMX1JPT1QKCkRBVEFfUk9PVCA9IGRldGVjdF9kYXRhX3Jvb3QoKQpEQVRBX1BBVEgg"
    "PSBfb3MucGF0aC5qb2luKERBVEFfUk9PVCwgImVudl9kYXRhX3BsdXNfYWxsaW5vbmUuanNvbiIpCgojIC0tLS0tIFByb2plY3RzIC8gREFUIO2MjOydvCDs"
    "oIDsnqUg6rK966GcIC0tLS0tCiMg6rO87JeFKFNOXy4uLikg64uo7JyE66GcIERBVOulvCDsoIDsnqXtlZjripQg66Oo7Yq4IO2PtOuNlDoKIyAgIDxEQVRB"
    "X1JPT1Q+L1Byb2plY3RzL1NOX3h4eHh4eHh4eHh4eHh4eHgvV05feHh4X1lZWVlNTUREX1VTRVJJRC5kYXQKUFJPSkVDVFNfUk9PVCA9IF9vcy5wYXRoLmpv"
    "aW4oREFUQV9ST09ULCAiUHJvamVjdHMiKQoKCmRlZiBlbnN1cmVfcHJvamVjdF9kaXIoc3VydmV5X25vOiBzdHIpIC0+IHN0cjoKICAgICIiIgogICAg6rO8"
    "7JeF67KI7Zi4KFNOXy4uLikg6riw7KSA7Jy866GcIFByb2plY3RzL1NOX3h4eCDtj7TrjZTrpbwg7IOd7ISx7ZWY6rOgIOqyveuhnOulvCDrsJjtmZjtlanr"
    "i4jri6QuCiAgICAiIiIKICAgIGlmIG5vdCBzdXJ2ZXlfbm86CiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigic3VydmV5X25vKFNOXy4uLinqsIAg67mE7Ja0"
    "IOyeiOyKteuLiOuLpC4iKQogICAgZm9sZGVyID0gX29zLnBhdGguam9pbihQUk9KRUNUU19ST09ULCBzdXJ2ZXlfbm8pCiAgICBfb3MubWFrZWRpcnMoZm9s"
    "ZGVyLCBleGlzdF9vaz1UcnVlKQogICAgcmV0dXJuIGZvbGRlcgoKCmRlZiBmb3JtYXRfa29yZWFuX2RhdGV0aW1lKHZhbHVlKSAtPiBzdHI6CiAgICAiIiIK"
    "ICAgIGRhdGV0aW1lIOqwkuydhCAnWVlZWS1NTS1ERCDsmKTsoIQv7Jik7ZuEIEhIOk1NOlNTJyDtmJXsi50g66y47J6Q7Je066GcIOuzgO2ZmO2VqeuLiOuL"
    "pC4KICAgIOydtOuvuCDrrLjsnpDsl7TsnbTrqbQg6re464yA66GcIOuwmO2ZmO2VqeuLiOuLpC4KICAgICIiIgogICAgaWYgaXNpbnN0YW5jZSh2YWx1ZSwg"
    "c3RyKToKICAgICAgICByZXR1cm4gdmFsdWUKICAgIGlmIGlzaW5zdGFuY2UodmFsdWUsIGR0LmRhdGUpIGFuZCBub3QgaXNpbnN0YW5jZSh2YWx1ZSwgZHQu"
    "ZGF0ZXRpbWUpOgogICAgICAgIHZhbHVlID0gZHQuZGF0ZXRpbWUodmFsdWUueWVhciwgdmFsdWUubW9udGgsIHZhbHVlLmRheSkKICAgIGlmIG5vdCBpc2lu"
    "c3RhbmNlKHZhbHVlLCBkdC5kYXRldGltZSk6CiAgICAgICAgcmFpc2UgVHlwZUVycm9yKCJkYXRldGltZSDrmJDripQg64Kg7KecIOusuOyekOyXtOydtOyW"
    "tOyVvCDtlanri4jri6QuIikKICAgIGFtcG0gPSAi7Jik7KCEIiBpZiB2YWx1ZS5ob3VyIDwgMTIgZWxzZSAi7Jik7ZuEIgogICAgaG91cjEyID0gdmFsdWUu"
    "aG91ciAlIDEyCiAgICBpZiBob3VyMTIgPT0gMDoKICAgICAgICBob3VyMTIgPSAxMgogICAgcmV0dXJuIGYie3ZhbHVlLnN0cmZ0aW1lKCclWS0lbS0lZCcp"
    "fSB7YW1wbX0ge2hvdXIxMjowMmR9Ont2YWx1ZS5taW51dGU6MDJkfTp7dmFsdWUuc2Vjb25kOjAyZH0iCgoKZGVmIHdyaXRlX3N1cnZleV9kYXQoCiAgICBz"
    "dXJ2ZXlfbm86IHN0ciwgICAjIFNOXy4uLgogICAgd29ya19ubzogc3RyLCAgICAgIyBXTl8uLi4KICAgIHVzZXJfaWQ6IHN0ciwgICAgICMg66Gc6re47J24"
    "IElEICjsmIg6IGhrdzMzMTYpCiAgICB1c2VyX25hbWU6IHN0ciwgICAjIOyCrOyaqeyekCDsnbTrpoQKICAgIHJlY19kYXRlLCAgICAgICAgICMg7KGw7IKs"
    "7J28IChkYXRlLCBkYXRldGltZSwg65iQ64qUICdZWVlZLU1NLUREJyDrrLjsnpDsl7QpCiAgICBzdGFydF90aW1lLCAgICAgICAjIOyLnOyekeyLnOqwhCAo"
    "ZGF0ZXRpbWUg65iQ64qUIOydtOuvuCDtj6zrp7frkJwg66y47J6Q7Je0KQogICAgbGFzdF90aW1lLCAgICAgICAgIyDsooXro4zsi5zqsIQgKGRhdGV0aW1l"
    "IOuYkOuKlCDsnbTrr7gg7Y+s66e365CcIOusuOyekOyXtCkKICAgIHNlcV9ubzogaW50ID0gMCwKICAgIHN0YXRlOiBpbnQgPSAxLAogICAgZGVsZXRlZDog"
    "aW50ID0gMCwKICAgIG1hdHJpY2VzPU5vbmUsICAgICMg6rOE7IiYIOuNsOydtO2EsCAoMuywqOybkCDrpqzsiqTtirjrk6TsnZgg66as7Iqk7Yq4KQopOgog"
    "ICAgIiIiCiAgICDsobDsgqwv7KeA7KCQIOyekeyXhSAx6rG07JeQIOuMgO2VnCBEQVQg7YyM7J287J2EIOyDneyEse2VqeuLiOuLpC4KCiAgICDtjIzsnbwg"
    "6rK966GcOgogICAgICAgIFByb2plY3RzLzxTVVJWRVlfTk8+LzxXT1JLX05PPl9ZWVlZTU1ERF88VVNFUl9JRD4uZGF0CgogICAg7Zek642UIO2YleyLneyd"
    "gCDquLDsobQg7JiI7IucIERBVOyZgCDrj5nsnbztlanri4jri6QuCiAgICBtYXRyaWNlcyDripQgMuywqOybkCDrpqzsiqTtirjrk6TsnZgg66as7Iqk7Yq4"
    "7J6F64uI64ukLgogICAgICAgIOyYiDogWyBtYXQwLCBtYXQxLCAuLi4gXQogICAgICAgIG1hdE4g7J2AIHJvd3MgeCBjb2xzIO2BrOq4sOydmCBpbnQg6rCS"
    "IOumrOyKpO2KuOyeheuLiOuLpC4KICAgICIiIgogICAgIyDsobDsgqzsnbwg66y47J6Q7Je0IOyymOumrAogICAgaWYgaXNpbnN0YW5jZShyZWNfZGF0ZSwg"
    "KGR0LmRhdGUsIGR0LmRhdGV0aW1lKSk6CiAgICAgICAgcmVjX2RhdGVfc3RyID0gcmVjX2RhdGUuc3RyZnRpbWUoIiVZLSVtLSVkIikKICAgIGVsc2U6CiAg"
    "ICAgICAgcmVjX2RhdGVfc3RyID0gc3RyKHJlY19kYXRlKQogICAgZGF0ZV9mb3JfbmFtZSA9IHJlY19kYXRlX3N0ci5yZXBsYWNlKCItIiwgIiIpCgogICAg"
    "IyBET0NfTk8gPSBXT1JLX05PX1lZWVlNTUREX1VTRVJJRAogICAgZG9jX25vID0gZiJ7d29ya19ub31fe2RhdGVfZm9yX25hbWV9X3t1c2VyX2lkfSIKCiAg"
    "ICBmb2xkZXIgPSBlbnN1cmVfcHJvamVjdF9kaXIoc3VydmV5X25vKQogICAgZmlsZW5hbWUgPSBfb3MucGF0aC5qb2luKGZvbGRlciwgZG9jX25vICsgIi5k"
    "YXQiKQoKICAgICMg7Zek642UIOyekeyEsQogICAgd2l0aCBvcGVuKGZpbGVuYW1lLCAidyIsIGVuY29kaW5nPSJjcDk0OSIsIG5ld2xpbmU9IlxyXG4iKSBh"
    "cyBmOgogICAgICAgIGYud3JpdGUoIltJTkZPXVxyXG4iKQogICAgICAgIGYud3JpdGUoZiJET0NfTk89e2RvY19ub31cclxuIikKICAgICAgICBmLndyaXRl"
    "KGYiU1VSVkVZX05PPXtzdXJ2ZXlfbm99XHJcbiIpCiAgICAgICAgZi53cml0ZShmIldPUktfTk89e3dvcmtfbm99XHJcbiIpCiAgICAgICAgZi53cml0ZShm"
    "IlVTRVJfSUQ9e3VzZXJfaWR9XHJcbiIpCiAgICAgICAgZi53cml0ZShmIlVTRVJfTk09e3VzZXJfbmFtZX1cclxuIikKICAgICAgICBmLndyaXRlKGYiUkVD"
    "X0RBVEU9e3JlY19kYXRlX3N0cn1cclxuIikKICAgICAgICBmLndyaXRlKGYiU0VRX05PPXtpbnQoc2VxX25vKX1cclxuIikKICAgICAgICBmLndyaXRlKGYi"
    "U1RBUlRfVElNRT17Zm9ybWF0X2tvcmVhbl9kYXRldGltZShzdGFydF90aW1lKX1cclxuIikKICAgICAgICBmLndyaXRlKGYiTEFTVF9USU1FPXtmb3JtYXRf"
    "a29yZWFuX2RhdGV0aW1lKGxhc3RfdGltZSl9XHJcbiIpCiAgICAgICAgZi53cml0ZShmIlNUQVRFPXtpbnQoc3RhdGUpfVxyXG4iKQogICAgICAgIGYud3Jp"
    "dGUoZiJERUxFVEVEPXtpbnQoZGVsZXRlZCl9XHJcbiIpCiAgICAgICAgZi53cml0ZSgiXHJcbiIpCgogICAgICAgICMg6rOE7IiYIOuNsOydtO2EsCDshLns"
    "hZgg7J6R7ISxCiAgICAgICAgaWYgbWF0cmljZXM6CiAgICAgICAgICAgIGZvciBzZWN0aW9uX2luZGV4LCBtYXQgaW4gZW51bWVyYXRlKG1hdHJpY2VzKToK"
    "ICAgICAgICAgICAgICAgIGYud3JpdGUoZiJbe3NlY3Rpb25faW5kZXh9XVxyXG4iKQogICAgICAgICAgICAgICAgZm9yIHIsIHJvdyBpbiBlbnVtZXJhdGUo"
    "bWF0KToKICAgICAgICAgICAgICAgICAgICBmb3IgYywgdmFsIGluIGVudW1lcmF0ZShyb3cpOgogICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAg"
    "ICAgICAgICAgICAgICAgICAgICAgICBpdmFsID0gaW50KHZhbCkKICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAg"
    "ICAgICAgICAgICAgICAgICAgIGl2YWwgPSAwCiAgICAgICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJ7cn0se2N9PXtpdmFsfVxyXG4iKQogICAgICAg"
    "ICAgICAgICAgZi53cml0ZSgiXHJcbiIpCgogICAgcmV0dXJuIGZpbGVuYW1lCgoKCiMgLS0tLS0tLS0tLS0tLS0tLSBJL08gLS0tLS0tLS0tLS0tLS0tLQpk"
    "ZWYgbG9hZF9kYXRhKCk6CiAgICBpZiBvcy5wYXRoLmV4aXN0cyhEQVRBX1BBVEgpOgogICAgICAgIHRyeToKICAgICAgICAgICAgd2l0aCBvcGVuKERBVEFf"
    "UEFUSCwgInIiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgcmV0dXJuIGpzb24ubG9hZChmKQogICAgICAgIGV4Y2VwdCBFeGNl"
    "cHRpb246CiAgICAgICAgICAgIHBhc3MKICAgIHJldHVybiB7CiAgICAgICAgInByb2plY3RzIjogW3sKICAgICAgICAgICAgIm5hbWUiOiAi6riw67O4IOye"
    "keyXhSIsCiAgICAgICAgICAgICJ2ZWhpY2xlX3NldCI6IFsKICAgICAgICAgICAgICAgIHsi67KI7Zi4IjogMSwgIuywqOyiheuqhSI6ICLsirnsmqkifSwK"
    "ICAgICAgICAgICAgICAgIHsi67KI7Zi4IjogMiwgIuywqOyiheuqhSI6ICLshoztmJXrsoTsiqQifSwKICAgICAgICAgICAgICAgIHsi67KI7Zi4IjogMywg"
    "IuywqOyiheuqhSI6ICLrjIDtmJXrsoTsiqQifSwKICAgICAgICAgICAgICAgIHsi67KI7Zi4IjogNCwgIuywqOyiheuqhSI6ICLshoztmJXtmZTrrLwifSwK"
    "ICAgICAgICAgICAgICAgIHsi67KI7Zi4IjogNSwgIuywqOyiheuqhSI6ICLspJHtmJXtmZTrrLwifSwKICAgICAgICAgICAgICAgIHsi67KI7Zi4IjogNiwg"
    "IuywqOyiheuqhSI6ICLrjIDtmJXtmZTrrLwifSwKICAgICAgICAgICAgXSwKICAgICAgICAgICAgImhvdGtleXMiOiB7IuyijCI6IHt9LCAi7KeBIjoge30s"
    "ICLsmrAiOiB7fX0sCiAgICAgICAgICAgICJ0ZW1wbGF0ZXMiOiBbXQogICAgICAgIH1dLAogICAgICAgICJzdXJ2ZXlzIjogW10KICAgIH0KCmRlZiBfaG90"
    "a2V5c19kYl9wYXRoKCk6CiAgICAiIiJOQVMv6rO17JygIOujqO2KuChEQVRBX1JPT1QpIOq4sOykgOycvOuhnCBob3RrZXlzX2RiLmpzb24g7KCA7J6lIOyc"
    "hOy5mOulvCDqsrDsoJXtlanri4jri6QuCgogICAgLSDquLDrs7g6IDxEQVRBX1JPT1Q+L3N1cnZleS9ob3RrZXlzX2RiLmpzb24gIChzdXJ2ZXkg7Y+0642U"
    "6rCAIOyLpOygnOuhnCDsobTsnqztlZjripQg6rK97JqwKQogICAgLSDrjIDslYg6IDxEQVRBX1JPT1Q+L2hvdGtleXNfZGIuanNvbiAgICAgICAgKERBVEFf"
    "Uk9PVOqwgCDsnbTrr7ggU3VydmV5IOujqO2KuOyduCDqsr3smrAg65OxKQogICAgIiIiCiAgICB0cnk6CiAgICAgICAgcm9vdCA9IERBVEFfUk9PVAogICAg"
    "ZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICByb290ID0gb3MucGF0aC5kaXJuYW1lKG9zLnBhdGguYWJzcGF0aChEQVRBX1BBVEgpKQoKICAgIGNhbmRfc3Vy"
    "dmV5ID0gb3MucGF0aC5qb2luKHJvb3QsICJzdXJ2ZXkiKQogICAgaWYgb3MucGF0aC5pc2RpcihjYW5kX3N1cnZleSk6CiAgICAgICAgZm9sZGVyID0gY2Fu"
    "ZF9zdXJ2ZXkKICAgIGVsc2U6CiAgICAgICAgZm9sZGVyID0gcm9vdAoKICAgIHRyeToKICAgICAgICBvcy5tYWtlZGlycyhmb2xkZXIsIGV4aXN0X29rPVRy"
    "dWUpCiAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgIHBhc3MKCiAgICByZXR1cm4gb3MucGF0aC5qb2luKGZvbGRlciwgImhvdGtleXNfZGIuanNvbiIp"
    "CgoKZGVmIGV4cG9ydF9ob3RrZXlzX2RiKGRhdGEpOgogICAgIiIi6rOE7IiY7ZSE66Gc6re4656o7J20IOydveydhCBob3RrZXlzX2RiLmpzb24g7IOd7ISx"
    "KOqzvOyXhS/sp4DsoJAv67Cp7ZalL+ywqOyihS/ri6jstpXtgqQg7Y+s7ZWoKS4iIiIKICAgIG91dCA9IHsKICAgICAgICAidmVyc2lvbiI6IDEsCiAgICAg"
    "ICAgImV4cG9ydGVkX2F0IjogZHQuZGF0ZXRpbWUubm93KCkuc3RyZnRpbWUoIiVZLSVtLSVkICVIOiVNOiVTIiksCiAgICAgICAgIyDqs4TsiJjsqr3sl5Ds"
    "hJwg6re464yA66GcIOywuOyhsO2VoCDsiJgg7J6I6rKMIOyghOyytCDtlITroZzsoJ3tirgv6rO87JeFIOq1rOyhsOulvCDqt7jrjIDroZwg7Y+s7ZWoCiAg"
    "ICAgICAgInByb2plY3RzIjogKGRhdGEgb3Ige30pLmdldCgicHJvamVjdHMiLCBbXSkgb3IgW10sCiAgICAgICAgInN1cnZleXMiOiAoZGF0YSBvciB7fSku"
    "Z2V0KCJzdXJ2ZXlzIiwgW10pIG9yIFtdLAogICAgfQogICAgcGF0aCA9IF9ob3RrZXlzX2RiX3BhdGgoKQogICAgd2l0aCBvcGVuKHBhdGgsICJ3IiwgZW5j"
    "b2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICBqc29uLmR1bXAob3V0LCBmLCBlbnN1cmVfYXNjaWk9RmFsc2UsIGluZGVudD0yKQogICAgcmV0dXJuIHBh"
    "dGgKCgpkZWYgc2F2ZV9kYXRhKGRhdGEpOgogICAgd2l0aCBvcGVuKERBVEFfUEFUSCwgInciLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgIGpz"
    "b24uZHVtcChkYXRhLCBmLCBlbnN1cmVfYXNjaWk9RmFsc2UsIGluZGVudD0yKQogICAgIyDqs4TsiJjtlITroZzqt7jrnqgg7Jew64+Z7JqpIERC64+EIO2V"
    "qOq7mCDqsLHsi6AKICAgIHRyeToKICAgICAgICBleHBvcnRfaG90a2V5c19kYihkYXRhKQogICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICBwYXNzCmNs"
    "YXNzIFdvcmtWZWhpY2xlVGFiKFF0V2lkZ2V0cy5RV2lkZ2V0KToKICAgIGRlZiBfX2luaXRfXyhzZWxmLCB3b3JrKToKICAgICAgICBzdXBlcigpLl9faW5p"
    "dF9fKHdvcmspOyBzZWxmLndvcmsgPSB3b3JrCiAgICAgICAgdiA9IFF0V2lkZ2V0cy5RVkJveExheW91dChzZWxmKQogICAgICAgIHNlbGYudGJsID0gUXRX"
    "aWRnZXRzLlFUYWJsZVdpZGdldCgwLDQpCiAgICAgICAgc2VsZi50Ymwuc2V0SG9yaXpvbnRhbEhlYWRlckxhYmVscyhbIuuyiO2YuCIsIuywqOyiheq1rOu2"
    "hCIsIuyEpOuqhSIsIiJdKQogICAgICAgIHNlbGYudGJsLnNldENvbHVtbkhpZGRlbigzLCBGYWxzZSkKICAgICAgICBzZWxmLnRibC52ZXJ0aWNhbEhlYWRl"
    "cigpLnNldFZpc2libGUoRmFsc2UpCiAgICAgICAgc2VsZi50YmwuaG9yaXpvbnRhbEhlYWRlcigpLnNldFN0cmV0Y2hMYXN0U2VjdGlvbihUcnVlKQogICAg"
    "ICAgIHYuYWRkV2lkZ2V0KHNlbGYudGJsLDEpCiAgICAgICAgaGIgPSBRdFdpZGdldHMuUUhCb3hMYXlvdXQoKQogICAgICAgIGhiLmFkZFN0cmV0Y2goMSkg"
    "ICMg4oaQIOyZvOyqvSDsl6zrsLEsIOuyhO2KvOydhCDsmKTrpbjsqr3snLzroZwg67CA6riwCiAgICAgICAgc2VsZi5iX2FkZCA9IFF0V2lkZ2V0cy5RUHVz"
    "aEJ1dHRvbigi7LaU6rCAIikKICAgICAgICBzZWxmLmJfZWRpdCA9IFF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi7IiY7KCVIikKICAgICAgICBzZWxmLmJfZGVs"
    "ID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCLsgq3soJwiKQogICAgICAgIGZvciBiIGluIChzZWxmLmJfYWRkLCBzZWxmLmJfZWRpdCwgc2VsZi5iX2RlbCk6"
    "CiAgICAgICAgICAgIGIuc2V0Rml4ZWRXaWR0aCg0MCkgICAgICAgIyDihpAg67KE7Yq8IOqwgOuhnCDtgazquLAg7LaV7IaMCiAgICAgICAgICAgIGhiLmFk"
    "ZFdpZGdldChiKQogICAgICAgIHYuYWRkTGF5b3V0KGhiKQogICAgICAgIHNlbGYuYl9hZGQuY2xpY2tlZC5jb25uZWN0KHNlbGYuYWRkX3JvdykKICAgICAg"
    "ICBzZWxmLmJfZWRpdC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5wZXJzaXN0KQogICAgICAgIHNlbGYuYl9kZWwuY2xpY2tlZC5jb25uZWN0KHNlbGYuZGVsX3Jv"
    "dykKICAgICAgICBzZWxmLnRibC5pdGVtQ2hhbmdlZC5jb25uZWN0KGxhbWJkYSAqXzogc2VsZi5wZXJzaXN0KCkpCgogICAgZGVmIGxvYWQoc2VsZik6CiAg"
    "ICAgICAgcCA9IHNlbGYud29yay5jdXJyZW50X3Byb2plY3QoKQogICAgICAgIHNlbGYudGJsLmJsb2NrU2lnbmFscyhUcnVlKTsgc2VsZi50Ymwuc2V0Um93"
    "Q291bnQoMCkKICAgICAgICBpZiBwOgogICAgICAgICAgICBmb3Igcm93IGluIHAuZ2V0KCJ2ZWhpY2xlX3NldCIsW10pOgogICAgICAgICAgICAgICAgcj1z"
    "ZWxmLnRibC5yb3dDb3VudCgpOyBzZWxmLnRibC5pbnNlcnRSb3cocikKICAgICAgICAgICAgICAgIG51bSA9IHJvdy5nZXQoIuuyiO2YuCIsIHIrMSkKICAg"
    "ICAgICAgICAgICAgIG5hbWUgPSByb3cuZ2V0KCLssKjsooXqtazrtoQiLCByb3cuZ2V0KCLssKjsooXrqoUiLCIiKSkKICAgICAgICAgICAgICAgIGRlc2Mg"
    "PSByb3cuZ2V0KCLshKTrqoUiLCAiIikKICAgICAgICAgICAgICAgIHNlbGYudGJsLnNldEl0ZW0ociwwLFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKHN0"
    "cihudW0pKSkKICAgICAgICAgICAgICAgIHNlbGYudGJsLml0ZW0ociwwKS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXJ8UXRDb3Jl"
    "LlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgICAgIHNlbGYudGJsLml0ZW0ociwwKS5zZXRGbGFncyhzZWxmLnRibC5pdGVtKHIsMCkuZmxhZ3MoKSAm"
    "IH5RdENvcmUuUXQuSXRlbUlzRWRpdGFibGUpCiAgICAgICAgICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsMSxRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRl"
    "bShuYW1lKSkKICAgICAgICAgICAgICAgIHNlbGYudGJsLml0ZW0ociwxKS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXJ8UXRDb3Jl"
    "LlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgICAgIHNlbGYudGJsLnNldEl0ZW0ociwyLFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKGRlc2MpKQog"
    "ICAgICAgICAgICAgICAgc2VsZi50YmwuaXRlbShyLDIpLnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlcnxRdENvcmUuUXQuQWxpZ25W"
    "Q2VudGVyKQogICAgICAgICAgICAgICAgCiAgICAgICAgc2VsZi50YmwuYmxvY2tTaWduYWxzKEZhbHNlKQogICAgICAgIHRyeToKICAgICAgICAgICAgc2Vs"
    "Zi50Ymwuc2V0Q29sdW1uV2lkdGgoMCwgNjApICAjIOuyiO2YuCDsl7Qg7LaV7IaMCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFz"
    "cwoKICAgIGRlZiByb3dzKHNlbGYpOgogICAgICAgIG91dD1bXQogICAgICAgIGZvciByIGluIHJhbmdlKHNlbGYudGJsLnJvd0NvdW50KCkpOgogICAgICAg"
    "ICAgICBudW1faXRlbSA9IHNlbGYudGJsLml0ZW0ociwwKQogICAgICAgICAgICBuYW1lX2l0ZW09IHNlbGYudGJsLml0ZW0ociwxKQogICAgICAgICAgICBk"
    "ZXNjX2l0ZW09IHNlbGYudGJsLml0ZW0ociwyKQogICAgICAgICAgICBudW0gPSBudW1faXRlbS50ZXh0KCkgaWYgbnVtX2l0ZW0gZWxzZSBzdHIocisxKQog"
    "ICAgICAgICAgICBuYW1lPSBuYW1lX2l0ZW0udGV4dCgpIGlmIG5hbWVfaXRlbSBlbHNlICIiCiAgICAgICAgICAgIGRlc2M9IGRlc2NfaXRlbS50ZXh0KCkg"
    "aWYgZGVzY19pdGVtIGVsc2UgIiIKICAgICAgICAgICAgaWYgbmFtZToKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBudW1fdmFs"
    "ID0gaW50KG51bSkgaWYgc3RyKG51bSkuaXNkaWdpdCgpIGVsc2UgcisxCiAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAg"
    "ICAgICAgIG51bV92YWwgPSByKzEKICAgICAgICAgICAgICAgIG91dC5hcHBlbmQoeyLrsojtmLgiOiBudW1fdmFsLCAi7LCo7KKF6rWs67aEIjogbmFtZSwg"
    "IuywqOyiheuqhSI6IG5hbWUsICLshKTrqoUiOiBkZXNjfSkKICAgICAgICByZXR1cm4gb3V0CgogICAgZGVmIHBlcnNpc3Qoc2VsZik6CiAgICAgICAgcCA9"
    "IHNlbGYud29yay5jdXJyZW50X3Byb2plY3QoKQogICAgICAgIGlmIG5vdCBwOiByZXR1cm4KICAgICAgICBwWyJ2ZWhpY2xlX3NldCJdID0gc2VsZi5yb3dz"
    "KCkKICAgICAgICBzYXZlX2RhdGEoc2VsZi53b3JrLmRhdGEpCgogICAgZGVmIGFkZF9yb3coc2VsZik6CiAgICAgICAgcj1zZWxmLnRibC5yb3dDb3VudCgp"
    "OyBzZWxmLnRibC5pbnNlcnRSb3cocikKICAgICAgICBpdDA9UXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oc3RyKHIrMSkpOyBpdDAuc2V0VGV4dEFsaWdu"
    "bWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyfFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpOyBpdDAuc2V0RmxhZ3MoaXQwLmZsYWdzKCkgJiB+UXRDb3JlLlF0"
    "Lkl0ZW1Jc0VkaXRhYmxlKTsgc2VsZi50Ymwuc2V0SXRlbShyLDAsaXQwKTtpdDE9UXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oIiIpOyBpdDEuc2V0VGV4"
    "dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyfFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpOyBzZWxmLnRibC5zZXRJdGVtKHIsMSxpdDEpO2l0Mj1R"
    "dFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbSgiIik7IGl0Mi5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXJ8UXRDb3JlLlF0LkFsaWdu"
    "VkNlbnRlcik7IHNlbGYudGJsLnNldEl0ZW0ociwyLGl0Mik7aXQzPVF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKCIiKTsgaXQzLnNldEZsYWdzKGl0My5m"
    "bGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNFZGl0YWJsZSk7IHNlbGYudGJsLnNldEl0ZW0ociwzLGl0MykKICAgICAgICAKICAgICAgICBzZWxmLnBlcnNp"
    "c3QoKQoKICAgIGRlZiBkZWxfcm93KHNlbGYpOgogICAgICAgIHI9c2VsZi50YmwuY3VycmVudFJvdygpCiAgICAgICAgaWYgcj49MDoKICAgICAgICAgICAg"
    "c2VsZi50YmwucmVtb3ZlUm93KHIpCiAgICAgICAgICAgIHNlbGYucGVyc2lzdCgpOyBzZWxmLmxvYWQoKQoKCgojIC0tLS0tLS0tLS0tLS0tLS0g7LCo7KKF"
    "6rSA66asOiDsubTsmrTthLAg64uo7LaV7YKkIC0tLS0tLS0tLS0tLS0tLS0KY2xhc3MgV29ya0hvdGtleVRhYihRdFdpZGdldHMuUVdpZGdldCk6CiAgICAi"
    "IiIKICAgICjsoowv7KeBL+yasCDsoJzqsbApIOyghOyXrSDsubTsmrTthLAg7Iuc7Yq4IOq0gOumrCArIOuLqOy2le2CpCDshKTsoJUKICAgIOyggOyepSDq"
    "tazsobA6CiAgICAgICAgcHJvamVjdFsiaG90a2V5X3NoZWV0c19nbG9iYWwiXSA9IFsKICAgICAgICAgICAgeyJuYW1lIjoiMSIsICJpdGVtcyI6W3si7Iic"
    "67KIIiwi7LCo7KKF66qFIiwi64uo7LaV7YKkIn0sIC4uLl19LAogICAgICAgICAgICAuLi4KICAgICAgICBdCiAgICDtmLjtmZgo7Ji17IWYKToKICAgICAg"
    "ICAtIOyyqyDrsojsp7gg7Iuc7Yq466W8IHByb2plY3RbImhvdGtleV9pdGVtc19nbG9iYWwiXSwgcHJvamVjdFsiaG90a2V5c19nbG9iYWwiXSDroZwg66+4"
    "65+s66eBCiAgICAgICAgLSDstIjquLAg7IOd7ISx7J2AIHZlaGljbGVfc2V0IOq4sOuwmAogICAgIiIiCiAgICBkZWYgX19pbml0X18oc2VsZiwgd29yayk6"
    "CiAgICAgICAgc3VwZXIoKS5fX2luaXRfXyh3b3JrKTsgc2VsZi53b3JrID0gd29yawogICAgICAgIHJvb3QgPSBRdFdpZGdldHMuUUhCb3hMYXlvdXQoc2Vs"
    "ZikKCiAgICAgICAgIyBDZW50ZXI6IOy5tOyatO2EsCDsi5ztirgKICAgICAgICBjZW50ZXIgPSBRdFdpZGdldHMuUVZCb3hMYXlvdXQoKQogICAgICAgIGNl"
    "bnRlci5hZGRXaWRnZXQoUXRXaWRnZXRzLlFMYWJlbCgi7Lm07Jq07YSwIikpCiAgICAgICAgc2VsZi5jb3VudGVyX2xpc3QgPSBRdFdpZGdldHMuUUxpc3RX"
    "aWRnZXQoKQogICAgICAgIHNlbGYuY291bnRlcl9saXN0LnNldEZpeGVkV2lkdGgoMjAwKSAgICMg4oaQIOy5tOyatO2EsCDrpqzsiqTtirgg6rCA66GcIO2P"
    "rSDsobDsoIgKICAgICAgICBjZW50ZXIuYWRkV2lkZ2V0KHNlbGYuY291bnRlcl9saXN0LCAxKQogICAgICAgIGNidG4gPSBRdFdpZGdldHMuUUhCb3hMYXlv"
    "dXQoKQogICAgICAgIHNlbGYuY19hZGQgPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIuy2lOqwgCIpCiAgICAgICAgc2VsZi5jX2RlbCA9IFF0V2lkZ2V0cy5R"
    "UHVzaEJ1dHRvbigi7IKt7KCcIikKICAgICAgICAjIOy5tOyatO2EsCDstpTqsIAv7IKt7KCcIOuyhO2KvOydhCDssKjsooXsnKDtmJUg67KE7Yq86rO8IOu5"
    "hOyKt+2VnCDtgazquLDroZwg7Ya17J28CiAgICAgICAgZm9yIGIgaW4gKHNlbGYuY19hZGQsIHNlbGYuY19kZWwpOgogICAgICAgICAgICBiLnNldE1pbmlt"
    "dW1XaWR0aCg2MCkKICAgICAgICAgICAgYi5zZXRGaXhlZEhlaWdodCgyNCkKICAgICAgICBjYnRuLmFkZFdpZGdldChzZWxmLmNfYWRkKQogICAgICAgIGNi"
    "dG4uYWRkV2lkZ2V0KHNlbGYuY19kZWwpCiAgICAgICAgY2J0bi5hZGRTdHJldGNoKDEpCiAgICAgICAgY2VudGVyLmFkZExheW91dChjYnRuKQogICAgICAg"
    "IHJvb3QuYWRkTGF5b3V0KGNlbnRlciwgMSkKCiAgICAgICAgIyBSaWdodDog64uo7LaV7YKkIOyEpOyglQogICAgICAgIHJpZ2h0ID0gUXRXaWRnZXRzLlFW"
    "Qm94TGF5b3V0KCkKICAgICAgICByaWdodC5hZGRXaWRnZXQoUXRXaWRnZXRzLlFMYWJlbCgi64uo7LaV7YKkIikpCiAgICAgICAgc2VsZi50YmwgPSBRdFdp"
    "ZGdldHMuUVRhYmxlV2lkZ2V0KDAsNCkKICAgICAgICAjIOyXtCDsiJzshJw6IOyInOuyiCAvIOywqOyiheuqhSAvIOuLqOy2le2CpAogICAgICAgIHNlbGYu"
    "dGJsLnNldEhvcml6b250YWxIZWFkZXJMYWJlbHMoWyLsiJzrsogiLCLssKjsooXrqoUiLCLri6jstpXtgqQiLCIiXSkKICAgICAgICBzZWxmLnRibC5ob3Jp"
    "em9udGFsSGVhZGVyKCkuc2V0U3RyZXRjaExhc3RTZWN0aW9uKFRydWUpCiAgICAgICAgc2VsZi50YmwudmVydGljYWxIZWFkZXIoKS5zZXRWaXNpYmxlKEZh"
    "bHNlKQogICAgICAgIHNlbGYudGJsLnNldENvbHVtbkhpZGRlbigwLCBGYWxzZSkKICAgICAgICAjIOuLqOy2le2CpCDsl7Qg6rCA66Gc7Y+tIOyImOyglQog"
    "ICAgICAgIHRyeToKICAgICAgICAgICAgc2VsZi50Ymwuc2V0Q29sdW1uV2lkdGgoMCwgNTApCiAgICAgICAgICAgIHNlbGYudGJsLnNldENvbHVtbldpZHRo"
    "KDEsIDE1MCkKICAgICAgICAgICAgc2VsZi50Ymwuc2V0Q29sdW1uV2lkdGgoMiwgNTApCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAg"
    "cGFzcwogICAgICAgIHJpZ2h0LmFkZFdpZGdldChzZWxmLnRibCwgMSkKCiAgICAgICAgIyDri6jstpXtgqQg7Y647KeRIFVJICsg7LSI6riw7ZmUICjsnoXr"
    "oKXssL0g7Y+tIOy2leyGjCArIOyijOy4oSDsoJXroKwsIOy0iOq4sO2ZlCDrsoTtirzsnYAg7Jqw7LihIOuBnSkKICAgICAgICBrZXlfcm93ID0gUXRXaWRn"
    "ZXRzLlFIQm94TGF5b3V0KCkKICAgICAgICBrZXlfcm93LmFkZFdpZGdldChRdFdpZGdldHMuUUxhYmVsKCLri6jstpXtgqQiKSkKICAgICAgICB0cnk6CiAg"
    "ICAgICAgICAgIHNlbGYua2V5X2VkaXQgPSBRdFdpZGdldHMuUUtleVNlcXVlbmNlRWRpdCgpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAg"
    "ICAgc2VsZi5rZXlfZWRpdCA9IFF0V2lkZ2V0cy5RTGluZUVkaXQoKQogICAgICAgICMg7J6F66Cl7LC9IOqwgOuhnCDtgazquLAg7LaV7IaMIOuwjyDsoozs"
    "uKEg7KCV66CsOiDqs6DsoJUg7Y+t7Jy866GcIOuRkOqzoCBzdHJldGNoIOuKlCDrkqTsl5Ag67Cw7LmYCiAgICAgICAgc2VsZi5rZXlfZWRpdC5zZXRGaXhl"
    "ZFdpZHRoKDE2MCkKICAgICAgICBrZXlfcm93LmFkZFdpZGdldChzZWxmLmtleV9lZGl0KQogICAgICAgIHNlbGYuYnRuX2FwcGx5X2tleSA9IFF0V2lkZ2V0"
    "cy5RUHVzaEJ1dHRvbigi7KCB7JqpIikKICAgICAgICBrZXlfcm93LmFkZFdpZGdldChzZWxmLmJ0bl9hcHBseV9rZXkpCiAgICAgICAga2V5X3Jvdy5hZGRT"
    "dHJldGNoKDEpCiAgICAgICAgIyDstIjquLDtmZQg67KE7Yq87J2EIOqwmeydgCDspITsnZgg7Jqw7LihIOuBneyXkCDrsLDsuZgKICAgICAgICBzZWxmLmJ0"
    "bl9yZXNldCA9IFF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi7LSI6riw7ZmUIikKICAgICAgICBrZXlfcm93LmFkZFdpZGdldChzZWxmLmJ0bl9yZXNldCkKICAg"
    "ICAgICByaWdodC5hZGRMYXlvdXQoa2V5X3JvdykKCiAgICAgICAgcm9vdC5hZGRMYXlvdXQocmlnaHQsIDMpCgogICAgICAgICMgU2lnbmFscwogICAgICAg"
    "IHNlbGYuY291bnRlcl9saXN0LmN1cnJlbnRSb3dDaGFuZ2VkLmNvbm5lY3Qoc2VsZi5sb2FkX2NvdW50ZXIpCiAgICAgICAgc2VsZi5jb3VudGVyX2xpc3Qu"
    "aXRlbURvdWJsZUNsaWNrZWQuY29ubmVjdChsYW1iZGEgKl86IHNlbGYucmVuYW1lX2NvdW50ZXIoKSkKICAgICAgICBzZWxmLnRibC5jdXJyZW50Q2VsbENo"
    "YW5nZWQuY29ubmVjdChzZWxmLnN5bmNfa2V5X2VkaXRvcikKICAgICAgICBzZWxmLnRibC5pdGVtQ2hhbmdlZC5jb25uZWN0KGxhbWJkYSAqXzogc2VsZi5w"
    "ZXJzaXN0X2N1cnJlbnQoKSkKICAgICAgICBzZWxmLmNfYWRkLmNsaWNrZWQuY29ubmVjdChzZWxmLmFkZF9jb3VudGVyKQogICAgICAgIHNlbGYuY19kZWwu"
    "Y2xpY2tlZC5jb25uZWN0KHNlbGYuZGVsX2NvdW50ZXIpCiAgICAgICAgc2VsZi5idG5fYXBwbHlfa2V5LmNsaWNrZWQuY29ubmVjdChzZWxmLmFwcGx5X2hv"
    "dGtleSkKICAgICAgICBzZWxmLmJ0bl9yZXNldC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5yZXNldF9ob3RrZXlzKQoKICAgICAgICAjIEluaXQKICAgICAgICBz"
    "ZWxmLnJlbG9hZF9jb3VudGVycygpCgogICAgIyAtLS0tLS0tLS0tIERhdGEgaGVscGVycyAtLS0tLS0tLS0tCiAgICBkZWYgX3Byb2plY3Qoc2VsZik6CiAg"
    "ICAgICAgcmV0dXJuIHNlbGYud29yay5jdXJyZW50X3Byb2plY3QoKQoKICAgIGRlZiBfc2hlZXRzKHNlbGYpOgogICAgICAgIHAgPSBzZWxmLl9wcm9qZWN0"
    "KCkKICAgICAgICBpZiBwIGlzIE5vbmU6IHJldHVybiBOb25lCiAgICAgICAgcmV0dXJuIHAuc2V0ZGVmYXVsdCgiaG90a2V5X3NoZWV0c19nbG9iYWwiLCBb"
    "XSkKCiAgICBkZWYgX2Vuc3VyZV9maXJzdChzZWxmKToKICAgICAgICBwID0gc2VsZi5fcHJvamVjdCgpCiAgICAgICAgaWYgcCBpcyBOb25lOiByZXR1cm4K"
    "ICAgICAgICBzaGVldHMgPSBzZWxmLl9zaGVldHMoKQogICAgICAgIGlmIHNoZWV0czoKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgIyBpbml0aWFsaXpl"
    "IGZyb20gdmVoaWNsZV9zZXQKICAgICAgICB2c2V0ID0gcC5nZXQoInZlaGljbGVfc2V0IiwgW10pCiAgICAgICAgaXRlbXMgPSBbeyLsiJzrsogiOiBpKzEs"
    "ICLssKjsooXrqoUiOiByb3cuZ2V0KCLssKjsooXrqoUiLCIiKSwgIuuLqOy2le2CpCI6ICIifSBmb3IgaSwgcm93IGluIGVudW1lcmF0ZSh2c2V0KV0KICAg"
    "ICAgICBzaGVldHMuYXBwZW5kKHsibmFtZSI6IjEiLCJpdGVtcyI6aXRlbXN9KQogICAgICAgIHNhdmVfZGF0YShzZWxmLndvcmsuZGF0YSkKCiAgICAjIC0t"
    "LS0tLS0tLS0gTG9hZGluZyAtLS0tLS0tLS0tCiAgICBkZWYgbG9hZF9kaXIoc2VsZiwgKl8pOgogICAgICAgIHNlbGYucmVsb2FkX2NvdW50ZXJzKCkKCiAg"
    "ICBkZWYgcmVsb2FkX2NvdW50ZXJzKHNlbGYsIHByZWZlcnJlZF9pbmRleD1Ob25lKToKICAgICAgICBzZWxmLl9lbnN1cmVfZmlyc3QoKQogICAgICAgIHNl"
    "bGYuY291bnRlcl9saXN0LmJsb2NrU2lnbmFscyhUcnVlKQogICAgICAgIHNlbGYuY291bnRlcl9saXN0LmNsZWFyKCkKICAgICAgICBzaGVldHMgPSBzZWxm"
    "Ll9zaGVldHMoKSBvciBbXQogICAgICAgIGZvciBzIGluIHNoZWV0czoKICAgICAgICAgICAgc2VsZi5jb3VudGVyX2xpc3QuYWRkSXRlbShzdHIocy5nZXQo"
    "Im5hbWUiLCIxIikpKQogICAgICAgIHNlbGYuY291bnRlcl9saXN0LmJsb2NrU2lnbmFscyhGYWxzZSkKICAgICAgICBpZiBzZWxmLmNvdW50ZXJfbGlzdC5j"
    "b3VudCgpOgogICAgICAgICAgICAjIOq4sOuzuOydgCDssqsg67KI7Ke4LCBwcmVmZXJyZWRfaW5kZXjqsIAg7J6I7Jy866m0IOq3uCDsnITsuZjrpbwg7Jqw"
    "7ISgIOyEoO2DnQogICAgICAgICAgICBpZiBwcmVmZXJyZWRfaW5kZXggaXMgTm9uZToKICAgICAgICAgICAgICAgIHByZWZlcnJlZF9pbmRleCA9IDAKICAg"
    "ICAgICAgICAgcHJlZmVycmVkX2luZGV4ID0gbWF4KDAsIG1pbihwcmVmZXJyZWRfaW5kZXgsIHNlbGYuY291bnRlcl9saXN0LmNvdW50KCkgLSAxKSkKICAg"
    "ICAgICAgICAgc2VsZi5jb3VudGVyX2xpc3Quc2V0Q3VycmVudFJvdyhwcmVmZXJyZWRfaW5kZXgpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgIyBJZiBu"
    "byBwcm9qZWN0IHlldCwgZG8gbm90aGluZwogICAgICAgICAgICBwYXNzCgogICAgZGVmIGxvYWRfY291bnRlcihzZWxmLCAqXyk6CiAgICAgICAgc2VsZi50"
    "YmwuYmxvY2tTaWduYWxzKFRydWUpCiAgICAgICAgc2VsZi50Ymwuc2V0Um93Q291bnQoMCkKICAgICAgICBzaGVldHMgPSBzZWxmLl9zaGVldHMoKSBvciBb"
    "XQogICAgICAgIGkgPSBzZWxmLmNvdW50ZXJfbGlzdC5jdXJyZW50Um93KCkKICAgICAgICBpZiAwIDw9IGkgPCBsZW4oc2hlZXRzKToKICAgICAgICAgICAg"
    "Zm9yIHJlYyBpbiBzaGVldHNbaV0uZ2V0KCJpdGVtcyIsIFtdKToKICAgICAgICAgICAgICAgIHIgPSBzZWxmLnRibC5yb3dDb3VudCgpOyBzZWxmLnRibC5p"
    "bnNlcnRSb3cocikKICAgICAgICAgICAgICAgICMgMOyXtDog7Iic67KILCAx7Je0OiDssKjsooXrqoUsIDLsl7Q6IOuLqOy2le2CpAogICAgICAgICAgICAg"
    "ICAgc2VsZi50Ymwuc2V0SXRlbShyLDAsUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oc3RyKHJlYy5nZXQoIuyInOuyiCIsIHIrMSkpKSkKICAgICAgICAg"
    "ICAgICAgIHNlbGYudGJsLnNldEl0ZW0ociwxLFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKHJlYy5nZXQoIuywqOyiheuqhSIsIiIpKSkKICAgICAgICAg"
    "ICAgICAgIHNlbGYudGJsLnNldEl0ZW0ociwyLFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKHJlYy5nZXQoIuuLqOy2le2CpCIsIiIpKSkKICAgICAgICAg"
    "ICAgICAgIGZvciBjIGluICgwLDEsMik6CiAgICAgICAgICAgICAgICAgICAgaXQgPSBzZWxmLnRibC5pdGVtKHIsYykKICAgICAgICAgICAgICAgICAgICBp"
    "ZiBpdDogaXQuc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyfFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpCgogICAgICAgIHNlbGYudGJs"
    "LmJsb2NrU2lnbmFscyhGYWxzZSkKICAgICAgICB0cnk6CiAgICAgICAgICAgIHNlbGYudGJsLnNldENvbHVtbldpZHRoKDAsIDM4KSAgIyDsiJzrsogg7Je0"
    "IOyVveqwhCDstpXshowKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICBwYXNzCiAgICAgICAgdHJ5OgogICAgICAgICAgICBzZWxmLnRi"
    "bC5zZXRDb2x1bW5XaWR0aCgxLCA4MCkgICMg7LCo7KKF66qFIOyXtCDquLDrs7gg7Y+tCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAg"
    "cGFzcwogICAgICAgIHNlbGYuc3luY19rZXlfZWRpdG9yKHNlbGYudGJsLmN1cnJlbnRSb3coKSwgMCwgLTEsIC0xKQogICAgIyAtLS0tLS0tLS0tIFBlcnNp"
    "c3QgLS0tLS0tLS0tLQogICAgZGVmIHBlcnNpc3RfY3VycmVudChzZWxmKToKICAgICAgICBwID0gc2VsZi5fcHJvamVjdCgpCiAgICAgICAgaWYgcCBpcyBO"
    "b25lOiByZXR1cm4KICAgICAgICBzaGVldHMgPSBzZWxmLl9zaGVldHMoKQogICAgICAgIGkgPSBzZWxmLmNvdW50ZXJfbGlzdC5jdXJyZW50Um93KCkKICAg"
    "ICAgICBpZiBzaGVldHMgaXMgTm9uZSBvciBub3QgKDAgPD0gaSA8IGxlbihzaGVldHMpKTogcmV0dXJuCiAgICAgICAgaXRlbXMgPSBbXQogICAgICAgIGZv"
    "ciByIGluIHJhbmdlKHNlbGYudGJsLnJvd0NvdW50KCkpOgogICAgICAgICAgICAjIDDsl7Q6IOyInOuyiCjtkZzsi5zsmqkpLCAx7Je0OiDssKjsooXrqoUs"
    "IDLsl7Q6IOuLqOy2le2CpAogICAgICAgICAgICBuYW1lX2l0ZW0gPSBzZWxmLnRibC5pdGVtKHIsMSkKICAgICAgICAgICAga2V5X2l0ZW0gID0gc2VsZi50"
    "YmwuaXRlbShyLDIpCiAgICAgICAgICAgIG5hbWUgPSBuYW1lX2l0ZW0udGV4dCgpLnN0cmlwKCkgaWYgbmFtZV9pdGVtIGVsc2UgIiIKICAgICAgICAgICAg"
    "a2V5ICA9IGtleV9pdGVtLnRleHQoKS5zdHJpcCgpIGlmIGtleV9pdGVtIGVsc2UgIiIKICAgICAgICAgICAgaWYgbmFtZToKICAgICAgICAgICAgICAgIGl0"
    "ZW1zLmFwcGVuZCh7IuyInOuyiCI6IHIrMSwgIuywqOyiheuqhSI6IG5hbWUsICLri6jstpXtgqQiOiBrZXl9KQogICAgICAgIHNoZWV0c1tpXVsiaXRlbXMi"
    "XSA9IGl0ZW1zCiAgICAgICAgIyBtaXJyb3JzCiAgICAgICAgaWYgaSA9PSAwOgogICAgICAgICAgICBwWyJob3RrZXlfaXRlbXNfZ2xvYmFsIl0gPSBpdGVt"
    "cwogICAgICAgICAgICBwWyJob3RrZXlzX2dsb2JhbCJdID0ge3JlY1si7LCo7KKF66qFIl06IHJlY1si64uo7LaV7YKkIl0gZm9yIHJlYyBpbiBpdGVtc30K"
    "ICAgICAgICBzYXZlX2RhdGEoc2VsZi53b3JrLmRhdGEpCgogICAgIyAtLS0tLS0tLS0tIENvdW50ZXIgb3BzIC0tLS0tLS0tLS0KICAgIGRlZiBhZGRfY291"
    "bnRlcihzZWxmKToKICAgICAgICBwID0gc2VsZi5fcHJvamVjdCgpCiAgICAgICAgaWYgcCBpcyBOb25lOiByZXR1cm4KICAgICAgICBzaGVldHMgPSBzZWxm"
    "Ll9zaGVldHMoKQogICAgICAgIG5leHRfbm8gPSAxICsgbGVuKHNoZWV0cyBvciBbXSkKICAgICAgICB2c2V0ID0gcC5nZXQoInZlaGljbGVfc2V0IiwgW10p"
    "CiAgICAgICAgaXRlbXMgPSBbeyLsiJzrsogiOiBpKzEsICLssKjsooXrqoUiOiByb3cuZ2V0KCLssKjsooXrqoUiLCIiKSwgIuuLqOy2le2CpCI6ICIifSBm"
    "b3IgaSwgcm93IGluIGVudW1lcmF0ZSh2c2V0KV0KICAgICAgICBzaGVldHMuYXBwZW5kKHsibmFtZSI6IHN0cihuZXh0X25vKSwgIml0ZW1zIjogaXRlbXN9"
    "KQogICAgICAgIHNhdmVfZGF0YShzZWxmLndvcmsuZGF0YSkKICAgICAgICBzZWxmLnJlbG9hZF9jb3VudGVycygpCiAgICAgICAgc2VsZi5jb3VudGVyX2xp"
    "c3Quc2V0Q3VycmVudFJvdyhzZWxmLmNvdW50ZXJfbGlzdC5jb3VudCgpLTEpCgogICAgZGVmIHJlbmFtZV9jb3VudGVyKHNlbGYpOgogICAgICAgIHNoZWV0"
    "cyA9IHNlbGYuX3NoZWV0cygpIG9yIFtdCiAgICAgICAgaSA9IHNlbGYuY291bnRlcl9saXN0LmN1cnJlbnRSb3coKQogICAgICAgIGlmIG5vdCAoMCA8PSBp"
    "IDwgbGVuKHNoZWV0cykpOiByZXR1cm4KICAgICAgICBjdXIgPSBzaGVldHNbaV0uZ2V0KCJuYW1lIiwiIikKICAgICAgICB0ZXh0LCBvayA9IFF0V2lkZ2V0"
    "cy5RSW5wdXREaWFsb2cuZ2V0VGV4dChzZWxmLCAi7Lm07Jq07YSwIOydtOumhCDsiJjsoJUiLCAi7J2066aEOiIsIHRleHQ9c3RyKGN1cikpCiAgICAgICAg"
    "aWYgb2sgYW5kIHRleHQuc3RyaXAoKToKICAgICAgICAgICAgc2hlZXRzW2ldWyJuYW1lIl0gPSB0ZXh0LnN0cmlwKCkKICAgICAgICAgICAgc2F2ZV9kYXRh"
    "KHNlbGYud29yay5kYXRhKQogICAgICAgICAgICBzZWxmLnJlbG9hZF9jb3VudGVycygpCiAgICAgICAgICAgIHNlbGYuY291bnRlcl9saXN0LnNldEN1cnJl"
    "bnRSb3coaSkKCiAgICBkZWYgZGVsX2NvdW50ZXIoc2VsZik6CiAgICAgICAgc2hlZXRzID0gc2VsZi5fc2hlZXRzKCkgb3IgW10KICAgICAgICBpID0gc2Vs"
    "Zi5jb3VudGVyX2xpc3QuY3VycmVudFJvdygpCiAgICAgICAgaWYgbm90ICgwIDw9IGkgPCBsZW4oc2hlZXRzKSk6IHJldHVybgogICAgICAgIGlmIFF0V2lk"
    "Z2V0cy5RTWVzc2FnZUJveC5xdWVzdGlvbihzZWxmLCLsgq3soJwg7ZmV7J24Iiwi7ZiE7J6sIOy5tOyatO2EsOulvCDsgq3soJztlaDquYzsmpQ/Iik9PVF0"
    "V2lkZ2V0cy5RTWVzc2FnZUJveC5ZZXM6CiAgICAgICAgICAgIHNoZWV0cy5wb3AoaSkKICAgICAgICAgICAgIyByZS1udW1iZXIgZGVmYXVsdCBuYW1lcyAx"
    "Li5uIGlmIG51bWVyaWMKICAgICAgICAgICAgZm9yIGlkeCwgcyBpbiBlbnVtZXJhdGUoc2hlZXRzLCAxKToKICAgICAgICAgICAgICAgIGlmIHN0cihzLmdl"
    "dCgibmFtZSIsIiIpKS5pc2RpZ2l0KCk6CiAgICAgICAgICAgICAgICAgICAgc1sibmFtZSJdID0gc3RyKGlkeCkKICAgICAgICAgICAgc2F2ZV9kYXRhKHNl"
    "bGYud29yay5kYXRhKQogICAgICAgICAgICAjIOyCreygnOuQnCDtla3rqqkg67CU66GcIOychCjrmJDripQg64+Z7J28IOychOy5mCnrpbwg7ISg7YOd7ZWY"
    "64+E66GdIOyalOyyrQogICAgICAgICAgICBwcmVmZXJyZWQgPSBpIC0gMQogICAgICAgICAgICBzZWxmLnJlbG9hZF9jb3VudGVycyhwcmVmZXJyZWRfaW5k"
    "ZXg9cHJlZmVycmVkKQoKICAgICMgLS0tLS0tLS0tLSBLZXkgZWRpdG9yIC0tLS0tLS0tLS0KICAgIGRlZiBzeW5jX2tleV9lZGl0b3Ioc2VsZiwgY3VyX3Jv"
    "dywgY3VyX2NvbCwgcHJldl9yb3csIHByZXZfY29sKToKICAgICAgICB0cnk6CiAgICAgICAgICAgIGtleSA9IHNlbGYudGJsLml0ZW0oY3VyX3JvdywgMiku"
    "dGV4dCgpIGlmIGN1cl9yb3cgaXMgbm90IE5vbmUgYW5kIGN1cl9yb3cgPj0gMCBlbHNlICIiCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAg"
    "ICAga2V5ID0gIiIKICAgICAgICBpZiBoYXNhdHRyKHNlbGYsICJrZXlfZWRpdCIpIGFuZCBoYXNhdHRyKHNlbGYua2V5X2VkaXQsICJzZXRLZXlTZXF1ZW5j"
    "ZSIpOgogICAgICAgICAgICBmcm9tIFB5UXQ1IGltcG9ydCBRdEd1aQogICAgICAgICAgICBzZWxmLmtleV9lZGl0LnNldEtleVNlcXVlbmNlKFF0R3VpLlFL"
    "ZXlTZXF1ZW5jZShrZXkpKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHNlbGYua2V5X2VkaXQuc2V0VGV4dChrZXkpCgogICAgZGVmIGFwcGx5X2hvdGtl"
    "eShzZWxmKToKICAgICAgICByID0gc2VsZi50YmwuY3VycmVudFJvdygpCiAgICAgICAgaWYgciA8IDA6CiAgICAgICAgICAgIFF0V2lkZ2V0cy5RTWVzc2Fn"
    "ZUJveC5pbmZvcm1hdGlvbihzZWxmLCLslYzrprwiLCLtlonsnYQg66i87KCAIOyEoO2Dne2VmOyEuOyalC4iKQogICAgICAgICAgICByZXR1cm4KICAgICAg"
    "ICBpZiBoYXNhdHRyKHNlbGYua2V5X2VkaXQsICJrZXlTZXF1ZW5jZSIpOgogICAgICAgICAgICBrZXkgPSBzZWxmLmtleV9lZGl0LmtleVNlcXVlbmNlKCku"
    "dG9TdHJpbmcoKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGtleSA9IHNlbGYua2V5X2VkaXQudGV4dCgpCiAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShy"
    "LDIsUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oa2V5KSkKICAgICAgICBzZWxmLnBlcnNpc3RfY3VycmVudCgpCgogICAgZGVmIHJlc2V0X2hvdGtleXMo"
    "c2VsZik6CiAgICAgICAgaWYgUXRXaWRnZXRzLlFNZXNzYWdlQm94LnF1ZXN0aW9uKHNlbGYsIuy0iOq4sO2ZlCIsIu2YhOyerCDsubTsmrTthLDsnZgg64uo"
    "7LaV7YKk66W8IOuqqOuRkCDruYTsmrjquYzsmpQ/IikhPVF0V2lkZ2V0cy5RTWVzc2FnZUJveC5ZZXM6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIGZv"
    "ciByIGluIHJhbmdlKHNlbGYudGJsLnJvd0NvdW50KCkpOgogICAgICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsMixRdFdpZGdldHMuUVRhYmxlV2lkZ2V0"
    "SXRlbSgiIikpCiAgICAgICAgCiAgICAgICAgc2VsZi5wZXJzaXN0X2N1cnJlbnQoKQoKIyAtLS0tLS0tLS0tLS0tLS0tIOywqOyiheq0gOumrDog7YWc7ZSM"
    "66a/IC0tLS0tLS0tLS0tLS0tLS0KY2xhc3MgV29ya1RlbXBsYXRlVGFiKFF0V2lkZ2V0cy5RV2lkZ2V0KToKICAgIGRlZiBfX2luaXRfXyhzZWxmLCB3b3Jr"
    "KToKICAgICAgICBzdXBlcigpLl9faW5pdF9fKHdvcmspCiAgICAgICAgc2VsZi53b3JrID0gd29yawoKICAgICAgICAjIOyghOyytCDroIjsnbTslYTsm4M6"
    "IOyijOy4oSDthZztlIzrpr8gLyDsmrDsuKEg6rWs7ISxCiAgICAgICAgcm9vdCA9IFF0V2lkZ2V0cy5RR3JpZExheW91dChzZWxmKQoKICAgICAgICAjIC0t"
    "LS0tIOyZvOyqvTog7J6F66Cl6re466O5IO2FnO2UjOumvyDrpqzsiqTtirggLS0tLS0KICAgICAgICByb290LmFkZFdpZGdldChRdFdpZGdldHMuUUxhYmVs"
    "KCLsnoXroKXqt7jro7kg7YWc7ZSM66a/IiksIDAsIDApCiAgICAgICAgc2VsZi5sc3QgPSBRdFdpZGdldHMuUUxpc3RXaWRnZXQoKQogICAgICAgICMg6rO8"
    "7JeF66qFIOumrOyKpO2KuCDtj60gMzAwcHgg6rOg7KCVCiAgICAgICAgc2VsZi5sc3Quc2V0Rml4ZWRXaWR0aCgyMDApCiAgICAgICAgc2VsZi5sc3Quc2V0"
    "TWluaW11bVdpZHRoKDIyMCkKICAgICAgICBzZWxmLmxzdC5zZXRNYXhpbXVtV2lkdGgoMjIwKQogICAgICAgIHJvb3QuYWRkV2lkZ2V0KHNlbGYubHN0LCAx"
    "LCAwLCAxLCAxKQoKICAgICAgICB0cGxfYnRucyA9IFF0V2lkZ2V0cy5RSEJveExheW91dCgpCiAgICAgICAgc2VsZi5iX2FkZCA9IFF0V2lkZ2V0cy5RUHVz"
    "aEJ1dHRvbigi7LaU6rCAIikKICAgICAgICBzZWxmLmJfZGVsID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCLsgq3soJwiKQogICAgICAgIGZvciBiIGluIChz"
    "ZWxmLmJfYWRkLCBzZWxmLmJfZGVsKToKICAgICAgICAgICAgdHBsX2J0bnMuYWRkV2lkZ2V0KGIpCiAgICAgICAgcm9vdC5hZGRMYXlvdXQodHBsX2J0bnMs"
    "IDIsIDApCgogICAgICAgICMgLS0tLS0g7Jik66W47Kq9OiDrsKntlqXrsojtmLggLyDsnoXroKXqt7jro7ko7YOtKSAvIOy5tOyatO2EsCAtLS0tLQogICAg"
    "ICAgICMg7Jik66W47Kq9IOyghOyytCDtjKjrhJDsnYQgd3JhcHBlcuuhnCDqsJDsi7gg7IOB64uoIOygleugrAogICAgICAgIHJpZ2h0X3dyYXBwZXIgPSBR"
    "dFdpZGdldHMuUVdpZGdldCgpCiAgICAgICAgcmlnaHRfd3JhcHBlcl9sYXlvdXQgPSBRdFdpZGdldHMuUVZCb3hMYXlvdXQocmlnaHRfd3JhcHBlcikKICAg"
    "ICAgICByaWdodF93cmFwcGVyX2xheW91dC5zZXRDb250ZW50c01hcmdpbnMoMCwgMCwgMCwgMCkKICAgICAgICByaWdodF93cmFwcGVyX2xheW91dC5zZXRB"
    "bGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduVG9wKQoKICAgICAgICByaWdodCA9IFF0V2lkZ2V0cy5RR3JpZExheW91dCgpCiAgICAgICAgIyDrsKntlqXrsojt"
    "mLggLyDtmZTsgrTtkZwgLyDsnoXroKXqt7jro7ko7YOtKSvsubTsmrTthLAg7IKs7J20IOqwgOuhnCDsl6zrsLEg7LWc7IaM7ZmUIOuwjyDsmrDsuKEg7JiB"
    "7JetIO2ZleyepQogICAgICAgIHJpZ2h0LnNldEhvcml6b250YWxTcGFjaW5nKDIpCiAgICAgICAgcmlnaHQuc2V0Q29sdW1uU3RyZXRjaCgwLCAwKSAgIyDr"
    "sKntlqXrsojtmLgg7Je0CiAgICAgICAgcmlnaHQuc2V0Q29sdW1uU3RyZXRjaCgxLCAwKSAgIyDtmZTsgrTtkZwg7Je0CiAgICAgICAgcmlnaHQuc2V0Q29s"
    "dW1uU3RyZXRjaCgyLCAxKSAgIyDsnoXroKXqt7jro7ko7YOtKSvsubTsmrTthLAg7Je07J2EIOqwgOyepSDrhJPqsowKICAgICAgICByaWdodF93cmFwcGVy"
    "X2xheW91dC5hZGRMYXlvdXQocmlnaHQpCiAgICAgICAgcm9vdC5hZGRXaWRnZXQocmlnaHRfd3JhcHBlciwgMCwgMSwgMywgMSkKCiAgICAgICAgIyAw7ZaJ"
    "OiDrsKntlqXsiJggKyDsg53shLEv7J6Q64+Z7IOd7ISxICjsoozsuKEg7KCV66CsLCDrsoTtirwg7J6R6rKMKQogICAgICAgIGZvcm0gPSBRdFdpZGdldHMu"
    "UUhCb3hMYXlvdXQoKQogICAgICAgICMgIuyeheugpSDqt7jro7kg6rWs7ISxIiDrnbzrsqgg7KCc6rGwLCDrsKntlqXsiJgg7ZaJ7J2EIOyijOy4oSDsoJXr"
    "oKwKICAgICAgICBmb3JtLmFkZFdpZGdldChRdFdpZGdldHMuUUxhYmVsKCLrsKntlqXsiJgiKSkKICAgICAgICBzZWxmLnNwaW4gPSBRdFdpZGdldHMuUVNw"
    "aW5Cb3goKQogICAgICAgIHNlbGYuc3Bpbi5zZXRSYW5nZSgxLCA0MCkKICAgICAgICBzZWxmLnNwaW4uc2V0VmFsdWUoMikKICAgICAgICAjIOuwqe2WpeyI"
    "mCDsiqTtlYDrsJXsiqQg6rCA66GcIO2BrOq4sCAy67CwIO2ZleuMgAogICAgICAgIHRyeToKICAgICAgICAgICAgdyA9IHNlbGYuc3Bpbi5zaXplSGludCgp"
    "LndpZHRoKCkKICAgICAgICAgICAgc2VsZi5zcGluLnNldEZpeGVkV2lkdGgoaW50KHcgKiAyKSkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAg"
    "ICAgICBwYXNzCiAgICAgICAgZm9ybS5hZGRXaWRnZXQoc2VsZi5zcGluKQogICAgICAgIHNlbGYuYl9tYWtlID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCLs"
    "g53shLEiKQogICAgICAgIHNlbGYuYl9hdXRvID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCLsnpDrj5nsg53shLEiKQogICAgICAgIHNlbGYuYl9tYWtlLnNl"
    "dEZpeGVkV2lkdGgoNjApCiAgICAgICAgc2VsZi5iX2F1dG8uc2V0Rml4ZWRXaWR0aCg4MCkKICAgICAgICBmb3JtLmFkZFdpZGdldChzZWxmLmJfbWFrZSkK"
    "ICAgICAgICBmb3JtLmFkZFdpZGdldChzZWxmLmJfYXV0bykKICAgICAgICBmb3JtLmFkZFN0cmV0Y2goMSkKICAgICAgICByaWdodC5hZGRMYXlvdXQoZm9y"
    "bSwgMCwgMCwgMSwgMykKCiAgICAgICAgIyAx7ZaJOiDrsKntlqXrsojtmLggLyDsnoXroKUg6re466O5KO2DrSkg652867KoCiAgICAgICAgbGJsX2RpciA9"
    "IFF0V2lkZ2V0cy5RTGFiZWwoIuuwqe2WpSDrsojtmLgiKQogICAgICAgIGxibF90YWJzID0gUXRXaWRnZXRzLlFMYWJlbCgi7J6F66ClIOq3uOujuSjtg60p"
    "IikKICAgICAgICByaWdodC5hZGRXaWRnZXQobGJsX2RpciwgMSwgMCkKICAgICAgICByaWdodC5hZGRXaWRnZXQobGJsX3RhYnMsIDEsIDIpCgogICAgICAg"
    "ICMgMn4z7ZaJOiDrsKntlqXrsojtmLgg66as7Iqk7Yq4KOyEuOuhnCDsoITssrQpLCDtmZTsgrTtkZwsIOyeheugpeq3uOujuSjtg60pICsg7Lm07Jq07YSw"
    "CiAgICAgICAgIyDrsKntlqXrsojtmLgg66as7Iqk7Yq4OiByb3cgMn4zIOyghOyytCDsgqzsmqkgKOy5tOyatO2EsCDsmIHsl63quYzsp4Ag7KG07J6sKQog"
    "ICAgICAgIHNlbGYuZGlyID0gUXRXaWRnZXRzLlFMaXN0V2lkZ2V0KCkKICAgICAgICBzZWxmLmRpci5zZXRTZWxlY3Rpb25Nb2RlKFF0V2lkZ2V0cy5RQWJz"
    "dHJhY3RJdGVtVmlldy5FeHRlbmRlZFNlbGVjdGlvbikKICAgICAgICAjIOuwqe2WpeuyiO2YuCDrpqzsiqTtirg6IOqwgOuhnCDtj63snYQg6riw7KG067O0"
    "64ukIDLrsLAg7KCV64+EIOuEk+qyjAogICAgICAgIHNlbGYuZGlyLnNldEZpeGVkV2lkdGgoMTAwKQogICAgICAgIHRyeToKICAgICAgICAgICAgc2VsZi5k"
    "aXIuc2V0TWluaW11bUhlaWdodCgyNTApCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgICAgIHJpZ2h0LmFkZFdpZGdl"
    "dChzZWxmLmRpciwgMiwgMCwgMiwgMSkKCiAgICAgICAgIyDtmZTsgrTtkZwg67KE7Yq8OiDrsKntlqXrsojtmLjsmYAg64+Z7J28IOuGkuydtChyb3dTcGFu"
    "PTIpCiAgICAgICAgdmJ0biA9IFF0V2lkZ2V0cy5RVkJveExheW91dCgpCiAgICAgICAgIyDsnIQv7JWE656YIOyKpO2KuOugiOy5mOuhnCDrsoTtirzsnYQg"
    "7IS466GcIOykkeyVmSDrsLDsuZgKICAgICAgICB2YnRuLmFkZFN0cmV0Y2goMSkKICAgICAgICBzZWxmLnRvID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCLi"
    "lrYiKQogICAgICAgIHNlbGYuZnIgPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIuKXgCIpCiAgICAgICAgdmJ0bi5hZGRXaWRnZXQoc2VsZi50bykKICAgICAg"
    "ICB2YnRuLmFkZFdpZGdldChzZWxmLmZyKQogICAgICAgIHZidG4uYWRkU3RyZXRjaCgxKQogICAgICAgICMg7ZmU7IK07ZGcIOuyhO2KvOydhCDsl7TsnZgg"
    "7Jik66W47Kq97Jy866GcIOygleugrO2VmOyXrCDsnoXroKXqt7jro7kg7YOtIOyqveyXkCDqsIDquZ3qsowg67Cw7LmYCiAgICAgICAgcmlnaHQuYWRkTGF5"
    "b3V0KHZidG4sIDIsIDEsIDIsIDEsIGFsaWdubWVudD1RdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKCiAgICAgICAg"
    "IyDsnoXroKUg6re466O5KO2DrSk6IOychOyqvSDsmIHsl60ocm93IDIpCiAgICAgICAgc2VsZi50YWJzID0gUXRXaWRnZXRzLlFMaXN0V2lkZ2V0KCkKICAg"
    "ICAgICAjIOqwgOuhnCDrsKntlqXsnLzroZzripQg66CI7J207JWE7JuDIOqzteqwhOydhCDqvYkg7LGE7Jqw64+E66GdIOyEpOyglQogICAgICAgIHNlbGYu"
    "dGFicy5zZXRTaXplUG9saWN5KFF0V2lkZ2V0cy5RU2l6ZVBvbGljeS5FeHBhbmRpbmcsIFF0V2lkZ2V0cy5RU2l6ZVBvbGljeS5QcmVmZXJyZWQpCiAgICAg"
    "ICAgIyDtg60g7JiB7JetIOyEuOuhnCDtgazquLAg7KGw7KCVICjrhIjrrLQg7Luk7KeA7KeAIOyViuuPhOuhnSDsg4HtlZwg7ISk7KCVKQogICAgICAgIHRy"
    "eToKICAgICAgICAgICAgc2VsZi50YWJzLnNldE1heGltdW1IZWlnaHQoMTAwKQogICAgICAgICAgICBzZWxmLnRhYnMuc2V0TWluaW11bUhlaWdodCgxMDAp"
    "CiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgICAgIHJpZ2h0LmFkZFdpZGdldChzZWxmLnRhYnMsIDIsIDIsIDEsIDEp"
    "CgoKICAgICAgICAjIOy5tOyatO2EsDog7J6F66ClIOq3uOujuSjtg60pIOyVhOuemChyb3cgMywgY29sIDIpCiAgICAgICAgY291bnRlciA9IFF0V2lkZ2V0"
    "cy5RVkJveExheW91dCgpCiAgICAgICAgbGJsX2NvdW50ZXIgPSBRdFdpZGdldHMuUUxhYmVsKCLsubTsmrTthLAiKQogICAgICAgIGNvdW50ZXIuYWRkV2lk"
    "Z2V0KGxibF9jb3VudGVyKQogICAgICAgIHNlbGYudGJsID0gUXRXaWRnZXRzLlFUYWJsZVdpZGdldCgwLCAzKQogICAgICAgICMg6rCA66Gc64qUIO2Zleye"
    "pSwg7IS466Gc64qUIOqzoOyglSDrhpLsnbQg7IKs7JqpCiAgICAgICAgc2VsZi50Ymwuc2V0U2l6ZVBvbGljeShRdFdpZGdldHMuUVNpemVQb2xpY3kuRXhw"
    "YW5kaW5nLCBRdFdpZGdldHMuUVNpemVQb2xpY3kuRml4ZWQpCiAgICAgICAgc2VsZi50Ymwuc2V0Rml4ZWRIZWlnaHQoMjUwKSAgICMg7IS466GcIO2BrOq4"
    "sCDsobDsoJUgKOyeheugpeq3uOujuSDtg63snYQg7KSE7J206rOgIOy5tOyatO2EsOuKlCDtgazqsowpCiAgICAgICAgc2VsZi50Ymwuc2V0SG9yaXpvbnRh"
    "bEhlYWRlckxhYmVscyhbIuy5tOyatO2EsCIsICLrsKntlqUiLCAi7ZGc7Iuc66qFIl0pCiAgICAgICAgc2VsZi50YmwuaG9yaXpvbnRhbEhlYWRlcigpLnNl"
    "dERlZmF1bHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlcikKICAgICAgICBzZWxmLnRibC52ZXJ0aWNhbEhlYWRlcigpLnNldFZpc2libGUoRmFs"
    "c2UpCiAgICAgICAgIyDsubTsmrTthLAg7YWc7ZSM66a/IO2FjOydtOu4lOydgCDsubTsmrTthLAv67Cp7Zal7J2AIOyeoOq3uOqzoCwg7ZGc7Iuc66qF66eM"
    "IOyImOyglSDqsIDriqXtlZjrj4TroZ0g7ISk7KCVCiAgICAgICAgc2VsZi50Ymwuc2V0RWRpdFRyaWdnZXJzKAogICAgICAgICAgICBRdFdpZGdldHMuUUFi"
    "c3RyYWN0SXRlbVZpZXcuRG91YmxlQ2xpY2tlZAogICAgICAgICAgICB8IFF0V2lkZ2V0cy5RQWJzdHJhY3RJdGVtVmlldy5FZGl0S2V5UHJlc3NlZAogICAg"
    "ICAgICkKICAgICAgICAjIOy5tOyatO2EsCDthZztlIzrpr8g7YWM7J2067iUIO2PsO2KuCDtgazquLAg7LaV7IaMICjsnoXroKXqt7jro7kg7Iuc7Yq47JmA"
    "IOycoOyCrO2VmOqyjCkKICAgICAgICB0cnk6CiAgICAgICAgICAgIGYgPSBzZWxmLnRibC5mb250KCkKICAgICAgICAgICAgaWYgZi5wb2ludFNpemUoKSA+"
    "IDA6CiAgICAgICAgICAgICAgICBmLnNldFBvaW50U2l6ZShtYXgoOCwgZi5wb2ludFNpemUoKSAtIDIpKQogICAgICAgICAgICAgICAgc2VsZi50Ymwuc2V0"
    "Rm9udChmKQogICAgICAgICAgICAgICAgc2VsZi50YmwuaG9yaXpvbnRhbEhlYWRlcigpLnNldEZvbnQoZikKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgog"
    "ICAgICAgICAgICBwYXNzCiAgICAgICAgIyDtlokg64aS7J2066W8IOyVveqwhCDspITsl6zshJwg67Cp7ZalIOyXtCDshLjroZwg7YGs6riw66W8IDEwIOyg"
    "leuPhCDstpXshowKICAgICAgICB0cnk6CiAgICAgICAgICAgIHZoID0gc2VsZi50YmwudmVydGljYWxIZWFkZXIoKQogICAgICAgICAgICBoID0gdmguZGVm"
    "YXVsdFNlY3Rpb25TaXplKCkKICAgICAgICAgICAgaWYgaCA+IDEyOgogICAgICAgICAgICAgICAgdmguc2V0RGVmYXVsdFNlY3Rpb25TaXplKG1heCgxMCwg"
    "aCAtIDEwKSkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICBwYXNzCiAgICAgICAgIyDsubTsmrTthLAv67KI7Zi4L+2RnOyLnOuqhSDs"
    "l7Qg6rWs7ISxOgogICAgICAgICMgLSAw7Je0KOy5tOyatO2EsCksIDHsl7Qo67Cp7ZalKeydgCDqsIDsmrTrjbAg7KCV66CsCiAgICAgICAgIyAtIDLsl7Qo"
    "7ZGc7Iuc66qFKeydgCDqsIDroZwg7IKs7J207KaI66W8IOuEk+qyjCDsgqzsmqkKICAgICAgICB0cnk6CiAgICAgICAgICAgIGZvciByIGluIHJhbmdlKHNl"
    "bGYudGJsLnJvd0NvdW50KCkpOgogICAgICAgICAgICAgICAgaXRfY291bnRlciA9IHNlbGYudGJsLml0ZW0ociwgMCkKICAgICAgICAgICAgICAgIGlmIGl0"
    "X2NvdW50ZXI6CiAgICAgICAgICAgICAgICAgICAgaXRfY291bnRlci5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXIgfCBRdENvcmUu"
    "UXQuQWxpZ25WQ2VudGVyKQogICAgICAgICAgICAgICAgaXRfZGlyID0gc2VsZi50YmwuaXRlbShyLCAxKQogICAgICAgICAgICAgICAgaWYgaXRfZGlyOgog"
    "ICAgICAgICAgICAgICAgICAgIGl0X2Rpci5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXIgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVy"
    "KQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIHBhc3MKICAgICAgICB0cnk6CiAgICAgICAgICAgIGJhc2VfdyA9IHNlbGYudGJsLmNv"
    "bHVtbldpZHRoKDIpIG9yIDEwMAogICAgICAgICAgICBzZWxmLnRibC5zZXRDb2x1bW5XaWR0aCgyLCBpbnQoYmFzZV93ICogMikpCiAgICAgICAgZXhjZXB0"
    "IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgICAgICMg67Cp7ZalIOyXtCgx7Je0KeydmCDqsIDroZwg7IKs7J207KaI66W8IDVweCDsoJXrj4Qg"
    "7LaV7IaMCiAgICAgICAgdHJ5OgogICAgICAgICAgICB3X2RpciA9IHNlbGYudGJsLmNvbHVtbldpZHRoKDEpIG9yIDQwCiAgICAgICAgICAgIHNlbGYudGJs"
    "LnNldENvbHVtbldpZHRoKDEsIG1heCgxMCwgd19kaXIgLSA1KSkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICBwYXNzCiAgICAgICAg"
    "IyDsl7Qg6rCA66Gc7YGs6riw66W8IOqwgeqwgSAxLzLroZwg7LaV7IaMCiAgICAgICAgdHJ5OgogICAgICAgICAgICBmb3IgYyBpbiByYW5nZSgzKToKICAg"
    "ICAgICAgICAgICAgIHcgPSBzZWxmLnRibC5jb2x1bW5XaWR0aChjKQogICAgICAgICAgICAgICAgaWYgdyA+IDA6CiAgICAgICAgICAgICAgICAgICAgc2Vs"
    "Zi50Ymwuc2V0Q29sdW1uV2lkdGgoYywgbWF4KDIwLCBpbnQodyAqIDAuNSkpKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIHBhc3MK"
    "ICAgICAgICAjIOy5tOyatO2EsCDsl7QoMOyXtCkg6rCA66GcIO2BrOq4sOulvCAxMTDsnLzroZwg7ISk7KCVCiAgICAgICAgdHJ5OgogICAgICAgICAgICBz"
    "ZWxmLnRibC5zZXRDb2x1bW5XaWR0aCgwLCAxMTApCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgICAgICMg7KCE7LK0"
    "IO2PreydhCDsgrTsp50g7KSE7Jes7IScIOqzteqwhCDtmZXrs7QKICAgICAgICB0cnk6CiAgICAgICAgICAgIGN3ID0gc2VsZi50Ymwuc2l6ZUhpbnQoKS53"
    "aWR0aCgpCiAgICAgICAgICAgIGlmIGN3ID4gMjA6CiAgICAgICAgICAgICAgICBwYXNzICAjIGZpeGVkIHdpZHRoIOygnOqxsAogICAgICAgIGV4Y2VwdCBF"
    "eGNlcHRpb246CiAgICAgICAgICAgIHBhc3MKICAgICAgICBjb3VudGVyLmFkZFdpZGdldChzZWxmLnRibCkKCiAgICAgICAgIyDsubTsmrTthLAg7Iuc7Yq4"
    "OiDshKDtg53rkJwg7ZaJ7J2EIOyCreygnO2VoCDsiJgg7J6I64qUIOuyhO2KvCDstpTqsIAKICAgICAgICBidG5fcm93ID0gUXRXaWRnZXRzLlFIQm94TGF5"
    "b3V0KCkKICAgICAgICBidG5fcm93LmFkZFN0cmV0Y2goMSkKICAgICAgICBzZWxmLmJ0bl9jb3VudGVyX2RlbCA9IFF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi"
    "7ISg7YOdIOyCreygnCIpCiAgICAgICAgYnRuX3Jvdy5hZGRXaWRnZXQoc2VsZi5idG5fY291bnRlcl9kZWwpCiAgICAgICAgY291bnRlci5hZGRMYXlvdXQo"
    "YnRuX3JvdykKCiAgICAgICAgc2VsZi50YmwuaXRlbUNoYW5nZWQuY29ubmVjdChsYW1iZGEgKl86IHNlbGYucGVyc2lzdF9jdXJyZW50KCkpCgogICAgICAg"
    "ICMg7Lm07Jq07YSwIOugiOydtOyVhOybg+ydhCDrsJTroZwg7JWE656YIO2WieyXkCDrsLDsuZjtlZjqs6AsIO2WiSDruYTsnKjsnYQg7KGw7KCV7ZWY7Jes"
    "IOyDgeuLqOycvOuhnCDrgYzslrTsmKzrprwKICAgICAgICByaWdodC5hZGRMYXlvdXQoY291bnRlciwgMywgMiwgMSwgMSkKCiAgICAgICAgIyDsnIQv7JWE"
    "656YIOyYgeyXrSDruYTsnKggKOyeheugpSDqt7jro7kg7JiB7Jet7J2EIOykhOydtOqzoCDsubTsmrTthLAg7JiB7Jet7J2EIO2CpOybgCkKICAgICAgICBy"
    "aWdodC5zZXRSb3dTdHJldGNoKDIsIDEpICAgIyDtg60g7JiB7JetCiAgICAgICAgcmlnaHQuc2V0Um93U3RyZXRjaCgzLCAzKSAgICMg7Lm07Jq07YSwIOyY"
    "geyXrQoKICAgICAgICAjIOyLnOq3uOuEkCDsl7DqsrAKICAgICAgICBzZWxmLmJfbWFrZS5jbGlja2VkLmNvbm5lY3Qoc2VsZi5tYWtlX2RpcnMpCiAgICAg"
    "ICAgc2VsZi5iX2F1dG8uY2xpY2tlZC5jb25uZWN0KHNlbGYubWFrZV9kaXJzKQogICAgICAgIHNlbGYudG8uY2xpY2tlZC5jb25uZWN0KHNlbGYuYWRkX2dy"
    "b3VwKQogICAgICAgIHNlbGYuZnIuY2xpY2tlZC5jb25uZWN0KHNlbGYucmVtb3ZlX2dyb3VwKQogICAgICAgIHNlbGYuYl9hZGQuY2xpY2tlZC5jb25uZWN0"
    "KHNlbGYuYWRkX3RwbCkKICAgICAgICBzZWxmLmJfZGVsLmNsaWNrZWQuY29ubmVjdChzZWxmLmRlbF90cGwpCiAgICAgICAgc2VsZi5sc3QuY3VycmVudFJv"
    "d0NoYW5nZWQuY29ubmVjdChzZWxmLmxvYWRfdHBsKQogICAgICAgICMg7Lm07Jq07YSwIOyLnO2KuCAtIOyEoO2DneuQnCDtlokg7IKt7KCcIOuyhO2KvAog"
    "ICAgICAgIHNlbGYuYnRuX2NvdW50ZXJfZGVsLmNsaWNrZWQuY29ubmVjdChzZWxmLmRlbF9jb3VudGVyX3JvdykKICAgICAgICAjIO2FnO2UjOumvyDtla3r"
    "qqkg642U67iU7YG066atIOyLnCDsnbTrpoQg7IiY7KCVIO2MneyXhQogICAgICAgIHNlbGYubHN0Lml0ZW1Eb3VibGVDbGlja2VkLmNvbm5lY3Qoc2VsZi5y"
    "ZW5fdHBsKQogICAgICAgICMg7J6F66ClIOq3uOujuSjtg60pIOuNlOu4lO2BtOumrSDsi5wg64uo7LaV7YKkIOyEpOyglSDtjJ3sl4UKICAgICAgICBzZWxm"
    "LnRhYnMuaXRlbURvdWJsZUNsaWNrZWQuY29ubmVjdChzZWxmLl9vbl9ncm91cF90YWJfZG91YmxlX2NsaWNrZWQpCiAgICBkZWYgY3VycmVudF9wcm9qZWN0"
    "KHNlbGYpOiByZXR1cm4gc2VsZi53b3JrLmN1cnJlbnRfcHJvamVjdCgpCgogICAgZGVmIGxvYWQoc2VsZiwgcHJlZmVycmVkX2luZGV4PU5vbmUpOgogICAg"
    "ICAgIHA9c2VsZi5jdXJyZW50X3Byb2plY3QoKTsgc2VsZi5sc3QuYmxvY2tTaWduYWxzKFRydWUpOyBzZWxmLmxzdC5jbGVhcigpCiAgICAgICAgaWYgcDoK"
    "ICAgICAgICAgICAgZm9yIHQgaW4gcC5nZXQoInRlbXBsYXRlcyIsW10pOiBzZWxmLmxzdC5hZGRJdGVtKHQuZ2V0KCJuYW1lIiwiKOustOygnCkiKSkKICAg"
    "ICAgICBzZWxmLmxzdC5ibG9ja1NpZ25hbHMoRmFsc2UpCiAgICAgICAgaWYgc2VsZi5sc3QuY291bnQoKToKICAgICAgICAgICAgaWYgcHJlZmVycmVkX2lu"
    "ZGV4IGlzIE5vbmU6CiAgICAgICAgICAgICAgICBwcmVmZXJyZWRfaW5kZXggPSAwCiAgICAgICAgICAgIHByZWZlcnJlZF9pbmRleCA9IG1heCgwLCBtaW4o"
    "cHJlZmVycmVkX2luZGV4LCBzZWxmLmxzdC5jb3VudCgpIC0gMSkpCiAgICAgICAgICAgIHNlbGYubHN0LnNldEN1cnJlbnRSb3cocHJlZmVycmVkX2luZGV4"
    "KQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHNlbGYuY2xlYXJfcmlnaHQoKQoKICAgIGRlZiBjbGVhcl9yaWdodChzZWxmKToKICAgICAgICBzZWxmLmRp"
    "ci5jbGVhcigpOyBzZWxmLnRhYnMuY2xlYXIoKTsgc2VsZi50Ymwuc2V0Um93Q291bnQoMCkKCiAgICBkZWYgX3JlYnVpbGRfZGlyX2xpc3Qoc2VsZik6CiAg"
    "ICAgICAgIiIi7ZiE7J6sIOuwqe2WpeyImOyZgCDsnoXroKXqt7jro7ko7YOtKeyXkCDrp57stpTslrQg64Ko7J2AIOuwqe2WpeuyiO2YuCDrpqzsiqTtirjr"
    "pbwg64uk7IucIOyDneyEsS4iIiIKICAgICAgICBpbXBvcnQgcmUgYXMgX3JlCiAgICAgICAgc2VsZi5kaXIuY2xlYXIoKQogICAgICAgIHRyeToKICAgICAg"
    "ICAgICAgdG90YWwgPSBzZWxmLnNwaW4udmFsdWUoKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIHRvdGFsID0gMAogICAgICAgIGFs"
    "bF9kaXJzID0gc2V0KHJhbmdlKDEsIHRvdGFsICsgMSkpCiAgICAgICAgdXNlZCA9IHNldCgpCiAgICAgICAgZm9yIGkgaW4gcmFuZ2Uoc2VsZi50YWJzLmNv"
    "dW50KCkpOgogICAgICAgICAgICBsYWJlbCA9IHNlbGYudGFicy5pdGVtKGkpLnRleHQoKQogICAgICAgICAgICBmb3IgdG9rIGluIF9yZS5maW5kYWxsKHIi"
    "XGQrIiwgc3RyKGxhYmVsKSk6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgdXNlZC5hZGQoaW50KHRvaykpCiAgICAgICAgICAg"
    "ICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICByZW1haW4gPSBzb3J0ZWQoYWxsX2RpcnMgLSB1c2VkKQog"
    "ICAgICAgIGZvciBuIGluIHJlbWFpbjoKICAgICAgICAgICAgc2VsZi5kaXIuYWRkSXRlbShzdHIobikpCgogICAgZGVmIG1ha2VfZGlycyhzZWxmKToKICAg"
    "ICAgICAjIOuwqe2WpeuyiO2YuCDrpqzsiqTtirjrpbwg7IOI66GcIOyDneyEse2VmOuQmCwg7J2066+4IOyeheugpeq3uOujuSjtg60p7JeQIO2PrO2VqOuQ"
    "nCDrsKntlqXsnYAg7KCc7Jm4CiAgICAgICAgc2VsZi5fcmVidWlsZF9kaXJfbGlzdCgpCgogICAgZGVmIGFkZF9ncm91cChzZWxmKToKICAgICAgICBzZWxz"
    "PVtpdC50ZXh0KCkgZm9yIGl0IGluIHNlbGYuZGlyLnNlbGVjdGVkSXRlbXMoKV0KICAgICAgICBpZiBub3Qgc2VsczogCiAgICAgICAgICAgIHJldHVybgog"
    "ICAgICAgIHRyeToKICAgICAgICAgICAgbnVtcz1zb3J0ZWQoaW50KHgpIGZvciB4IGluIHNlbHMpCiAgICAgICAgICAgIGxhYmVsPSItIi5qb2luKHN0cihu"
    "KSBmb3IgbiBpbiBudW1zKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIGxhYmVsPSItIi5qb2luKHNlbHMpCiAgICAgICAgc2VsZi50"
    "YWJzLmFkZEl0ZW0obGFiZWwpCiAgICAgICAgIyDshKDtg53tlZwg67Cp7Zal67KI7Zi464qUIOyCrOyaqSDsspjrpqwg4oaSIOuCqOydgCDrsKntlqXrp4wg"
    "66as7Iqk7Yq47JeQIO2RnOyLnAogICAgICAgIHNlbGYuX3JlYnVpbGRfZGlyX2xpc3QoKQogICAgICAgIHNlbGYucGVyc2lzdF9jdXJyZW50KCkKCiAgICBk"
    "ZWYgcmVtb3ZlX2dyb3VwKHNlbGYpOgogICAgICAgICMg7ISg7YOd65CcIOq3uOujuSjtg60p7J2EIOygnOqxsO2VnCDrkqQsIOuCqOydgCDqt7jro7kg7KCV"
    "67O066W8IOq4sOykgOycvOuhnCDrsKntlqXrsojtmLgg66as7Iqk7Yq466W8IOyerOqzhOyCsAogICAgICAgIGZvciBpdCBpbiBzZWxmLnRhYnMuc2VsZWN0"
    "ZWRJdGVtcygpOgogICAgICAgICAgICBzZWxmLnRhYnMudGFrZUl0ZW0oc2VsZi50YWJzLnJvdyhpdCkpCiAgICAgICAgc2VsZi5fcmVidWlsZF9kaXJfbGlz"
    "dCgpCiAgICAgICAgc2VsZi5wZXJzaXN0X2N1cnJlbnQoKQoKCiAgICBkZWYgX29uX2dyb3VwX3RhYl9kb3VibGVfY2xpY2tlZChzZWxmLCBpdGVtKToKICAg"
    "ICAgICAiIiLssKjsooXqtIDrpqwgPiDsubTsmrTthLAg7YWc7ZSM66a/IOq0gOumrDog7J6F66Cl6re466O5KO2DrSkg64uo7LaV7YKkIOyLnO2KuOulvCDs"
    "hKTsoJUuIiIiCiAgICAgICAgaWYgaXRlbSBpcyBOb25lOgogICAgICAgICAgICByZXR1cm4KICAgICAgICBsYWJlbCA9IGl0ZW0udGV4dCgpIG9yICIiCiAg"
    "ICAgICAgaW1wb3J0IHJlIGFzIF9yZQogICAgICAgIGRpcnMgPSBbXQogICAgICAgIGZvciBwYXJ0IGluIF9yZS5zcGxpdChyIlteMC05XSsiLCBsYWJlbCk6"
    "CiAgICAgICAgICAgIGlmIHBhcnQuaXNkaWdpdCgpOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIGRpcnMuYXBwZW5kKGludChw"
    "YXJ0KSkKICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgIGRpcnMgPSBzb3J0ZWQoc2V0"
    "KGRpcnMpKQogICAgICAgIGlmIG5vdCBkaXJzOgogICAgICAgICAgICBRdFdpZGdldHMuUU1lc3NhZ2VCb3guaW5mb3JtYXRpb24oc2VsZiwgIuyVjOumvCIs"
    "ICLsnbQg7YOt7JeQ7IScIOuwqe2WpeuyiO2YuOulvCDssL7snYQg7IiYIOyXhuyKteuLiOuLpC4iKQogICAgICAgICAgICByZXR1cm4KCiAgICAgICAgcCA9"
    "IHNlbGYuY3VycmVudF9wcm9qZWN0KCkKICAgICAgICBpZiBwIGlzIE5vbmU6CiAgICAgICAgICAgIFF0V2lkZ2V0cy5RTWVzc2FnZUJveC5pbmZvcm1hdGlv"
    "bihzZWxmLCAi7JWM66a8IiwgIuuovOyggCDssKjsooUg7Jyg7ZiV7J2EIOyEoO2Dne2VmOyEuOyalC4iKQogICAgICAgICAgICByZXR1cm4KCiAgICAgICAg"
    "c2hlZXRzID0gcC5nZXQoImhvdGtleV9zaGVldHNfZ2xvYmFsIiwgW10pIG9yIFtdCiAgICAgICAgc2hlZXRfbmFtZXMgPSBbc3RyKHMuZ2V0KCJuYW1lIiwg"
    "IiIpIG9yICIiKSBmb3IgcyBpbiBzaGVldHNdCiAgICAgICAgaWYgbm90IHNoZWV0X25hbWVzOgogICAgICAgICAgICBRdFdpZGdldHMuUU1lc3NhZ2VCb3gu"
    "aW5mb3JtYXRpb24oc2VsZiwgIuyVjOumvCIsICLtmITsnqwg7LCo7KKFIOycoO2YleyXkCDrk7HroZ3rkJwg7Lm07Jq07YSwIOuLqOy2le2CpCDsi5ztirjq"
    "sIAg7JeG7Iq164uI64ukLiIpCiAgICAgICAgICAgIHJldHVybgoKICAgICAgICBkbGcgPSBRdFdpZGdldHMuUURpYWxvZyhzZWxmKQogICAgICAgIGRsZy5z"
    "ZXRXaW5kb3dUaXRsZSgi7J6F66Cl6re466O5IOuLqOy2le2CpCDshKTsoJUgKO2FnO2UjOumvykiKQogICAgICAgIHZib3ggPSBRdFdpZGdldHMuUVZCb3hM"
    "YXlvdXQoZGxnKQoKICAgICAgICAjIOywqOyiheycoO2YlSDrnbzrsqggKO2FnO2UjOumv+ydgCDtmITsnqwg7ZSE66Gc7KCd7Yq4IOqzoOyglSkKICAgICAg"
    "ICBmb3JtX3RvcCA9IFF0V2lkZ2V0cy5RRm9ybUxheW91dCgpCiAgICAgICAgZm9ybV90b3AuYWRkUm93KCLssKjsooXsnKDtmJU6IiwgUXRXaWRnZXRzLlFM"
    "YWJlbChwLmdldCgibmFtZSIsICIiKSBvciAiKOydtOumhCDsl4bsnYwpIikpCiAgICAgICAgdmJveC5hZGRMYXlvdXQoZm9ybV90b3ApCgogICAgICAgICMg"
    "7ZiE7J6sIOy5tOyatO2EsCDthYzsnbTruJTsl5DshJwg67Cp7Zal67OE66GcIOydtOuvuCDsp4DsoJXrkJwg7Iuc7Yq4IOydtOumhOydhCDsiJjsp5EKICAg"
    "ICAgICBjdXJyZW50X2J5X2RpciA9IHt9CiAgICAgICAgZm9yIHJvdyBpbiByYW5nZShzZWxmLnRibC5yb3dDb3VudCgpKToKICAgICAgICAgICAgZF9pdGVt"
    "ID0gc2VsZi50YmwuaXRlbShyb3csIDEpCiAgICAgICAgICAgIG5faXRlbSA9IHNlbGYudGJsLml0ZW0ocm93LCAwKQogICAgICAgICAgICBpZiBub3QgZF9p"
    "dGVtOgogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgZF90ZXh0ID0gZF9pdGVtLnRleHQoKS5zdHJpcCgpCiAgICAgICAgICAgIGlmIG5v"
    "dCBkX3RleHQ6CiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICBpZiBuX2l0ZW06CiAgICAgICAgICAgICAgICBjdXJyZW50X2J5X2Rpci5z"
    "ZXRkZWZhdWx0KGRfdGV4dCwgbl9pdGVtLnRleHQoKS5zdHJpcCgpKQoKICAgICAgICAjIOuwqe2WpeuzhCDsvaTrs7TrsJXsiqQKICAgICAgICBkaXJfbGF5"
    "b3V0ID0gUXRXaWRnZXRzLlFGb3JtTGF5b3V0KCkKICAgICAgICBkaXJfY29tYm9zID0ge30KCiAgICAgICAgZGVmIF9yZWZyZXNoX3ByZXZpZXdfYWxsKCk6"
    "CiAgICAgICAgICAgICMg7KCE7LK0IOuvuOumrOuztOq4sCDsmIHsl60g7LSI6riw7ZmUCiAgICAgICAgICAgIHdoaWxlIHByZXZpZXdfbGF5b3V0LmNvdW50"
    "KCk6CiAgICAgICAgICAgICAgICBpdGVtID0gcHJldmlld19sYXlvdXQudGFrZUF0KDApCiAgICAgICAgICAgICAgICB3ID0gaXRlbS53aWRnZXQoKQogICAg"
    "ICAgICAgICAgICAgaWYgdyBpcyBub3QgTm9uZToKICAgICAgICAgICAgICAgICAgICB3LmRlbGV0ZUxhdGVyKCkKCiAgICAgICAgICAgICMg6rCBIOuwqe2W"
    "peuzhOuhnCDqt7jro7nrsJXsiqTrpbwg66eM65Ok7Ja0IOyEoO2DneuQnCDsi5ztirjsnZgg64uo7LaV7YKk66W8IO2RnOyLnAogICAgICAgICAgICBmb3Ig"
    "ZCBpbiBkaXJzOgogICAgICAgICAgICAgICAgY29tYm8gPSBkaXJfY29tYm9zLmdldChkKQogICAgICAgICAgICAgICAgZ3JvdXBfYm94ID0gUXRXaWRnZXRz"
    "LlFHcm91cEJveChmIntkfeuyiCDrsKntlqUiKQogICAgICAgICAgICAgICAgZ2JfbGF5b3V0ID0gUXRXaWRnZXRzLlFWQm94TGF5b3V0KGdyb3VwX2JveCkK"
    "ICAgICAgICAgICAgICAgIGdiX2xheW91dC5zZXRDb250ZW50c01hcmdpbnMoNCwgNCwgNCwgNCkKICAgICAgICAgICAgICAgIGdiX2xheW91dC5zZXRTcGFj"
    "aW5nKDIpCgogICAgICAgICAgICAgICAgaWYgY29tYm8gaXMgTm9uZToKICAgICAgICAgICAgICAgICAgICBnYl9sYXlvdXQuYWRkV2lkZ2V0KFF0V2lkZ2V0"
    "cy5RTGFiZWwoIuuwqe2WpSDsvaTrs7TrsJXsiqTrpbwg7LC+7J2EIOyImCDsl4bsirXri4jri6QuIikpCiAgICAgICAgICAgICAgICAgICAgcHJldmlld19s"
    "YXlvdXQuYWRkV2lkZ2V0KGdyb3VwX2JveCkKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQoKICAgICAgICAgICAgICAgIHNoZWV0X25hbWUgPSBjb21i"
    "by5jdXJyZW50VGV4dCgpLnN0cmlwKCkKICAgICAgICAgICAgICAgIGlmIG5vdCBzaGVldF9uYW1lOgogICAgICAgICAgICAgICAgICAgIGdiX2xheW91dC5h"
    "ZGRXaWRnZXQoUXRXaWRnZXRzLlFMYWJlbCgi7ISg7YOd65CcIOuLqOy2le2CpCDsi5ztirjqsIAg7JeG7Iq164uI64ukLiIpKQogICAgICAgICAgICAgICAg"
    "ICAgIHByZXZpZXdfbGF5b3V0LmFkZFdpZGdldChncm91cF9ib3gpCiAgICAgICAgICAgICAgICAgICAgY29udGludWUKCiAgICAgICAgICAgICAgICB0YXJn"
    "ZXQgPSBOb25lCiAgICAgICAgICAgICAgICBmb3IgcyBpbiBzaGVldHM6CiAgICAgICAgICAgICAgICAgICAgaWYgc3RyKHMuZ2V0KCJuYW1lIiwgIiIpIG9y"
    "ICIiKSA9PSBzaGVldF9uYW1lOgogICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBzCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCgogICAg"
    "ICAgICAgICAgICAgaWYgdGFyZ2V0IGlzIE5vbmU6CiAgICAgICAgICAgICAgICAgICAgZ2JfbGF5b3V0LmFkZFdpZGdldChRdFdpZGdldHMuUUxhYmVsKGYi"
    "J3tzaGVldF9uYW1lfScg7Iuc7Yq466W8IOywvuydhCDsiJgg7JeG7Iq164uI64ukLiIpKQogICAgICAgICAgICAgICAgICAgIHByZXZpZXdfbGF5b3V0LmFk"
    "ZFdpZGdldChncm91cF9ib3gpCiAgICAgICAgICAgICAgICAgICAgY29udGludWUKCiAgICAgICAgICAgICAgICBpdGVtcyA9IHRhcmdldC5nZXQoIml0ZW1z"
    "IiwgW10pIG9yIFtdCiAgICAgICAgICAgICAgICBpZiBub3QgaXRlbXM6CiAgICAgICAgICAgICAgICAgICAgZ2JfbGF5b3V0LmFkZFdpZGdldChRdFdpZGdl"
    "dHMuUUxhYmVsKCLrk7HroZ3rkJwg64uo7LaV7YKk6rCAIOyXhuyKteuLiOuLpC4iKSkKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAg"
    "ICAgZm9yIHJlYyBpbiBpdGVtczoKICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxfdHh0ID0gc3RyKHJlYy5nZXQoIuywqOyiheuqhSIsICIiKSkKICAg"
    "ICAgICAgICAgICAgICAgICAgICAga2V5X3R4dCA9IHN0cihyZWMuZ2V0KCLri6jstpXtgqQiLCAiIikpCiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9"
    "IFF0V2lkZ2V0cy5RSEJveExheW91dCgpCiAgICAgICAgICAgICAgICAgICAgICAgIGxhYiA9IFF0V2lkZ2V0cy5RTGFiZWwoZiJ7bGFiZWxfdHh0fSDtgqQi"
    "KQogICAgICAgICAgICAgICAgICAgICAgICBlZGl0ID0gUXRXaWRnZXRzLlFMaW5lRWRpdChrZXlfdHh0KQogICAgICAgICAgICAgICAgICAgICAgICBlZGl0"
    "LnNldFJlYWRPbmx5KFRydWUpCiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXQuc2V0TWF4aW11bVdpZHRoKDgwKQogICAgICAgICAgICAgICAgICAgICAg"
    "ICByb3cuYWRkV2lkZ2V0KGxhYikKICAgICAgICAgICAgICAgICAgICAgICAgcm93LmFkZFdpZGdldChlZGl0KQogICAgICAgICAgICAgICAgICAgICAgICBn"
    "Yl9sYXlvdXQuYWRkTGF5b3V0KHJvdykKCiAgICAgICAgICAgICAgICBwcmV2aWV3X2xheW91dC5hZGRXaWRnZXQoZ3JvdXBfYm94KQoKICAgICAgICBkZWYg"
    "X29uX2Rpcl9jb21ib19jaGFuZ2VkKF9pZHgsIGQpOgogICAgICAgICAgICAjIOy9pOuztOuwleyKpCDrs4Dqsr0g7IucIOyghOyytCDrsKntlqUg66+466as"
    "67O06riw66W8IOuLpOyLnCDqt7jrprDri6QuCiAgICAgICAgICAgIF9yZWZyZXNoX3ByZXZpZXdfYWxsKCkKCiAgICAgICAgZm9yIGQgaW4gZGlyczoKICAg"
    "ICAgICAgICAgY29tYm8gPSBRdFdpZGdldHMuUUNvbWJvQm94KGRsZykKICAgICAgICAgICAgY29tYm8uYWRkSXRlbSgiIikgICMg6rO167CxIOyEoO2DnQog"
    "ICAgICAgICAgICBmb3IgbiBpbiBzaGVldF9uYW1lczoKICAgICAgICAgICAgICAgIGNvbWJvLmFkZEl0ZW0obikKICAgICAgICAgICAga2V5ID0gc3RyKGQp"
    "CiAgICAgICAgICAgIGJhc2UgPSBjdXJyZW50X2J5X2Rpci5nZXQoa2V5LCAiIikKICAgICAgICAgICAgaWYgYmFzZSBhbmQgYmFzZSBpbiBzaGVldF9uYW1l"
    "czoKICAgICAgICAgICAgICAgIGNvbWJvLnNldEN1cnJlbnRJbmRleChzaGVldF9uYW1lcy5pbmRleChiYXNlKSArIDEpCiAgICAgICAgICAgIGRpcl9jb21i"
    "b3NbZF0gPSBjb21ibwogICAgICAgICAgICBjb21iby5jdXJyZW50SW5kZXhDaGFuZ2VkLmNvbm5lY3QobGFtYmRhIGlkeCwgZGQ9ZDogX29uX2Rpcl9jb21i"
    "b19jaGFuZ2VkKGlkeCwgZGQpKQogICAgICAgICAgICBkaXJfbGF5b3V0LmFkZFJvdyhmIntkfeuyiCDrsKntlqUiLCBjb21ibykKCiAgICAgICAgdmJveC5h"
    "ZGRMYXlvdXQoZGlyX2xheW91dCkKCiAgICAgICAgIyDrr7jrpqzrs7TquLAg7JiB7JetCiAgICAgICAgIyDqt7jro7nrsJXsiqQg7IKs7JqpIOyLnCDsoJzr"
    "qqnqs7wg64K07Jqp7J20IOqyueyzkCDrs7TsnbTripQg7ZiE7IOB7J20IOyeiOyWtAogICAgICAgICMg7KCc66qpIOudvOuyqCArIOyKpO2BrOuhpCDsmIHs"
    "l60g7KGw7ZWp7Jy866GcIOuzgOqyvS4KICAgICAgICAjIOuvuOumrOuztOq4sCDsmIHsl606IFFHcm91cEJveCArIFFTY3JvbGxBcmVhIOyhsO2VqeycvOuh"
    "nCDqtazshLHtlZjsl6wKICAgICAgICAjIOygnOuqqeqzvCDrgrTsmqnsnbQg7J6Q7Jew7Iqk65+96rKMIOuwsOy5mOuQmOqzoCwg7ZWt66qp7J20IOunjuyd"
    "hCDqsr3smrAg7Iqk7YGs66Gk66GcIO2ZleyduO2VoCDsiJgg7J6I64+E66GdIO2VnOuLpC4KICAgICAgICBwcmV2aWV3X2dyb3VwID0gUXRXaWRnZXRzLlFH"
    "cm91cEJveCgi7ISg7YOd65CcIOuLqOy2le2CpCDsi5ztirgg66+466as67O06riwIikKICAgICAgICBwcmV2aWV3X2dyb3VwLnNldFN0eWxlU2hlZXQoCiAg"
    "ICAgICAgICAgICJRR3JvdXBCb3ggeyBtYXJnaW4tdG9wOiAxMnB4OyB9IgogICAgICAgICAgICAiUUdyb3VwQm94Ojp0aXRsZSB7IHN1YmNvbnRyb2wtb3Jp"
    "Z2luOiBtYXJnaW47IGxlZnQ6IDhweDsgfSIKICAgICAgICApCiAgICAgICAgZ3JvdXBfbGF5b3V0ID0gUXRXaWRnZXRzLlFWQm94TGF5b3V0KHByZXZpZXdf"
    "Z3JvdXApCiAgICAgICAgZ3JvdXBfbGF5b3V0LnNldENvbnRlbnRzTWFyZ2lucyg0LCA0LCA0LCA0KQogICAgICAgIGdyb3VwX2xheW91dC5zZXRTcGFjaW5n"
    "KDIpCgogICAgICAgIHNjcm9sbCA9IFF0V2lkZ2V0cy5RU2Nyb2xsQXJlYSgpCiAgICAgICAgc2Nyb2xsLnNldFdpZGdldFJlc2l6YWJsZShUcnVlKQogICAg"
    "ICAgIHByZXZpZXdfY29udGFpbmVyID0gUXRXaWRnZXRzLlFXaWRnZXQoKQogICAgICAgIHByZXZpZXdfbGF5b3V0ID0gUXRXaWRnZXRzLlFWQm94TGF5b3V0"
    "KHByZXZpZXdfY29udGFpbmVyKQogICAgICAgIHByZXZpZXdfbGF5b3V0LnNldEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25Ub3ApCiAgICAgICAgcHJldmll"
    "d19sYXlvdXQuc2V0Q29udGVudHNNYXJnaW5zKDQsIDQsIDQsIDQpCiAgICAgICAgcHJldmlld19sYXlvdXQuc2V0U3BhY2luZygyKQogICAgICAgIHNjcm9s"
    "bC5zZXRXaWRnZXQocHJldmlld19jb250YWluZXIpCiAgICAgICAgZ3JvdXBfbGF5b3V0LmFkZFdpZGdldChzY3JvbGwpCgogICAgICAgIHZib3guYWRkV2lk"
    "Z2V0KHByZXZpZXdfZ3JvdXApCgogICAgICAgICMg7LSI6riwIOuvuOumrOuztOq4sDog66qo65OgIOuwqe2WpSDquLDspIAKICAgICAgICBfcmVmcmVzaF9w"
    "cmV2aWV3X2FsbCgpCgoKICAgICAgICBidG5fcm93ID0gUXRXaWRnZXRzLlFIQm94TGF5b3V0KCkKICAgICAgICBidG5fcm93LmFkZFN0cmV0Y2goMSkKICAg"
    "ICAgICBidG5fb2sgPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIk9LIikKICAgICAgICBidG5fY2FuY2VsID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCJDYW5j"
    "ZWwiKQogICAgICAgIGJ0bl9yb3cuYWRkV2lkZ2V0KGJ0bl9vaykKICAgICAgICBidG5fcm93LmFkZFdpZGdldChidG5fY2FuY2VsKQogICAgICAgIHZib3gu"
    "YWRkTGF5b3V0KGJ0bl9yb3cpCgogICAgICAgIGRlZiBfb25fb2soKToKICAgICAgICAgICAgIyDshKDtg53rkJwg7Iuc7Yq466W8IOy5tOyatO2EsCDthYzs"
    "nbTruJTsl5Ag67CY7JiBCiAgICAgICAgICAgIGZvciBkIGluIGRpcnM6CiAgICAgICAgICAgICAgICBzaGVldF9uYW1lID0gZGlyX2NvbWJvc1tkXS5jdXJy"
    "ZW50VGV4dCgpLnN0cmlwKCkKICAgICAgICAgICAgICAgIGlmIG5vdCBzaGVldF9uYW1lOgogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAg"
    "ICAgICAgICBkaXJfc3RyID0gc3RyKGQpCiAgICAgICAgICAgICAgICBmb3VuZCA9IEZhbHNlCiAgICAgICAgICAgICAgICBmb3Igcm93IGluIHJhbmdlKHNl"
    "bGYudGJsLnJvd0NvdW50KCkpOgogICAgICAgICAgICAgICAgICAgIGRfaXRlbSA9IHNlbGYudGJsLml0ZW0ocm93LCAxKQogICAgICAgICAgICAgICAgICAg"
    "IGlmIGRfaXRlbSBhbmQgZF9pdGVtLnRleHQoKS5zdHJpcCgpID09IGRpcl9zdHI6CiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfaXRlbSA9IFF0V2lk"
    "Z2V0cy5RVGFibGVXaWRnZXRJdGVtKHNoZWV0X25hbWUpCiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVfaXRlbS5zZXRUZXh0QWxpZ25tZW50KFF0Q29y"
    "ZS5RdC5BbGlnbkhDZW50ZXIgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQogICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHJvdywg"
    "MCwgbmFtZV9pdGVtKQogICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IFRydWUKICAgICAgICAgICAgICAgICMg7ZW064u5IOuwqe2WpeuyiO2YuOyX"
    "kCDrjIDtlZwg7Lm07Jq07YSwIO2WieydtCDsl4bsnLzrqbQg7IOI66GcIOy2lOqwgAogICAgICAgICAgICAgICAgaWYgbm90IGZvdW5kOgogICAgICAgICAg"
    "ICAgICAgICAgIHIgPSBzZWxmLnRibC5yb3dDb3VudCgpCiAgICAgICAgICAgICAgICAgICAgc2VsZi50YmwuaW5zZXJ0Um93KHIpCiAgICAgICAgICAgICAg"
    "ICAgICAgbmFtZV9pdGVtID0gUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oc2hlZXRfbmFtZSkKICAgICAgICAgICAgICAgICAgICBuYW1lX2l0ZW0uc2V0"
    "VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgICAgICAgICBzZWxmLnRi"
    "bC5zZXRJdGVtKHIsIDAsIG5hbWVfaXRlbSkKICAgICAgICAgICAgICAgICAgICBkaXJfaXRlbSA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKGRpcl9z"
    "dHIpCiAgICAgICAgICAgICAgICAgICAgZGlyX2l0ZW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWdu"
    "VkNlbnRlcikKICAgICAgICAgICAgICAgICAgICBkaXJfaXRlbS5zZXRGbGFncyhkaXJfaXRlbS5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNFZGl0YWJs"
    "ZSkKICAgICAgICAgICAgICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsIDEsIGRpcl9pdGVtKQogICAgICAgICAgICAgICAgICAgIHNlbGYudGJsLnNldEl0"
    "ZW0ociwgMiwgUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oIiIpKQogICAgICAgICAgICBzZWxmLnBlcnNpc3RfY3VycmVudCgpCiAgICAgICAgICAgIFF0"
    "V2lkZ2V0cy5RTWVzc2FnZUJveC5pbmZvcm1hdGlvbihzZWxmLCAi7JmE66OMIiwgIuyeheugpeq3uOujuSDri6jstpXtgqQg7ISk7KCV7J20IOyZhOujjOuQ"
    "mOyXiOyKteuLiOuLpC4iKQogICAgICAgICAgICBkbGcuYWNjZXB0KCkKCiAgICAgICAgYnRuX29rLmNsaWNrZWQuY29ubmVjdChfb25fb2spCiAgICAgICAg"
    "YnRuX2NhbmNlbC5jbGlja2VkLmNvbm5lY3QoZGxnLnJlamVjdCkKCiAgICAgICAgZGxnLmV4ZWNfKCkKCiAgICBkZWYgYWRkX2NvdW50ZXIoc2VsZik6CiAg"
    "ICAgICAgciA9IHNlbGYudGJsLnJvd0NvdW50KCkKICAgICAgICBzZWxmLnRibC5pbnNlcnRSb3cocikKICAgICAgICAjIDDsl7Q6IOy5tOyatO2EsCDsnbTr"
    "poQo7Iio6rmAIOyymOumrOuQmOyngOunjCDrgrTrtoDsoIHsnLzroZwg7Jyg7KeALCDtjrjsp5Eg67aI6rCAKQogICAgICAgIG5hbWVfaXRlbSA9IFF0V2lk"
    "Z2V0cy5RVGFibGVXaWRnZXRJdGVtKGYi7Lm07Jq07YSwe3IrMX0iKQogICAgICAgIG5hbWVfaXRlbS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGln"
    "bkhDZW50ZXIgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQogICAgICAgIG5hbWVfaXRlbS5zZXRGbGFncyhuYW1lX2l0ZW0uZmxhZ3MoKSAmIH5RdENvcmUu"
    "UXQuSXRlbUlzRWRpdGFibGUpCiAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShyLCAwLCBuYW1lX2l0ZW0pCiAgICAgICAgIyAx7Je0OiDrsojtmLgo6rCA7Jq0"
    "642wIOygleugrCwg7Y647KeRIOu2iOqwgCkKICAgICAgICBkaXJfaXRlbSA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKCIxIikKICAgICAgICBkaXJf"
    "aXRlbS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXIgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQogICAgICAgICMg67Cp7ZalKOuy"
    "iO2YuCkg7Je07J2AIOydveq4sCDsoITsmqkKICAgICAgICBkaXJfaXRlbS5zZXRGbGFncyhkaXJfaXRlbS5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNF"
    "ZGl0YWJsZSkKICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsIDEsIGRpcl9pdGVtKQogICAgICAgICMgMuyXtDog7ZGc7Iuc66qFKOyCrOyaqeyekCDsiJjs"
    "oJUg6rCA64qlKQogICAgICAgIGxhYmVsX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbSgiIikKICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIs"
    "IDIsIGxhYmVsX2l0ZW0pCiAgICAgICAgc2VsZi5wZXJzaXN0X2N1cnJlbnQoKQoKCiAgICBkZWYgZGVsX2NvdW50ZXIoc2VsZik6CiAgICAgICAgcj1zZWxm"
    "LnRibC5jdXJyZW50Um93KCkKICAgICAgICBpZiByPj0wOiAKICAgICAgICAgICAgc2VsZi50YmwucmVtb3ZlUm93KHIpCiAgICAgICAgICAgIHNlbGYucGVy"
    "c2lzdF9jdXJyZW50KCkKCiAgICBkZWYgYWRkX3RwbChzZWxmKToKICAgICAgICBuYW1lLCBvayA9IFF0V2lkZ2V0cy5RSW5wdXREaWFsb2cuZ2V0VGV4dChz"
    "ZWxmLCLthZztlIzrpr8g7LaU6rCAIiwi7J2066aEOiIpCiAgICAgICAgaWYgbm90IG9rIG9yIG5vdCBuYW1lLnN0cmlwKCk6IHJldHVybgogICAgICAgIHA9"
    "c2VsZi5jdXJyZW50X3Byb2plY3QoKTsgCiAgICAgICAgcC5zZXRkZWZhdWx0KCJ0ZW1wbGF0ZXMiLFtdKS5hcHBlbmQoeyJuYW1lIjpuYW1lLnN0cmlwKCks"
    "ImRpcnMiOltdLCJjb3VudGVycyI6W119KQogICAgICAgIHNhdmVfZGF0YShzZWxmLndvcmsuZGF0YSk7IHNlbGYubG9hZCgpCgogICAgZGVmIHJlbl90cGwo"
    "c2VsZiwgKl8pOgogICAgICAgIGk9c2VsZi5sc3QuY3VycmVudFJvdygpOyAKICAgICAgICBpZiBpPDA6IHJldHVybgogICAgICAgIGl0PXNlbGYubHN0Lml0"
    "ZW0oaSk7IG5hbWUsIG9rID0gUXRXaWRnZXRzLlFJbnB1dERpYWxvZy5nZXRUZXh0KHNlbGYsIuydtOumhCDrs4Dqsr0iLCLsnbTrpoQ6Iix0ZXh0PWl0LnRl"
    "eHQoKSkKICAgICAgICBpZiBvayBhbmQgbmFtZS5zdHJpcCgpOgogICAgICAgICAgICBwPXNlbGYuY3VycmVudF9wcm9qZWN0KCk7IHBbInRlbXBsYXRlcyJd"
    "W2ldWyJuYW1lIl09bmFtZS5zdHJpcCgpOyBzYXZlX2RhdGEoc2VsZi53b3JrLmRhdGEpOyBzZWxmLmxvYWQoKTsgc2VsZi5sc3Quc2V0Q3VycmVudFJvdyhp"
    "KQoKICAgIGRlZiBkZWxfdHBsKHNlbGYpOgogICAgICAgIGk9c2VsZi5sc3QuY3VycmVudFJvdygpOyAKICAgICAgICBpZiBpPDA6IHJldHVybgogICAgICAg"
    "IGlmIFF0V2lkZ2V0cy5RTWVzc2FnZUJveC5xdWVzdGlvbihzZWxmLCLsgq3soJwg7ZmV7J24Iiwi7IKt7KCc7ZWg6rmM7JqUPyIpPT1RdFdpZGdldHMuUU1l"
    "c3NhZ2VCb3guWWVzOgogICAgICAgICAgICBwPXNlbGYuY3VycmVudF9wcm9qZWN0KCk7IHBbInRlbXBsYXRlcyJdLnBvcChpKTsgc2F2ZV9kYXRhKHNlbGYu"
    "d29yay5kYXRhKTsgc2VsZi5sb2FkKHByZWZlcnJlZF9pbmRleD1pLTEpCgoKICAgIGRlZiBwZXJzaXN0X2N1cnJlbnQoc2VsZik6CiAgICAgICAgIiIi7ZiE"
    "7J6sIOyEoO2DneuQnCDthZztlIzrpr/snZgg7J6F66Cl6re466O5KO2DrSnqs7wg7Lm07Jq07YSwIOq1rOyEseydhCDrjbDsnbTthLDsl5Ag7KCA7J6lLiIi"
    "IgogICAgICAgIHAgPSBzZWxmLmN1cnJlbnRfcHJvamVjdCgpCiAgICAgICAgaSA9IHNlbGYubHN0LmN1cnJlbnRSb3coKQogICAgICAgIGlmIG5vdCBwIG9y"
    "IGkgPCAwOgogICAgICAgICAgICByZXR1cm4KICAgICAgICB0ZW1wbGF0ZXMgPSBwLnNldGRlZmF1bHQoInRlbXBsYXRlcyIsIFtdKQogICAgICAgIGlmIG5v"
    "dCAoMCA8PSBpIDwgbGVuKHRlbXBsYXRlcykpOgogICAgICAgICAgICByZXR1cm4KICAgICAgICB0ID0gdGVtcGxhdGVzW2ldCiAgICAgICAgIyDsnoXroKXq"
    "t7jro7ko7YOtKQogICAgICAgIGRpcnMgPSBbXQogICAgICAgIGZvciBpZHggaW4gcmFuZ2Uoc2VsZi50YWJzLmNvdW50KCkpOgogICAgICAgICAgICB0ZXh0"
    "ID0gc2VsZi50YWJzLml0ZW0oaWR4KS50ZXh0KCkKICAgICAgICAgICAgaWYgdGV4dDoKICAgICAgICAgICAgICAgIGRpcnMuYXBwZW5kKHN0cih0ZXh0KSkK"
    "ICAgICAgICAjIOy5tOyatO2EsCDthYzsnbTruJQKICAgICAgICBjb3VudGVycyA9IFtdCiAgICAgICAgZm9yIHIgaW4gcmFuZ2Uoc2VsZi50Ymwucm93Q291"
    "bnQoKSk6CiAgICAgICAgICAgIG5hbWVfaXRlbSA9IHNlbGYudGJsLml0ZW0ociwgMCkKICAgICAgICAgICAgZGlyX2l0ZW0gID0gc2VsZi50YmwuaXRlbShy"
    "LCAxKQogICAgICAgICAgICBsYWJlbF9pdGVtPSBzZWxmLnRibC5pdGVtKHIsIDIpCiAgICAgICAgICAgIG5hbWUgID0gbmFtZV9pdGVtLnRleHQoKS5zdHJp"
    "cCgpIGlmIG5hbWVfaXRlbSBlbHNlICIiCiAgICAgICAgICAgIGR0ZXh0ID0gZGlyX2l0ZW0udGV4dCgpLnN0cmlwKCkgaWYgZGlyX2l0ZW0gZWxzZSAiIgog"
    "ICAgICAgICAgICBsYWJlbCA9IGxhYmVsX2l0ZW0udGV4dCgpLnN0cmlwKCkgaWYgbGFiZWxfaXRlbSBlbHNlICIiCiAgICAgICAgICAgIGlmIG5vdCAobmFt"
    "ZSBvciBkdGV4dCBvciBsYWJlbCk6CiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBkdmFsID0gaW50"
    "KGR0ZXh0KSBpZiBkdGV4dCBlbHNlIE5vbmUKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgIGR2YWwgPSBOb25lCiAgICAg"
    "ICAgICAgIGVudHJ5ID0geyJuYW1lIjogbmFtZSwgImRpciI6IGR2YWwsICJsYWJlbCI6IGxhYmVsfQogICAgICAgICAgICBjb3VudGVycy5hcHBlbmQoZW50"
    "cnkpCiAgICAgICAgdFsiZGlycyJdID0gZGlycwogICAgICAgIHRbImNvdW50ZXJzIl0gPSBjb3VudGVycwogICAgICAgIHNhdmVfZGF0YShzZWxmLndvcmsu"
    "ZGF0YSkKCiAgICBkZWYgZGVsX2NvdW50ZXJfcm93KHNlbGYpOgogICAgICAgICIiIuy5tOyatO2EsCDsi5ztirjsl5DshJwg7ISg7YOd65CcIO2WiSjrk6Qp"
    "7J2EIOyCreygnO2VnOuLpC4iIiIKICAgICAgICByb3dzID0gc29ydGVkKHtpLnJvdygpIGZvciBpIGluIHNlbGYudGJsLnNlbGVjdGVkSW5kZXhlcygpfSwg"
    "cmV2ZXJzZT1UcnVlKQogICAgICAgIGlmIG5vdCByb3dzOgogICAgICAgICAgICByZXR1cm4KICAgICAgICBmb3IgciBpbiByb3dzOgogICAgICAgICAgICBp"
    "ZiAwIDw9IHIgPCBzZWxmLnRibC5yb3dDb3VudCgpOgogICAgICAgICAgICAgICAgc2VsZi50YmwucmVtb3ZlUm93KHIpCiAgICAgICAgc2VsZi5wZXJzaXN0"
    "X2N1cnJlbnQoKQogICAgZGVmIGxvYWRfdHBsKHNlbGYsKl8pOgogICAgICAgIHA9c2VsZi5jdXJyZW50X3Byb2plY3QoKTsgaT1zZWxmLmxzdC5jdXJyZW50"
    "Um93KCk7IHNlbGYuY2xlYXJfcmlnaHQoKQogICAgICAgIGlmIG5vdCBwIG9yIGk8MDogCiAgICAgICAgICAgIHJldHVybgogICAgICAgIHQ9cC5nZXQoInRl"
    "bXBsYXRlcyIsW10pW2ldCiAgICAgICAgZm9yIGcgaW4gdC5nZXQoImRpcnMiLFtdKToKICAgICAgICAgICAgc2VsZi50YWJzLmFkZEl0ZW0oc3RyKGcpKQog"
    "ICAgICAgIGZvciBjIGluIHQuZ2V0KCJjb3VudGVycyIsIFtdKToKICAgICAgICAgICAgciA9IHNlbGYudGJsLnJvd0NvdW50KCkKICAgICAgICAgICAgc2Vs"
    "Zi50YmwuaW5zZXJ0Um93KHIpCiAgICAgICAgICAgICMgMOyXtDog7Lm07Jq07YSwIOydtOumhCjsiKjquYAg7Lus65+8LCDtjrjsp5Eg67aI6rCAKQogICAg"
    "ICAgICAgICBuYW1lX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShjLmdldCgibmFtZSIsICIiKSkKICAgICAgICAgICAgbmFtZV9pdGVtLnNl"
    "dFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlciB8IFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAgICAgIG5hbWVfaXRlbS5zZXRG"
    "bGFncyhuYW1lX2l0ZW0uZmxhZ3MoKSAmIH5RdENvcmUuUXQuSXRlbUlzRWRpdGFibGUpCiAgICAgICAgICAgIHNlbGYudGJsLnNldEl0ZW0ociwgMCwgbmFt"
    "ZV9pdGVtKQogICAgICAgICAgICAjIDHsl7Q6IOuyiO2YuCjqsIDsmrTrjbAg7KCV66CsLCDtjrjsp5Eg67aI6rCAKQogICAgICAgICAgICBkaXJfdGV4dCA9"
    "IHN0cihjLmdldCgiZGlyIiwgIiIpIGlmIGMuZ2V0KCJkaXIiLCAiIikgaXMgbm90IE5vbmUgZWxzZSAiIikKICAgICAgICAgICAgZGlyX2l0ZW0gPSBRdFdp"
    "ZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShkaXJfdGV4dCkKICAgICAgICAgICAgZGlyX2l0ZW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2Vu"
    "dGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgZGlyX2l0ZW0uc2V0RmxhZ3MoZGlyX2l0ZW0uZmxhZ3MoKSAmIH5RdENvcmUuUXQu"
    "SXRlbUlzRWRpdGFibGUpCiAgICAgICAgICAgIHNlbGYudGJsLnNldEl0ZW0ociwgMSwgZGlyX2l0ZW0pCiAgICAgICAgICAgICMgMuyXtDog7ZGc7Iuc66qF"
    "ICjsgqzsmqnsnpAg7IiY7KCVIOqwgOuKpSkKICAgICAgICAgICAgbGFiZWxfaXRlbSA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKGMuZ2V0KCJsYWJl"
    "bCIsICIiKSkKICAgICAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShyLCAyLCBsYWJlbF9pdGVtKQogICAgICAgICMg7YWc7ZSM66a/7J2EIOu2iOufrOyYqCDt"
    "m4QsIOuCqOydgCDrsKntlqXrsojtmLgg66as7Iqk7Yq466W8IOuLpOyLnCDqs4TsgrAKICAgICAgICBzZWxmLl9yZWJ1aWxkX2Rpcl9saXN0KCkKCiMgLS0t"
    "LS0tLS0tLS0tLS0tLSDssKjsooXqtIDrpqwg7Y6Y7J207KeAIC0tLS0tLS0tLS0tLS0tLS0KY2xhc3MgV29ya01hbmFnZXJQYWdlKFF0V2lkZ2V0cy5RV2lk"
    "Z2V0KToKICAgIGNoYW5nZWQgPSBRdENvcmUucHlxdFNpZ25hbCgpCiAgICBkZWYgX19pbml0X18oc2VsZiwgZGF0YSwgcGFyZW50PU5vbmUpOgogICAgICAg"
    "IHN1cGVyKCkuX19pbml0X18ocGFyZW50KTsgc2VsZi5kYXRhID0gZGF0YQogICAgICAgIGggPSBRdFdpZGdldHMuUUhCb3hMYXlvdXQoc2VsZikKICAgICAg"
    "ICBsZWZ0ID0gUXRXaWRnZXRzLlFWQm94TGF5b3V0KCkKICAgICAgICBzZWxmLmxzdCA9IFF0V2lkZ2V0cy5RTGlzdFdpZGdldCgpCiAgICAgICAgbGVmdC5h"
    "ZGRXaWRnZXQoUXRXaWRnZXRzLlFMYWJlbCgi7LCo7KKFIOycoO2YlSIpKQogICAgICAgIHNlbGYubHN0LnNldEZpeGVkV2lkdGgoMjUwKQogICAgICAgIHNl"
    "bGYubHN0LnNldE1pbmltdW1XaWR0aCgyMjApCiAgICAgICAgc2VsZi5sc3Quc2V0TWF4aW11bVdpZHRoKDIyMCkKICAgICAgICBsZWZ0LmFkZFdpZGdldChz"
    "ZWxmLmxzdCwgMSkKICAgICAgICB0cnk6IHNlbGYubHN0LnNldE1heGltdW1XaWR0aCgyMDApCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjogcGFzcwogICAg"
    "ICAgIGhiID0gUXRXaWRnZXRzLlFIQm94TGF5b3V0KCk7IAogICAgICAgIHNlbGYuYl9hZGQgPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIuy2lOqwgCIpOyBz"
    "ZWxmLmJfZGVsPVF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi7IKt7KCcIikKICAgICAgICBmb3IgYiBpbiAoc2VsZi5iX2FkZCxzZWxmLmJfZGVsKTogaGIuYWRk"
    "V2lkZ2V0KGIpCiAgICAgICAgbGVmdC5hZGRMYXlvdXQoaGIpOyBoLmFkZExheW91dChsZWZ0LDEpCgogICAgICAgIHNlbGYudGFicyA9IFF0V2lkZ2V0cy5R"
    "VGFiV2lkZ2V0KCkKICAgICAgICBzZWxmLnRhYl92ZWhpY2xlID0gV29ya1ZlaGljbGVUYWIoc2VsZikKICAgICAgICBzZWxmLnRhYl9ob3RrZXkgID0gV29y"
    "a0hvdGtleVRhYihzZWxmKQogICAgICAgIHNlbGYudGFiX3RwbCAgICAgPSBXb3JrVGVtcGxhdGVUYWIoc2VsZikKICAgICAgICBzZWxmLnRhYnMuYWRkVGFi"
    "KHNlbGYudGFiX3ZlaGljbGUsIuywqOyihSDshKTsoJUiKQogICAgICAgIHNlbGYudGFicy5hZGRUYWIoc2VsZi50YWJfaG90a2V5LCLsubTsmrTthLAg64uo"
    "7LaV7YKkIOyEpOyglSIpCiAgICAgICAgc2VsZi50YWJzLmFkZFRhYihzZWxmLnRhYl90cGwsIuy5tOyatO2EsCDthZztlIzrpr8g6rSA66asIikKICAgICAg"
    "ICBoLmFkZFdpZGdldChzZWxmLnRhYnMsMykKCiAgICAgICAgc2VsZi5iX2FkZC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5hZGRfcHJvamVjdCkKICAgICAgICBz"
    "ZWxmLmJfZGVsLmNsaWNrZWQuY29ubmVjdChzZWxmLmRlbF9wcm9qZWN0KQogICAgICAgIHNlbGYubHN0LmN1cnJlbnRSb3dDaGFuZ2VkLmNvbm5lY3Qoc2Vs"
    "Zi5fbG9hZF9yaWdodCkKICAgICAgICBzZWxmLmxzdC5pdGVtRG91YmxlQ2xpY2tlZC5jb25uZWN0KHNlbGYucmVuX3Byb2plY3QpCiAgICAgICAgc2VsZi5y"
    "ZWxvYWQoKQoKICAgIGRlZiBwcm9qZWN0cyhzZWxmKTogcmV0dXJuIHNlbGYuZGF0YVsicHJvamVjdHMiXQogICAgZGVmIGN1cnJlbnRfcHJvamVjdChzZWxm"
    "KToKICAgICAgICBpPXNlbGYubHN0LmN1cnJlbnRSb3coKTsgCiAgICAgICAgcmV0dXJuIHNlbGYucHJvamVjdHMoKVtpXSBpZiAwPD1pPGxlbihzZWxmLnBy"
    "b2plY3RzKCkpIGVsc2UgTm9uZQoKICAgIGRlZiByZWxvYWQoc2VsZiwgcHJlZmVycmVkX2luZGV4PU5vbmUpOgogICAgICAgIHNlbGYubHN0LmNsZWFyKCk7"
    "IAogICAgICAgIGZvciBwIGluIHNlbGYucHJvamVjdHMoKTogc2VsZi5sc3QuYWRkSXRlbShwWyJuYW1lIl0pCiAgICAgICAgaWYgc2VsZi5sc3QuY291bnQo"
    "KToKICAgICAgICAgICAgaWYgcHJlZmVycmVkX2luZGV4IGlzIE5vbmU6CiAgICAgICAgICAgICAgICBwcmVmZXJyZWRfaW5kZXggPSAwCiAgICAgICAgICAg"
    "IHByZWZlcnJlZF9pbmRleCA9IG1heCgwLCBtaW4ocHJlZmVycmVkX2luZGV4LCBzZWxmLmxzdC5jb3VudCgpLTEpKQogICAgICAgICAgICBzZWxmLmxzdC5z"
    "ZXRDdXJyZW50Um93KHByZWZlcnJlZF9pbmRleCkKCiAgICBkZWYgX2xvYWRfcmlnaHQoc2VsZiwqXyk6CiAgICAgICAgc2VsZi50YWJfdmVoaWNsZS5sb2Fk"
    "KCk7IHNlbGYudGFiX2hvdGtleS5sb2FkX2RpcigpOyBzZWxmLnRhYl90cGwubG9hZCgpCiAgICAgICAgc2VsZi5jaGFuZ2VkLmVtaXQoKQoKICAgIGRlZiBh"
    "ZGRfcHJvamVjdChzZWxmKToKICAgICAgICBuYW1lLCBvayA9IFF0V2lkZ2V0cy5RSW5wdXREaWFsb2cuZ2V0VGV4dChzZWxmLCLsg4gg7J6R7JeFIiwi7J20"
    "66aEOiIpCiAgICAgICAgaWYgb2sgYW5kIG5hbWUuc3RyaXAoKToKICAgICAgICAgICAgIyDsg4gg7ZWt66qp7J2EIO2YhOyerCDsiJzshJwg66eoIOyVhOue"
    "mOyXkCDstpTqsIDtlZjqs6AsIOy2lOqwgOuQnCDsnITsuZjrpbwg6re464yA66GcIOyEoO2DnQogICAgICAgICAgICBzZWxmLnByb2plY3RzKCkuYXBwZW5k"
    "KHsKICAgICAgICAgICAgICAgICJuYW1lIjogbmFtZS5zdHJpcCgpLAogICAgICAgICAgICAgICAgInZlaGljbGVfc2V0IjogW10sCiAgICAgICAgICAgICAg"
    "ICAiaG90a2V5cyI6IHsi7KKMIjoge30sICLsp4EiOiB7fSwgIuyasCI6IHt9fSwKICAgICAgICAgICAgICAgICJ0ZW1wbGF0ZXMiOiBbXQogICAgICAgICAg"
    "ICB9KQogICAgICAgICAgICBzYXZlX2RhdGEoc2VsZi5kYXRhKQogICAgICAgICAgICBwcmVmZXJyZWQgPSBsZW4oc2VsZi5wcm9qZWN0cygpKSAtIDEgICMg"
    "67Cp6riIIOy2lOqwgOuQnCDsnbjrjbHsiqQKICAgICAgICAgICAgc2VsZi5yZWxvYWQocHJlZmVycmVkX2luZGV4PXByZWZlcnJlZCkKCiAgICBkZWYgcmVu"
    "X3Byb2plY3Qoc2VsZik6CiAgICAgICAgaXQgPSBzZWxmLmxzdC5jdXJyZW50SXRlbSgpCiAgICAgICAgaWYgbm90IGl0OgogICAgICAgICAgICByZXR1cm4K"
    "ICAgICAgICBjdXJfaW5kZXggPSBzZWxmLmxzdC5jdXJyZW50Um93KCkKICAgICAgICBuYW1lLCBvayA9IFF0V2lkZ2V0cy5RSW5wdXREaWFsb2cuZ2V0VGV4"
    "dChzZWxmLCLsiJjsoJUiLCLsnbTrpoQ6Iix0ZXh0PWl0LnRleHQoKSkKICAgICAgICBpZiBvayBhbmQgbmFtZS5zdHJpcCgpOgogICAgICAgICAgICBzZWxm"
    "LnByb2plY3RzKClbY3VyX2luZGV4XVsibmFtZSJdID0gbmFtZS5zdHJpcCgpCiAgICAgICAgICAgIHNhdmVfZGF0YShzZWxmLmRhdGEpCiAgICAgICAgICAg"
    "ICMg7J2066aE66eMIOuwlOuAjOqzoCDsnITsuZjripQg6re464yA66GcIOycoOyngO2VmOuPhOuhnSDtmITsnqwg7J24642x7Iqk66W8IOuLpOyLnCDshKDt"
    "g50KICAgICAgICAgICAgc2VsZi5yZWxvYWQocHJlZmVycmVkX2luZGV4PWN1cl9pbmRleCkKCiAgICBkZWYgZGVsX3Byb2plY3Qoc2VsZik6CiAgICAgICAg"
    "aT1zZWxmLmxzdC5jdXJyZW50Um93KCk7IAogICAgICAgIGlmIGk8MDogcmV0dXJuCiAgICAgICAgaWYgUXRXaWRnZXRzLlFNZXNzYWdlQm94LnF1ZXN0aW9u"
    "KHNlbGYsIuyCreygnCDtmZXsnbgiLCLsgq3soJztlaDquYzsmpQ/Iik9PVF0V2lkZ2V0cy5RTWVzc2FnZUJveC5ZZXM6CiAgICAgICAgICAgIHNlbGYucHJv"
    "amVjdHMoKS5wb3AoaSk7IHNhdmVfZGF0YShzZWxmLmRhdGEpOyAKICAgICAgICAgICAgIyBrZWVwIHNlbGVjdGlvbiBhdCB0aGUgcG9zaXRpb24gb2YgdGhl"
    "IGRlbGV0ZWQgaXRlbSAob3IgbGFzdCBpdGVtIGlmIGRlbGV0ZWQgbGFzdCkKICAgICAgICAgICAgcHJlZmVycmVkID0gbWF4KDAsIG1pbihpLCBsZW4oc2Vs"
    "Zi5wcm9qZWN0cygpKS0xKSkKICAgICAgICAgICAgc2VsZi5yZWxvYWQocHJlZmVycmVkX2luZGV4PXByZWZlcnJlZCkKCiMgLS0tLS0tLS0tLS0tLS0tLSDs"
    "obDsgqzqtIDrpqwg7YOt65OkIC0tLS0tLS0tLS0tLS0tLS0KZGVmIG5leHRfc24oKToKICAgICIiIgogICAg7KGw7IKs67KI7Zi4OiBTTl9ZWVlZTU1ERGho"
    "bW1zc2ZmCiAgICDsmIgpIDIwMjXrhYQgMTLsm5QgNeydvCAxNOyLnCAyNeu2hCAyM+y0iCAxNeuwgOumrOy0iCAtPiBTTl8yMDI1MTIwNTE0MjUyMzE1CiAg"
    "ICAiIiIKICAgIG5vdyA9IGR0LmRhdGV0aW1lLm5vdygpCiAgICBtczIgPSBpbnQobm93Lm1pY3Jvc2Vjb25kIC8gMTAwMDApICAjIDB+OTkgKOyVvSAxMG1z"
    "IOuLqOychCkKICAgIHJldHVybiAiU05fIiArIG5vdy5zdHJmdGltZSgiJVklbSVkJUglTSVTIikgKyBmInttczI6MDJkfSIKCgpjbGFzcyBTdXJ2ZXlJbmZv"
    "VGFiKFF0V2lkZ2V0cy5RV2lkZ2V0KToKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBwYWdlKToKICAgICAgICBzdXBlcigpLl9faW5pdF9fKHBhZ2UpCiAgICAg"
    "ICAgZiA9IFF0V2lkZ2V0cy5RRm9ybUxheW91dChzZWxmKQogICAgICAgIHNlbGYuY2JfcHVycG9zZSA9IFF0V2lkZ2V0cy5RQ29tYm9Cb3goKTsgc2VsZi5j"
    "Yl9wdXJwb3NlLmFkZEl0ZW1zKFsi7J2867CYIOyhsOyCrOyaqSjrqqjrk6DsnpHsl4XsnpAg64W47LacKSIsIuq0gOumrOyekOyaqSjqtIDrpqzsnpDrp4wg"
    "64W47LacKSJdKQogICAgICAgIHNlbGYuY2Jfc3RhdGUgPSBRdFdpZGdldHMuUUNvbWJvQm94KCk7IHNlbGYuY2Jfc3RhdGUuYWRkSXRlbXMoWyLrjIDquLAi"
    "LCLsp4TtlokiLCLsmYTro4wiXSkKICAgICAgICBzZWxmLmVkX25hbWUgPSBRdFdpZGdldHMuUUxpbmVFZGl0KCkKICAgICAgICBzZWxmLmVkX3NuICAgPSBR"
    "dFdpZGdldHMuUUxpbmVFZGl0KCkKICAgICAgICAjIOyhsOyCrOuyiO2YuOuKlCDsnpDrj5kg7IOd7ISx65CY66+A66GcIOyCrOyaqeyekCDtjrjsp5Eg67aI"
    "6rCACiAgICAgICAgc2VsZi5lZF9zbi5zZXRSZWFkT25seShUcnVlKQogICAgICAgIHNlbGYuZWRfcmVnICA9IFF0V2lkZ2V0cy5RRGF0ZUVkaXQoUXRDb3Jl"
    "LlFEYXRlLmN1cnJlbnREYXRlKCkpOyBzZWxmLmVkX3JlZy5zZXRDYWxlbmRhclBvcHVwKFRydWUpCiAgICAgICAgc2VsZi5lZF9jbGllbnQgPSBRdFdpZGdl"
    "dHMuUUxpbmVFZGl0KCkKICAgICAgICBzZWxmLmVkX3AxICA9IFF0V2lkZ2V0cy5RRGF0ZUVkaXQoUXRDb3JlLlFEYXRlLmN1cnJlbnREYXRlKCkpOyBzZWxm"
    "LmVkX3AxLnNldENhbGVuZGFyUG9wdXAoVHJ1ZSkKICAgICAgICBzZWxmLmVkX3AyICA9IFF0V2lkZ2V0cy5RRGF0ZUVkaXQoUXRDb3JlLlFEYXRlLmN1cnJl"
    "bnREYXRlKCkpOyBzZWxmLmVkX3AyLnNldENhbGVuZGFyUG9wdXAoVHJ1ZSkKICAgICAgICAjIOyhsOyCrOq4sOqwhCDrgqDsp5wg7L2k67O067CV7IqkKOyL"
    "nOyekS/sooXro4wpIOqwgOuhnCDtgazquLAgMuuwsOuhnCDtmZXrjIAKICAgICAgICB0cnk6CiAgICAgICAgICAgIHcgPSBzZWxmLmVkX3AxLnNpemVIaW50"
    "KCkud2lkdGgoKQogICAgICAgICAgICBzZWxmLmVkX3AxLnNldEZpeGVkV2lkdGgoaW50KHcgKiAyKSkKICAgICAgICAgICAgc2VsZi5lZF9wMi5zZXRGaXhl"
    "ZFdpZHRoKGludCh3ICogMikpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgICAgIHNlbGYuZWRfZGVzYz0gUXRXaWRn"
    "ZXRzLlFQbGFpblRleHRFZGl0KCkKICAgICAgICBmLmFkZFJvdygi7Jqp64+EIiwgc2VsZi5jYl9wdXJwb3NlKQogICAgICAgIGYuYWRkUm93KCLsp4Ttlons"
    "g4Htg5wiLCBzZWxmLmNiX3N0YXRlKQogICAgICAgIGYuYWRkUm93KCLsobDsgqzrqoUiLCBzZWxmLmVkX25hbWUpCiAgICAgICAgZi5hZGRSb3coIuyhsOyC"
    "rOuyiO2YuCIsIHNlbGYuZWRfc24pCiAgICAgICAgZi5hZGRSb3coIuuTseuhneydvCIsIHNlbGYuZWRfcmVnKQogICAgICAgIGYuYWRkUm93KCLrsJzso7zs"
    "spgiLCBzZWxmLmVkX2NsaWVudCkKICAgICAgICBoPVF0V2lkZ2V0cy5RSEJveExheW91dCgpOyBoLmFkZFdpZGdldChzZWxmLmVkX3AxKTsgaC5hZGRXaWRn"
    "ZXQoUXRXaWRnZXRzLlFMYWJlbCgiIH4gIikpOyBoLmFkZFdpZGdldChzZWxmLmVkX3AyKTsgaC5hZGRTdHJldGNoKDEpOyBmLmFkZFJvdygi7KGw7IKs6riw"
    "6rCEIiwgaCkKICAgICAgICBmLmFkZFJvdygi7ISk66qFIiwgc2VsZi5lZF9kZXNjKQoKICAgICAgICAjIOynhO2WieyDge2DnCDsg4nsg4Eg7LSI6riwIOyE"
    "pOyglQogICAgICAgIHRyeToKICAgICAgICAgICAgc2VsZi5jYl9zdGF0ZS5jdXJyZW50VGV4dENoYW5nZWQuY29ubmVjdChzZWxmLnVwZGF0ZV9zdGF0ZV9j"
    "b2xvcikKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICBwYXNzCiAgICAgICAgc2VsZi51cGRhdGVfc3RhdGVfY29sb3Ioc2VsZi5jYl9z"
    "dGF0ZS5jdXJyZW50VGV4dCgpKQoKICAgIGRlZiBnZXQoc2VsZik6CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgInB1cnBvc2UiOiBzZWxmLmNiX3B1"
    "cnBvc2UuY3VycmVudFRleHQoKSwKICAgICAgICAgICAgInN0YXRlIjogc2VsZi5jYl9zdGF0ZS5jdXJyZW50VGV4dCgpLAogICAgICAgICAgICAibmFtZSI6"
    "IHNlbGYuZWRfbmFtZS50ZXh0KCkuc3RyaXAoKSwKICAgICAgICAgICAgInNuIjogc2VsZi5lZF9zbi50ZXh0KCkuc3RyaXAoKSBvciBuZXh0X3NuKCksCiAg"
    "ICAgICAgICAgICJyZWdfZGF0ZSI6IHNlbGYuZWRfcmVnLmRhdGUoKS50b1N0cmluZygieXl5eS1NTS1kZCIpLAogICAgICAgICAgICAiY2xpZW50Ijogc2Vs"
    "Zi5lZF9jbGllbnQudGV4dCgpLnN0cmlwKCksCiAgICAgICAgICAgICJwZXJpb2QiOiBbc2VsZi5lZF9wMS5kYXRlKCkudG9TdHJpbmcoInl5eXktTU0tZGQi"
    "KSwgc2VsZi5lZF9wMi5kYXRlKCkudG9TdHJpbmcoInl5eXktTU0tZGQiKV0sCiAgICAgICAgICAgICJkZXNjIjogc2VsZi5lZF9kZXNjLnRvUGxhaW5UZXh0"
    "KCkKICAgICAgICB9CgogICAgZGVmIHNldChzZWxmLCBkKToKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShkLCBkaWN0KTogZD17fQogICAgICAgIHNlbGYu"
    "Y2JfcHVycG9zZS5zZXRDdXJyZW50VGV4dChkLmdldCgicHVycG9zZSIsIuydvOuwmCDsobDsgqzsmqko66qo65Og7J6R7JeF7J6QIOuFuOy2nCkiKSkKICAg"
    "ICAgICBzZWxmLmNiX3N0YXRlLnNldEN1cnJlbnRUZXh0KGQuZ2V0KCJzdGF0ZSIsIuuMgOq4sCIpKQogICAgICAgIHNlbGYudXBkYXRlX3N0YXRlX2NvbG9y"
    "KHNlbGYuY2Jfc3RhdGUuY3VycmVudFRleHQoKSkKICAgICAgICBzZWxmLmVkX25hbWUuc2V0VGV4dChkLmdldCgibmFtZSIsIiIpKQogICAgICAgIHNlbGYu"
    "ZWRfc24uc2V0VGV4dChkLmdldCgic24iLCIiKSkKICAgICAgICBxZD1RdENvcmUuUURhdGUuZnJvbVN0cmluZyhkLmdldCgicmVnX2RhdGUiLCIiKSwieXl5"
    "eS1NTS1kZCIpCiAgICAgICAgaWYgcWQuaXNWYWxpZCgpOiBzZWxmLmVkX3JlZy5zZXREYXRlKHFkKQogICAgICAgIHNlbGYuZWRfY2xpZW50LnNldFRleHQo"
    "ZC5nZXQoImNsaWVudCIsIiIpKQogICAgICAgIHBlcj1kLmdldCgicGVyaW9kIikKICAgICAgICBpZiBpc2luc3RhbmNlKHBlciwobGlzdCx0dXBsZSkpIGFu"
    "ZCBsZW4ocGVyKT09MjoKICAgICAgICAgICAgYT1RdENvcmUuUURhdGUuZnJvbVN0cmluZyhzdHIocGVyWzBdKSwieXl5eS1NTS1kZCIpCiAgICAgICAgICAg"
    "IGI9UXRDb3JlLlFEYXRlLmZyb21TdHJpbmcoc3RyKHBlclsxXSksInl5eXktTU0tZGQiKQogICAgICAgICAgICBpZiBhLmlzVmFsaWQoKTogc2VsZi5lZF9w"
    "MS5zZXREYXRlKGEpCiAgICAgICAgICAgIGlmIGIuaXNWYWxpZCgpOiBzZWxmLmVkX3AyLnNldERhdGUoYikKICAgICAgICBzZWxmLmVkX2Rlc2Muc2V0UGxh"
    "aW5UZXh0KGQuZ2V0KCJkZXNjIiwiIikpCgoKICAgIGRlZiB1cGRhdGVfc3RhdGVfY29sb3Ioc2VsZiwgdGV4dCk6CiAgICAgICAgIiIi7KeE7ZaJ7IOB7YOc"
    "IOy9pOuztOuwleyKpCDquIDsnpAg7IOJ7IOBIOuzgOqyvSIiIgogICAgICAgICMg64yA6riwOiDqsoDsoJUsIOynhO2WiTog7YyM656RLCDsmYTro4w6IOyX"
    "sO2ajOyDiQogICAgICAgIGNvbG9yX21hcCA9IHsi64yA6riwIjogImJsYWNrIiwgIuynhO2WiSI6ICJibHVlIiwgIuyZhOujjCI6ICJsaWdodGdyYXkifQog"
    "ICAgICAgIGNvbG9yID0gY29sb3JfbWFwLmdldCh0ZXh0LCAiYmxhY2siKQogICAgICAgICMgUUNvbWJvQm94IOyghOyytCDthY3siqTtirgg7IOJIOuzgOqy"
    "vQogICAgICAgIHNlbGYuY2Jfc3RhdGUuc2V0U3R5bGVTaGVldCgiUUNvbWJvQm94IHsgY29sb3I6ICVzOyB9IiAlIGNvbG9yKQoKY2xhc3MgU3VydmV5VGlt"
    "ZVRhYihRdFdpZGdldHMuUVdpZGdldCk6CiAgICBkZWYgX19pbml0X18oc2VsZiwgcGFnZSk6CiAgICAgICAgc3VwZXIoKS5fX2luaXRfXyhwYWdlKQogICAg"
    "ICAgIHY9UXRXaWRnZXRzLlFWQm94TGF5b3V0KHNlbGYpCiAgICAgICAgdG9wPVF0V2lkZ2V0cy5RSEJveExheW91dCgpCiAgICAgICAgc2VsZi50MT1RdFdp"
    "ZGdldHMuUVRpbWVFZGl0KFF0Q29yZS5RVGltZSg3LDApKTsgc2VsZi50MS5zZXREaXNwbGF5Rm9ybWF0KCJISDptbSIpCiAgICAgICAgc2VsZi50Mj1RdFdp"
    "ZGdldHMuUVRpbWVFZGl0KFF0Q29yZS5RVGltZSg5LDApKTsgc2VsZi50Mi5zZXREaXNwbGF5Rm9ybWF0KCJISDptbSIpCiAgICAgICAgc2VsZi5zdGVwPVF0"
    "V2lkZ2V0cy5RU3BpbkJveCgpOyBzZWxmLnN0ZXAuc2V0UmFuZ2UoMSw2MCk7IHNlbGYuc3RlcC5zZXRWYWx1ZSgxNSkKCiAgICAgICAgIyDsi5zqsIQv7KKF"
    "66OML+qwhOqyqSDsnoXroKUg7JyE7KCvIOqwgOuhnCDtgazquLAgMuuwsOuhnCDsobDsoJUKICAgICAgICB0cnk6CiAgICAgICAgICAgIHcgPSBzZWxmLnQx"
    "LnNpemVIaW50KCkud2lkdGgoKQogICAgICAgICAgICBzZWxmLnQxLnNldEZpeGVkV2lkdGgoaW50KHcqMikpCiAgICAgICAgICAgIHNlbGYudDIuc2V0Rml4"
    "ZWRXaWR0aChpbnQodyoyKSkKICAgICAgICAgICAgc3cgPSBzZWxmLnN0ZXAuc2l6ZUhpbnQoKS53aWR0aCgpCiAgICAgICAgICAgIHNlbGYuc3RlcC5zZXRG"
    "aXhlZFdpZHRoKGludChzdyoyKSkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICBwYXNzCiAgICAgICAgc2VsZi5iX2F1dG89UXRXaWRn"
    "ZXRzLlFQdXNoQnV0dG9uKCLsnpDrj5nsg53shLEiKQogICAgICAgIHNlbGYuYl9yZXNldD1RdFdpZGdldHMuUVB1c2hCdXR0b24oIuy0iOq4sO2ZlCIpCiAg"
    "ICAgICAgdG9wLmFkZFdpZGdldChRdFdpZGdldHMuUUxhYmVsKCLsi5zsnpEiKSk7IHRvcC5hZGRXaWRnZXQoc2VsZi50MSkKICAgICAgICB0b3AuYWRkV2lk"
    "Z2V0KFF0V2lkZ2V0cy5RTGFiZWwoIuyiheujjCIpKTsgdG9wLmFkZFdpZGdldChzZWxmLnQyKQogICAgICAgIHRvcC5hZGRXaWRnZXQoUXRXaWRnZXRzLlFM"
    "YWJlbCgi6rCE6rKpKOu2hCkiKSk7IHRvcC5hZGRXaWRnZXQoc2VsZi5zdGVwKQogICAgICAgIHRvcC5hZGRTdHJldGNoKDEpOyB0b3AuYWRkV2lkZ2V0KHNl"
    "bGYuYl9hdXRvKTsgdG9wLmFkZFdpZGdldChzZWxmLmJfcmVzZXQpCiAgICAgICAgdi5hZGRMYXlvdXQodG9wKQogICAgICAgIGhiPVF0V2lkZ2V0cy5RSEJv"
    "eExheW91dCgpOwogICAgICAgIHNlbGYuYl9kZWw9UXRXaWRnZXRzLlFQdXNoQnV0dG9uKCLtlokg7IKt7KCcIik7IGhiLmFkZFdpZGdldChzZWxmLmJfZGVs"
    "KTsgaGIuYWRkU3RyZXRjaCgxKQogICAgICAgIHYuYWRkTGF5b3V0KGhiKQogICAgICAgIHNlbGYudGJsPVF0V2lkZ2V0cy5RVGFibGVXaWRnZXQoIDAsNCk7"
    "IHNlbGYudGJsLnNldEhvcml6b250YWxIZWFkZXJMYWJlbHMoWyLrsojtmLgiLCLsi5zsnpEiLCLsooXro4wiXSk7IHNlbGYudGJsLnNldEhvcml6b250YWxI"
    "ZWFkZXJMYWJlbHMoWyLrsojtmLgiLCLsi5zsnpEiLCLsooXro4wiLCIiXSk7IHNlbGYudGJsLmhvcml6b250YWxIZWFkZXIoKS5zZXRTdHJldGNoTGFzdFNl"
    "Y3Rpb24oVHJ1ZSkKICAgICAgICBzZWxmLnRibC52ZXJ0aWNhbEhlYWRlcigpLnNldFZpc2libGUoRmFsc2UpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBz"
    "ZWxmLnRibC5ob3Jpem9udGFsSGVhZGVyKCkuc2V0RGVmYXVsdEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyKQogICAgICAgIGV4Y2VwdCBFeGNl"
    "cHRpb246CiAgICAgICAgICAgIHBhc3MKICAgICAgICAjIOyFgCDsp4HsoJEg7Y647KeRIOq4iOyngCAo7J6Q64+Z7IOd7ISx65CcIOyLnOqwhOuMgOunjCDs"
    "gqzsmqkpCiAgICAgICAgc2VsZi50Ymwuc2V0RWRpdFRyaWdnZXJzKFF0V2lkZ2V0cy5RQWJzdHJhY3RJdGVtVmlldy5Ob0VkaXRUcmlnZ2VycykKICAgICAg"
    "ICAjIOuyiO2YuC/si5zqsIQv7KKF66OMIOyXtCDqsIDroZzqsITqsqkg7LaV7IaMICYg6rCA7Jq0642wIOygleugrAogICAgICAgIHRyeToKICAgICAgICAg"
    "ICAgc2VsZi50YmwuaG9yaXpvbnRhbEhlYWRlcigpLnNldERlZmF1bHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlcikKICAgICAgICAgICAgc2Vs"
    "Zi50Ymwuc2V0Q29sdW1uV2lkdGgoMCwgNTApCiAgICAgICAgICAgIHNlbGYudGJsLnNldENvbHVtbldpZHRoKDEsIDcwKQogICAgICAgICAgICBzZWxmLnRi"
    "bC5zZXRDb2x1bW5XaWR0aCgyLCA3MCkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICBwYXNzCiAgICAgICAgdi5hZGRXaWRnZXQoc2Vs"
    "Zi50YmwsMSkKICAgICAgICBzZWxmLl9yYW5nZXM9W10gIyBsaXN0IG9mIChRVGltZSxRVGltZSxzdGVwKQogICAgICAgIHNlbGYuYl9hdXRvLmNsaWNrZWQu"
    "Y29ubmVjdChzZWxmLmdlbmVyYXRlKQogICAgICAgIHNlbGYuYl9yZXNldC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5yZXNldCkKICAgICAgICBzZWxmLmJfZGVs"
    "LmNsaWNrZWQuY29ubmVjdChzZWxmLmRlbF9yb3cpCgogICAgZGVmIGFkZF9yb3coc2VsZik6CiAgICAgICAgcj1zZWxmLnRibC5yb3dDb3VudCgpOyBzZWxm"
    "LnRibC5pbnNlcnRSb3cocikKICAgICAgICBpdDA9UXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oc3RyKHIrMSkpOyBpdDAuc2V0VGV4dEFsaWdubWVudChR"
    "dENvcmUuUXQuQWxpZ25IQ2VudGVyfFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpOyBzZWxmLnRibC5zZXRJdGVtKHIsMCxpdDApO2l0MT1RdFdpZGdldHMuUVRh"
    "YmxlV2lkZ2V0SXRlbShzZWxmLnQxLnRpbWUoKS50b1N0cmluZygiSEg6bW0iKSk7IGl0MS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50"
    "ZXJ8UXRDb3JlLlF0LkFsaWduVkNlbnRlcik7IHNlbGYudGJsLnNldEl0ZW0ociwxLGl0MSk7aXQyPVF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKHNlbGYu"
    "dDIudGltZSgpLnRvU3RyaW5nKCJISDptbSIpKTsgaXQyLnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlcnxRdENvcmUuUXQuQWxpZ25W"
    "Q2VudGVyKTsgc2VsZi50Ymwuc2V0SXRlbShyLDIsaXQyKTtpdDM9UXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oIiIpOyBpdDMuc2V0RmxhZ3MoaXQzLmZs"
    "YWdzKCkgJiB+UXRDb3JlLlF0Lkl0ZW1Jc0VkaXRhYmxlKTsgc2VsZi50Ymwuc2V0SXRlbShyLDMsaXQzKQoKICAgIGRlZiBkZWxfcm93KHNlbGYpOgogICAg"
    "ICAgIHJvd3M9c29ydGVkKHtpLnJvdygpIGZvciBpIGluIHNlbGYudGJsLnNlbGVjdGVkSW5kZXhlcygpfSwgcmV2ZXJzZT1UcnVlKQogICAgICAgIGZvciBy"
    "IGluIHJvd3M6IHNlbGYudGJsLnJlbW92ZVJvdyhyKQogICAgICAgIGZvciBpIGluIHJhbmdlKHNlbGYudGJsLnJvd0NvdW50KCkpOgogICAgICAgICAgICBz"
    "ZWxmLnRibC5zZXRJdGVtKGksMCxRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShzdHIoaSsxKSkpCgoKICAgIGRlZiByZXNldChzZWxmKToKICAgICAgICAi"
    "IiLsobDsgqzsi5zqsIQg7ISk7KCVIOy0iOq4sO2ZlDog67KU7JyE7JmAIO2FjOydtOu4lOydhCDrqqjrkZAg67mE7JuAIiIiCiAgICAgICAgaWYgUXRXaWRn"
    "ZXRzLlFNZXNzYWdlQm94LnF1ZXN0aW9uKHNlbGYsICLstIjquLDtmZQiLCAi7KGw7IKs7Iuc6rCEIOyEpOygleydhCDrqqjrkZAg67mE7Jq46rmM7JqUPyIp"
    "ICE9IFF0V2lkZ2V0cy5RTWVzc2FnZUJveC5ZZXM6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIHNlbGYuX3Jhbmdlcy5jbGVhcigpCiAgICAgICAgc2Vs"
    "Zi50Ymwuc2V0Um93Q291bnQoMCkKICAgIGRlZiBhZGRfcmFuZ2Uoc2VsZik6CiAgICAgICAgYT1zZWxmLnQxLnRpbWUoKTsgYj1zZWxmLnQyLnRpbWUoKTsg"
    "cz1zZWxmLnN0ZXAudmFsdWUoKQogICAgICAgIGlmIGE+PWI6IHJldHVybgogICAgICAgIGtleT0oYS50b1N0cmluZygnSEg6bW0nKSwgYi50b1N0cmluZygn"
    "SEg6bW0nKSwgcykKICAgICAgICBleGlzdHM9eyh4WzBdLnRvU3RyaW5nKCdISDptbScpLCB4WzFdLnRvU3RyaW5nKCdISDptbScpLCB4WzJdKSBmb3IgeCBp"
    "biBzZWxmLl9yYW5nZXN9CiAgICAgICAgaWYga2V5IGluIGV4aXN0czoKICAgICAgICAgICAgUXRXaWRnZXRzLlFNZXNzYWdlQm94LmluZm9ybWF0aW9uKHNl"
    "bGYsIuyVjOumvCIsIuydtOuvuCDrj5nsnbztlZwg6rWs6rCE7J20IOy2lOqwgOuQmOyWtCDsnojsirXri4jri6QuIik7IHJldHVybgogICAgICAgIHNlbGYu"
    "X3Jhbmdlcy5hcHBlbmQoKGEsYixzKSkKICAgICAgICBzZWxmLl9yZWZyZXNoX3JhbmdlcygpCgogICAgZGVmIF9yZWZyZXNoX3JhbmdlcyhzZWxmKToKICAg"
    "ICAgICBzZWxmLnRibC5zZXRSb3dDb3VudCgwKQogICAgICAgIGZvciBpLChhLGIscykgaW4gZW51bWVyYXRlKHNlbGYuX3JhbmdlcywxKToKICAgICAgICAg"
    "ICAgc2VsZi50YmwuaW5zZXJ0Um93KHNlbGYudGJsLnJvd0NvdW50KCkpCiAgICAgICAgICAgIHNlbGYudGJsLnNldEl0ZW0oc2VsZi50Ymwucm93Q291bnQo"
    "KS0xLDAsUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oc3RyKGkpKSk7CiAgICAgICAgICAgIHNlbGYudGJsLml0ZW0oc2VsZi50Ymwucm93Q291bnQoKS0x"
    "LDApLnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlcnxRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQogICAgICAgICAgICBzZWxmLnRibC5z"
    "ZXRJdGVtKHNlbGYudGJsLnJvd0NvdW50KCktMSwxLFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKGEudG9TdHJpbmcoJ0hIOm1tJykpKQogICAgICAgICAg"
    "ICBzZWxmLnRibC5zZXRJdGVtKHNlbGYudGJsLnJvd0NvdW50KCktMSwyLFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKGIudG9TdHJpbmcoJ0hIOm1tJykp"
    "KQoKICAgIEBzdGF0aWNtZXRob2QKICAgIGRlZiBfc2VnbWVudChhOlF0Q29yZS5RVGltZSwgYjpRdENvcmUuUVRpbWUsIHN0ZXA6aW50KToKICAgICAgICBp"
    "bXBvcnQgZGF0ZXRpbWUgYXMgX2R0CiAgICAgICAgdD1fZHQuZGF0ZXRpbWUoMjAwMCwxLDEsYS5ob3VyKCksYS5taW51dGUoKSkKICAgICAgICBlPV9kdC5k"
    "YXRldGltZSgyMDAwLDEsMSxiLmhvdXIoKSxiLm1pbnV0ZSgpKQogICAgICAgIG91dD1bXQogICAgICAgIHdoaWxlIHQ8ZToKICAgICAgICAgICAgdDI9dCtf"
    "ZHQudGltZWRlbHRhKG1pbnV0ZXM9c3RlcCkKICAgICAgICAgICAgaWYgdDI+ZTogYnJlYWsKICAgICAgICAgICAgb3V0LmFwcGVuZCgodC5zdHJmdGltZSgi"
    "JUg6JU0iKSwgdDIuc3RyZnRpbWUoIiVIOiVNIikpKQogICAgICAgICAgICB0PXQyCiAgICAgICAgcmV0dXJuIG91dAoKICAgIGRlZiBnZW5lcmF0ZShzZWxm"
    "KToKICAgICAgICAiIiLtmITsnqwg7Iuc7J6RL+yiheujjC/qsITqsqkg7ISk7KCV7J2EIOq4sOykgOycvOuhnCDsi5zqsITrjIDrpbwg7J6Q64+Z7IOd7ISx"
    "7ZWY7JesIOq4sOyhtCDrqqnroZ0g65Kk7JeQIOydtOyWtOu2meyeheuLiOuLpC4iIiIKICAgICAgICBzZWdzID0gc2VsZi5fc2VnbWVudChzZWxmLnQxLnRp"
    "bWUoKSwgc2VsZi50Mi50aW1lKCksIHNlbGYuc3RlcC52YWx1ZSgpKQogICAgICAgICMg6riw7KG0IO2WiSDsiJjrpbwg7Jyg7KeA7ZWcIOyxhCDrkqTsl5Ag"
    "7LaU6rCACiAgICAgICAgZm9yIHMsIGUgaW4gc2VnczoKICAgICAgICAgICAgciA9IHNlbGYudGJsLnJvd0NvdW50KCkKICAgICAgICAgICAgc2VsZi50Ymwu"
    "aW5zZXJ0Um93KHIpCiAgICAgICAgICAgIGl0MCA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKHN0cihyICsgMSkpCiAgICAgICAgICAgIGl0MC5zZXRU"
    "ZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXIgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQogICAgICAgICAgICBpdDAuc2V0RmxhZ3MoaXQw"
    "LmZsYWdzKCkgJiB+UXRDb3JlLlF0Lkl0ZW1Jc0VkaXRhYmxlKQogICAgICAgICAgICBpdDEgPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShzKQogICAg"
    "ICAgICAgICBpdDEuc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAg"
    "aXQxLnNldEZsYWdzKGl0MS5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNFZGl0YWJsZSkKICAgICAgICAgICAgaXQyID0gUXRXaWRnZXRzLlFUYWJsZVdp"
    "ZGdldEl0ZW0oZSkKICAgICAgICAgICAgaXQyLnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlciB8IFF0Q29yZS5RdC5BbGlnblZDZW50"
    "ZXIpCiAgICAgICAgICAgIGl0Mi5zZXRGbGFncyhpdDIuZmxhZ3MoKSAmIH5RdENvcmUuUXQuSXRlbUlzRWRpdGFibGUpCiAgICAgICAgICAgIHNlbGYudGJs"
    "LnNldEl0ZW0ociwgMCwgaXQwKQogICAgICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsIDEsIGl0MSkKICAgICAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShy"
    "LCAyLCBpdDIpCgoKICAgIGRlZiBzbG90cyhzZWxmKToKICAgICAgICAiIiLtmITsnqwg7YWM7J2067iU7JeQIO2RnOyLnOuQnCDsi5zqsITrjIAo67KI7Zi4"
    "L+yLnOyekS/sooXro4wp66W8IOq3uOuMgOuhnCDrsJjtmZjtlanri4jri6QuIiIiCiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0KCkKCiAgICBkZWYgZ2V0KHNl"
    "bGYpOgogICAgICAgIG91dD1bXQogICAgICAgIGZvciByIGluIHJhbmdlKHNlbGYudGJsLnJvd0NvdW50KCkpOgogICAgICAgICAgICBhPXNlbGYudGJsLml0"
    "ZW0ociwxKS50ZXh0KCkgaWYgc2VsZi50YmwuaXRlbShyLDEpIGVsc2UgIiIKICAgICAgICAgICAgYj1zZWxmLnRibC5pdGVtKHIsMikudGV4dCgpIGlmIHNl"
    "bGYudGJsLml0ZW0ociwyKSBlbHNlICIiCiAgICAgICAgICAgIG91dC5hcHBlbmQoeyLrsojtmLgiOnIrMSwi7Iuc7J6RIjphLCLsooXro4wiOmJ9KQogICAg"
    "ICAgIHJldHVybiBvdXQKCiAgICBkZWYgc2V0KHNlbGYsIHJvd3MpOgogICAgICAgIHNlbGYudGJsLnNldFJvd0NvdW50KDApCiAgICAgICAgZm9yIGkscm93"
    "IGluIGVudW1lcmF0ZShyb3dzIG9yIFtdKToKICAgICAgICAgICAgc2VsZi50YmwuaW5zZXJ0Um93KGkpCiAgICAgICAgICAgIGl0MCA9IFF0V2lkZ2V0cy5R"
    "VGFibGVXaWRnZXRJdGVtKHN0cihyb3cuZ2V0KCLrsojtmLgiLCBpICsgMSkpKQogICAgICAgICAgICBpdDAuc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQu"
    "QWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgaXQwLnNldEZsYWdzKGl0MC5mbGFncygpICYgflF0Q29yZS5RdC5J"
    "dGVtSXNFZGl0YWJsZSkKICAgICAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShpLCAwLCBpdDApCgogICAgICAgICAgICBpdDEgPSBRdFdpZGdldHMuUVRhYmxl"
    "V2lkZ2V0SXRlbShyb3cuZ2V0KCLsi5zsnpEiLCAiIikpCiAgICAgICAgICAgIGl0MS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXIg"
    "fCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQogICAgICAgICAgICBpdDEuc2V0RmxhZ3MoaXQxLmZsYWdzKCkgJiB+UXRDb3JlLlF0Lkl0ZW1Jc0VkaXRhYmxl"
    "KQogICAgICAgICAgICBzZWxmLnRibC5zZXRJdGVtKGksIDEsIGl0MSkKCiAgICAgICAgICAgIGl0MiA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKHJv"
    "dy5nZXQoIuyiheujjCIsICIiKSkKICAgICAgICAgICAgaXQyLnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlciB8IFF0Q29yZS5RdC5B"
    "bGlnblZDZW50ZXIpCiAgICAgICAgICAgIGl0Mi5zZXRGbGFncyhpdDIuZmxhZ3MoKSAmIH5RdENvcmUuUXQuSXRlbUlzRWRpdGFibGUpCiAgICAgICAgICAg"
    "IHNlbGYudGJsLnNldEl0ZW0oaSwgMiwgaXQyKQoKY2xhc3MgU3VydmV5VmVoaWNsZVRhYihRdFdpZGdldHMuUVdpZGdldCk6CiAgICBkZWYgX19pbml0X18o"
    "c2VsZiwgcGFnZSk6CiAgICAgICAgc3VwZXIoKS5fX2luaXRfXyhwYWdlKTsgc2VsZi5wYWdlID0gcGFnZQogICAgICAgIHY9UXRXaWRnZXRzLlFWQm94TGF5"
    "b3V0KHNlbGYpCiAgICAgICAgdG9wPVF0V2lkZ2V0cy5RSEJveExheW91dCgpCiAgICAgICAgdG9wLmFkZFdpZGdldChRdFdpZGdldHMuUUxhYmVsKCLssKjs"
    "ooUg7ISg7YOdIikpCiAgICAgICAgc2VsZi5jYj1RdFdpZGdldHMuUUNvbWJvQm94KCk7IHRvcC5hZGRXaWRnZXQoc2VsZi5jYiwxKQogICAgICAgIHNlbGYu"
    "Yl9yZWxvYWQ9UXRXaWRnZXRzLlFQdXNoQnV0dG9uKCLsnqzsnb3quLAiKTsgdG9wLmFkZFdpZGdldChzZWxmLmJfcmVsb2FkKQogICAgICAgIHYuYWRkTGF5"
    "b3V0KHRvcCkKICAgICAgICBvcHQ9UXRXaWRnZXRzLlFIQm94TGF5b3V0KCkKICAgICAgICBzZWxmLmNoa19sb2NhbD1RdFdpZGdldHMuUUNoZWNrQm94KCLs"
    "obDsgqwg66Gc7LusIO2OuOynkSjsm5Drs7gg642u7Ja07JOw6riwIOyVhOuLmCkiKQogICAgICAgIG9wdC5hZGRXaWRnZXQoc2VsZi5jaGtfbG9jYWwpOyBv"
    "cHQuYWRkU3RyZXRjaCgxKQogICAgICAgIHNlbGYuYl9jb3B5PVF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi7ZSE66Gc7KCd7Yq47JeQ7IScIOuzteyCrCIpOyBz"
    "ZWxmLmJfYWRkPVF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi7ZaJIOy2lOqwgCIpOyBzZWxmLmJfZGVsPVF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi7ZaJIOyCreyg"
    "nCIpCiAgICAgICAgZm9yIGIgaW4gKHNlbGYuYl9jb3B5LHNlbGYuYl9hZGQsc2VsZi5iX2RlbCk6IG9wdC5hZGRXaWRnZXQoYikKICAgICAgICB2LmFkZExh"
    "eW91dChvcHQpCiAgICAgICAgc2VsZi50Ymw9UXRXaWRnZXRzLlFUYWJsZVdpZGdldCggMCw0KTsgc2VsZi50Ymwuc2V0SG9yaXpvbnRhbEhlYWRlckxhYmVs"
    "cyhbIuywqOyiheuqhSIsIuyInOuyiCIsIuuLqOy2le2CpCIsIiJdKTsgc2VsZi50YmwuaG9yaXpvbnRhbEhlYWRlcigpLnNldFN0cmV0Y2hMYXN0U2VjdGlv"
    "bihUcnVlKQogICAgICAgIHNlbGYudGJsLnNldEhvcml6b250YWxIZWFkZXJMYWJlbHMoWyLsiJzrsogiLCLssKjsooXrqoUiLCLri6jstpXtgqQiLCIiXSkK"
    "ICAgICAgICBzZWxmLnRibC52ZXJ0aWNhbEhlYWRlcigpLnNldFZpc2libGUoRmFsc2UpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBzZWxmLnRibC5ob3Jp"
    "em9udGFsSGVhZGVyKCkuc2V0RGVmYXVsdEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAg"
    "ICAgICAgIHBhc3MKICAgICAgICAjIOyXtCDqsIDroZztj60g6rOg7KCVOiDsiJzrsogv7LCo7KKF66qFL+uLqOy2le2CpC/ruYjsl7QKICAgICAgICB0cnk6"
    "CiAgICAgICAgICAgIHNlbGYudGJsLnNldENvbHVtbldpZHRoKDAsIDUwKQogICAgICAgICAgICBzZWxmLnRibC5zZXRDb2x1bW5XaWR0aCgxLCAxNTApCiAg"
    "ICAgICAgICAgIHNlbGYudGJsLnNldENvbHVtbldpZHRoKDIsIDEyMCkgICMg64uo7LaV7YKkIOyXtCDrhJPqsowKICAgICAgICBleGNlcHQgRXhjZXB0aW9u"
    "OgogICAgICAgICAgICBwYXNzCiAgICAgICAgdi5hZGRXaWRnZXQoc2VsZi50YmwsMSkKICAgICAgICBzZWxmLmJfcmVsb2FkLmNsaWNrZWQuY29ubmVjdChz"
    "ZWxmLnJlZnJlc2hfY29tYm8pOyBzZWxmLmNiLmN1cnJlbnRJbmRleENoYW5nZWQuY29ubmVjdChzZWxmLmxvYWRfZnJvbV9wcm9qKQogICAgICAgIHNlbGYu"
    "Yl9jb3B5LmNsaWNrZWQuY29ubmVjdChzZWxmLmNvcHlfZnJvbV9wcm9qKTsgc2VsZi5iX2FkZC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5hZGRfcm93KTsgc2Vs"
    "Zi5iX2RlbC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5kZWxfcm93KQogICAgICAgIHNlbGYucmVmcmVzaF9jb21ibygpCgogICAgZGVmIHJlZnJlc2hfY29tYm8o"
    "c2VsZik6CiAgICAgICAgc2VsZi5jYi5ibG9ja1NpZ25hbHMoVHJ1ZSk7IHNlbGYuY2IuY2xlYXIoKQogICAgICAgIGZvciBwIGluIHNlbGYucGFnZS5kYXRh"
    "WyJwcm9qZWN0cyJdOiBzZWxmLmNiLmFkZEl0ZW0ocFsibmFtZSJdKQogICAgICAgIHNlbGYuY2IuYmxvY2tTaWduYWxzKEZhbHNlKTsgc2VsZi5sb2FkX2Zy"
    "b21fcHJvaigpCgogICAgZGVmIHByb2pfcm93cyhzZWxmKToKICAgICAgICBpPXNlbGYuY2IuY3VycmVudEluZGV4KCk7IAogICAgICAgIHJldHVybiBzZWxm"
    "LnBhZ2UuZGF0YVsicHJvamVjdHMiXVtpXS5nZXQoInZlaGljbGVfc2V0IixbXSkgaWYgaT49MCBlbHNlIFtdCgogICAgZGVmIGxvYWRfZnJvbV9wcm9qKHNl"
    "bGYpOgogICAgICAgIGlmIHNlbGYuY2hrX2xvY2FsLmlzQ2hlY2tlZCgpOgogICAgICAgICAgICByZXR1cm4KICAgICAgICBzZWxmLnRibC5zZXRSb3dDb3Vu"
    "dCgwKQogICAgICAgIGZvciBpLCByb3cgaW4gZW51bWVyYXRlKHNlbGYucHJval9yb3dzKCksIDEpOgogICAgICAgICAgICByID0gc2VsZi50Ymwucm93Q291"
    "bnQoKQogICAgICAgICAgICBzZWxmLnRibC5pbnNlcnRSb3cocikKICAgICAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShyLCAwLCBRdFdpZGdldHMuUVRhYmxl"
    "V2lkZ2V0SXRlbShzdHIoaSkpKQogICAgICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsIDEsIFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKHJvdy5nZXQo"
    "IuywqOyiheuqhSIsICIiKSkpCiAgICAgICAgICAgIHNlbGYudGJsLnNldEl0ZW0ociwgMiwgUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oIiIpKQogICAg"
    "ICAgICAgICBmb3IgYyBpbiAoMCwgMSwgMik6CiAgICAgICAgICAgICAgICBpdCA9IHNlbGYudGJsLml0ZW0ociwgYykKICAgICAgICAgICAgICAgIGlmIGl0"
    "OgogICAgICAgICAgICAgICAgICAgIGl0LnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlciB8IFF0Q29yZS5RdC5BbGlnblZDZW50ZXIp"
    "CiAgICAgICAgdHJ5OgogICAgICAgICAgICAjIOyhsOyCrOywqOyihSDshKTsoJUg7Iuc7Yq4IOyXtCDtj60g6rOg7KCVOiDsiJzrsoggLyDssKjsooXrqoUg"
    "LyDri6jstpXtgqQKICAgICAgICAgICAgc2VsZi50Ymwuc2V0Q29sdW1uV2lkdGgoMCwgNjApCiAgICAgICAgICAgIHNlbGYudGJsLnNldENvbHVtbldpZHRo"
    "KDEsIDE1MCkKICAgICAgICAgICAgc2VsZi50Ymwuc2V0Q29sdW1uV2lkdGgoMiwgNjApCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAg"
    "cGFzcwoKCgogICAgZGVmIGNvcHlfZnJvbV9wcm9qKHNlbGYpOgogICAgICAgIHNlbGYudGJsLnNldFJvd0NvdW50KDApCiAgICAgICAgZm9yIGkscm93IGlu"
    "IGVudW1lcmF0ZShzZWxmLnByb2pfcm93cygpLDEpOgogICAgICAgICAgICByPXNlbGYudGJsLnJvd0NvdW50KCk7IHNlbGYudGJsLmluc2VydFJvdyhyKQog"
    "ICAgICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsMCxRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShzdHIoaSkpKQogICAgICAgICAgICBzZWxmLnRibC5z"
    "ZXRJdGVtKHIsMSxRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShyb3cuZ2V0KCLssKjsooXrqoUiLCIiKSkpCiAgICAgICAgICAgIHNlbGYudGJsLnNldEl0"
    "ZW0ociwyLFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKCIiKSkKICAgICAgICAgICAgZm9yIGMgaW4gKDAsMSwyKToKICAgICAgICAgICAgICAgIGl0ID0g"
    "c2VsZi50YmwuaXRlbShyLGMpCiAgICAgICAgICAgICAgICBpZiBpdDogaXQuc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyfFF0Q29y"
    "ZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAgICAgIAogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAjIOyhsOyCrOywqOyihSDshKTsoJUg7Iuc"
    "7Yq4IOyXtCDtj60g6rOg7KCVOiDsiJzrsoggLyDssKjsooXrqoUgLyDri6jstpXtgqQKICAgICAgICAgICAgICAgIHNlbGYudGJsLnNldENvbHVtbldpZHRo"
    "KDAsIDYwKQogICAgICAgICAgICAgICAgc2VsZi50Ymwuc2V0Q29sdW1uV2lkdGgoMSwgMTUwKQogICAgICAgICAgICAgICAgc2VsZi50Ymwuc2V0Q29sdW1u"
    "V2lkdGgoMiwgNjApCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICBwYXNzCgogICAgICAgIAoKICAgIGRlZiBhZGRfcm93"
    "KHNlbGYpOgogICAgICAgIHI9c2VsZi50Ymwucm93Q291bnQoKTsgc2VsZi50YmwuaW5zZXJ0Um93KHIpCiAgICAgICAgaXQwPVF0V2lkZ2V0cy5RVGFibGVX"
    "aWRnZXRJdGVtKHN0cihyKzEpKTsgaXQwLnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlcnxRdENvcmUuUXQuQWxpZ25WQ2VudGVyKTsg"
    "aXQwLnNldEZsYWdzKGl0MC5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNFZGl0YWJsZSk7IHNlbGYudGJsLnNldEl0ZW0ociwwLGl0MCk7aXQxPVF0V2lk"
    "Z2V0cy5RVGFibGVXaWRnZXRJdGVtKCIiKTsgaXQxLnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlcnxRdENvcmUuUXQuQWxpZ25WQ2Vu"
    "dGVyKTsgc2VsZi50Ymwuc2V0SXRlbShyLDEsaXQxKTtpdDI9UXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oIiIpOyBpdDIuc2V0VGV4dEFsaWdubWVudChR"
    "dENvcmUuUXQuQWxpZ25IQ2VudGVyfFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpOyBzZWxmLnRibC5zZXRJdGVtKHIsMixpdDIpO2l0Mz1RdFdpZGdldHMuUVRh"
    "YmxlV2lkZ2V0SXRlbSgiIik7IGl0My5zZXRGbGFncyhpdDMuZmxhZ3MoKSAmIH5RdENvcmUuUXQuSXRlbUlzRWRpdGFibGUpOyBzZWxmLnRibC5zZXRJdGVt"
    "KHIsMyxpdDMpCiAgICAgICAgCgogICAgZGVmIGRlbF9yb3coc2VsZik6CiAgICAgICAgcj1zZWxmLnRibC5jdXJyZW50Um93KCk7IAogICAgICAgIGlmIHI+"
    "PTA6IHNlbGYudGJsLnJlbW92ZVJvdyhyKQoKICAgIGRlZiBnZXQoc2VsZik6CiAgICAgICAgb3V0PVtdCiAgICAgICAgZm9yIHIgaW4gcmFuZ2Uoc2VsZi50"
    "Ymwucm93Q291bnQoKSk6CiAgICAgICAgICAgIG91dC5hcHBlbmQoeyLsiJzrsogiOnIrMSwKICAgICAgICAgICAgICAgICAgICAgICAgIuywqOyiheuqhSI6"
    "IHNlbGYudGJsLml0ZW0ociwxKS50ZXh0KCkgaWYgc2VsZi50YmwuaXRlbShyLDEpIGVsc2UgIiIsCiAgICAgICAgICAgICAgICAgICAgICAgICLri6jstpXt"
    "gqQiOiBzZWxmLnRibC5pdGVtKHIsMikudGV4dCgpIGlmIHNlbGYudGJsLml0ZW0ociwyKSBlbHNlICIifSkKICAgICAgICByZXR1cm4geyLsnpHsl4XssLjs"
    "obAiOiBzZWxmLmNiLmN1cnJlbnRUZXh0KCksICLroZzsu6ztjrjsp5EiOiBzZWxmLmNoa19sb2NhbC5pc0NoZWNrZWQoKSwgIuywqOyiheuqqeuhnSI6IG91"
    "dH0KCiAgICBkZWYgc2V0KHNlbGYsIGQpOgogICAgICAgIHNlbGYucmVmcmVzaF9jb21ibygpCiAgICAgICAgaWYgbm90IGQ6IHJldHVybgogICAgICAgIHNl"
    "bGYuY2hrX2xvY2FsLnNldENoZWNrZWQoYm9vbChkLmdldCgi66Gc7Lus7Y647KeRIiwgRmFsc2UpKSkKICAgICAgICBpZiBkLmdldCgi7J6R7JeF7LC47KGw"
    "Iik6IHNlbGYuY2Iuc2V0Q3VycmVudFRleHQoZFsi7J6R7JeF7LC47KGwIl0pCiAgICAgICAgcm93cz1kLmdldCgi7LCo7KKF66qp66GdIikKICAgICAgICBp"
    "ZiByb3dzOgogICAgICAgICAgICBzZWxmLnRibC5zZXRSb3dDb3VudCgwKQogICAgICAgICAgICBmb3IgaSxyb3cgaW4gZW51bWVyYXRlKHJvd3MsMSk6CiAg"
    "ICAgICAgICAgICAgICByPXNlbGYudGJsLnJvd0NvdW50KCk7IHNlbGYudGJsLmluc2VydFJvdyhyKQogICAgICAgICAgICAgICAgc2VsZi50Ymwuc2V0SXRl"
    "bShyLDAsUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oc3RyKGkpKSkKICAgICAgICAgICAgICAgIHNlbGYudGJsLnNldEl0ZW0ociwxLFF0V2lkZ2V0cy5R"
    "VGFibGVXaWRnZXRJdGVtKHJvdy5nZXQoIuywqOyiheuqhSIsIiIpKSkKICAgICAgICAgICAgICAgIHNlbGYudGJsLnNldEl0ZW0ociwyLFF0V2lkZ2V0cy5R"
    "VGFibGVXaWRnZXRJdGVtKHJvdy5nZXQoIuuLqOy2le2CpCIsIiIpKSkKICAgICAgICAgICAgICAgIGZvciBjIGluICgwLDEsMik6CiAgICAgICAgICAgICAg"
    "ICAgICAgaXQ9c2VsZi50YmwuaXRlbShyLGMpCiAgICAgICAgICAgICAgICAgICAgaWYgaXQ6IGl0LnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWdu"
    "SENlbnRlcnxRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQoKICAgICAgICAgICAgICAgIAogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAjIOyhsOyC"
    "rOywqOyihSDshKTsoJUg7Iuc7Yq4IOyXtCDtj60g6rOg7KCVOiDsiJzrsoggLyDssKjsooXrqoUgLyDri6jstpXtgqQKICAgICAgICAgICAgICAgIHNlbGYu"
    "dGJsLnNldENvbHVtbldpZHRoKDAsIDYwKQogICAgICAgICAgICAgICAgc2VsZi50Ymwuc2V0Q29sdW1uV2lkdGgoMSwgMTUwKQogICAgICAgICAgICAgICAg"
    "c2VsZi50Ymwuc2V0Q29sdW1uV2lkdGgoMiwgNjApCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICBwYXNzCgoKY2xhc3Mg"
    "U3VydmV5U2l0ZXNUYWIoUXRXaWRnZXRzLlFXaWRnZXQpOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHBhZ2UpOgogICAgICAgIHN1cGVyKCkuX19pbml0X18o"
    "cGFnZSkKICAgICAgICBzZWxmLnBhZ2UgPSBwYWdlCiAgICAgICAgIyByb3dfa2V5IC0+IHsiZ3JvdXBzIjogWy4uLl0sICJjb3VudGVycyI6IFsuLi5dfQog"
    "ICAgICAgIHNlbGYuc2l0ZV9kYXRhID0ge30KCiAgICAgICAgcm9vdCA9IFF0V2lkZ2V0cy5RSEJveExheW91dChzZWxmKQoKICAgICAgICAjIC0tLS0tLS0t"
    "IOyijOy4oTog7KeA7KCQ7KCV67O0IC0tLS0tLS0tCiAgICAgICAgbGVmdCA9IFF0V2lkZ2V0cy5RVkJveExheW91dCgpCiAgICAgICAgdGl0bGUgPSBRdFdp"
    "ZGdldHMuUUxhYmVsKCLsp4DsoJDsoJXrs7QiKQogICAgICAgIGxlZnQuYWRkV2lkZ2V0KHRpdGxlKQoKICAgICAgICAjIOyInOuyiCAvIOyngOuyiCAvIOyn"
    "gOygkOuqhSAvIOyekeyXheuyiO2YuCAvIOuwqe2WpeyImCAvIOyDge2DnCAvICjruYgg7Je0KQogICAgICAgIHNlbGYudGJsID0gUXRXaWRnZXRzLlFUYWJs"
    "ZVdpZGdldCgwLCA3KQogICAgICAgIHNlbGYudGJsLnNldEhvcml6b250YWxIZWFkZXJMYWJlbHMoWyLsiJzrsogiLCAi7KeA67KIIiwgIuyngOygkOuqhSIs"
    "ICLsnpHsl4XrsojtmLgiLCAi67Cp7Zal7IiYIiwgIuyDge2DnCIsICIiXSkKICAgICAgICBzZWxmLnRibC52ZXJ0aWNhbEhlYWRlcigpLnNldFZpc2libGUo"
    "RmFsc2UpCiAgICAgICAgIyDsp4DsoJDsoJXrs7Qg66as7Iqk7Yq4IO2WiSDrhpLsnbTrpbwg6riw7KG067O064ukIOyVvSAzcHgg7KSE7Jes7IScIO2RnOyL"
    "nAogICAgICAgIHRyeToKICAgICAgICAgICAgdmggPSBzZWxmLnRibC52ZXJ0aWNhbEhlYWRlcigpCiAgICAgICAgICAgIHZoLnNldERlZmF1bHRTZWN0aW9u"
    "U2l6ZShtYXgoMCwgdmguZGVmYXVsdFNlY3Rpb25TaXplKCkgLSAzKSkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICBwYXNzCiAgICAg"
    "ICAgIyDtkZzshKDsnbQg67O07J207KeAIOyViuuPhOuhnSDshKTsoJUgKOyKpO2BrOumsOyDtyDsiqTtg4DsnbwpCiAgICAgICAgc2VsZi50Ymwuc2V0U2hv"
    "d0dyaWQoRmFsc2UpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBzZWxmLnRibC5zZXRDb2x1bW5XaWR0aCgwLCAzOCkgICAjIOyInOuyiAogICAgICAgICAg"
    "ICBzZWxmLnRibC5zZXRDb2x1bW5XaWR0aCgxLCA0OCkgICAjIOyngOuyiAogICAgICAgICAgICBzZWxmLnRibC5zZXRDb2x1bW5XaWR0aCgyLCAxNDgpICAj"
    "IOyngOygkOuqhQogICAgICAgICAgICBzZWxmLnRibC5zZXRDb2x1bW5XaWR0aCgzLCA1NikgICAjIOyekeyXheuyiO2YuAogICAgICAgICAgICBzZWxmLnRi"
    "bC5zZXRDb2x1bW5XaWR0aCg0LCA0NikgICAjIOuwqe2WpeyImAogICAgICAgICAgICBzZWxmLnRibC5zZXRDb2x1bW5XaWR0aCg1LCA0NikgICAjIOyDge2D"
    "nAogICAgICAgICAgICBzZWxmLnRibC5zZXRDb2x1bW5XaWR0aCg2LCA2KSAgICMg7IOB7YOcIOyasOy4oSDruYgg7Iqs66GvCiAgICAgICAgZXhjZXB0IEV4"
    "Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgICAgICMg7KeA7KCQ7KCV67O0IO2FjOydtOu4lCDstZzshowg6rCA66GcIO2BrOq4sCDqs6DsoJUgKOy7"
    "rOufvCDtlanqs4Qg6riw7KSAKQogICAgICAgIHRyeToKICAgICAgICAgICAgc2VsZi50Ymwuc2V0TWluaW11bVdpZHRoKDQyMCkKICAgICAgICBleGNlcHQg"
    "RXhjZXB0aW9uOgogICAgICAgICAgICBwYXNzCiAgICAgICAgIyDtlokg7KCE7LK0IOyEoO2DnSArIO2VnOuyiCDrjZQg7YG066atIOuYkOuKlCDrjZTruJTt"
    "gbTrpq0g7IucIO2OuOynkSDqsIDriqUKICAgICAgICBzZWxmLnRibC5zZXRTZWxlY3Rpb25CZWhhdmlvcihRdFdpZGdldHMuUUFic3RyYWN0SXRlbVZpZXcu"
    "U2VsZWN0Um93cykKICAgICAgICBzZWxmLnRibC5zZXRTZWxlY3Rpb25Nb2RlKFF0V2lkZ2V0cy5RQWJzdHJhY3RJdGVtVmlldy5FeHRlbmRlZFNlbGVjdGlv"
    "bikKICAgICAgICBzZWxmLnRibC5zZXRFZGl0VHJpZ2dlcnMoCiAgICAgICAgICAgIFF0V2lkZ2V0cy5RQWJzdHJhY3RJdGVtVmlldy5TZWxlY3RlZENsaWNr"
    "ZWQKICAgICAgICAgICAgfCBRdFdpZGdldHMuUUFic3RyYWN0SXRlbVZpZXcuRWRpdEtleVByZXNzZWQKICAgICAgICAgICAgfCBRdFdpZGdldHMuUUFic3Ry"
    "YWN0SXRlbVZpZXcuRG91YmxlQ2xpY2tlZAogICAgICAgICkKICAgICAgICBzZWxmLnRibC5ob3Jpem9udGFsSGVhZGVyKCkuc2V0U3RyZXRjaExhc3RTZWN0"
    "aW9uKFRydWUpCiAgICAgICAgbGVmdC5hZGRXaWRnZXQoc2VsZi50YmwsIDEpCgogICAgICAgIGJ0bl9yb3cgPSBRdFdpZGdldHMuUUhCb3hMYXlvdXQoKQog"
    "ICAgICAgIHNlbGYuYl90b3AgPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIuKGkeKGkSIpCiAgICAgICAgc2VsZi5iX3VwID0gUXRXaWRnZXRzLlFQdXNoQnV0"
    "dG9uKCLilrIiKQogICAgICAgIHNlbGYuYl9kbiA9IFF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi4pa8IikKICAgICAgICBzZWxmLmJfYXBwbHlfaW4gPSBRdFdp"
    "ZGdldHMuUVB1c2hCdXR0b24oIuyeheugpSDrk7HroZ0iKQogICAgICAgIHNlbGYuYl9hZGQgPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIuy2lOqwgCIpCiAg"
    "ICAgICAgc2VsZi5iX2RlbCA9IFF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi7IKt7KCcIikKICAgICAgICBmb3IgYiBpbiAoc2VsZi5iX3RvcCwgc2VsZi5iX3Vw"
    "LCBzZWxmLmJfZG4sIHNlbGYuYl9hcHBseV9pbiwgc2VsZi5iX2FkZCwgc2VsZi5iX2RlbCk6CiAgICAgICAgICAgIGJ0bl9yb3cuYWRkV2lkZ2V0KGIpCiAg"
    "ICAgICAgYnRuX3Jvdy5hZGRTdHJldGNoKDEpCiAgICAgICAgbGVmdC5hZGRMYXlvdXQoYnRuX3JvdykKCiAgICAgICAgcm9vdC5hZGRMYXlvdXQobGVmdCwg"
    "OCkKCiAgICAgICAgIyAtLS0tLS0tLSDsmrDsuKE6IOy5tOyatO2EsCDshKTsoJUgLS0tLS0tLS0KICAgICAgICByaWdodCA9IFF0V2lkZ2V0cy5RVkJveExh"
    "eW91dCgpCiAgICAgICAgZ2IgPSBRdFdpZGdldHMuUUdyb3VwQm94KCLsubTsmrTthLAg7ISk7KCVIikKICAgICAgICBnYi5zZXRNYXhpbXVtV2lkdGgoMjYw"
    "KQogICAgICAgIGcgPSBRdFdpZGdldHMuUUdyaWRMYXlvdXQoZ2IpCiAgICAgICAgZy5zZXRDb2x1bW5NaW5pbXVtV2lkdGgoMSwgMCkKICAgICAgICBnLnNl"
    "dENvbHVtbk1pbmltdW1XaWR0aCgyLCA1KSAgIyDtmZTsgrTtkZwg7Lus65+8KDLrsogp7J2YIOqwgOuhnCDsl6zrsLEg7KGw7KCV7JqpCiAgICAgICAgZy5z"
    "ZXRDb2x1bW5NaW5pbXVtV2lkdGgoMiwgMCkKICAgICAgICBnLnNldEhvcml6b250YWxTcGFjaW5nKDApCgogICAgICAgICMgMO2WiTog67Cp7Zal7IiYICsg"
    "7KCB7JqpL+yekOuPmeyDneyEsS/shKTsoJUg7KCA7J6lCiAgICAgICAgZy5hZGRXaWRnZXQoUXRXaWRnZXRzLlFMYWJlbCgi67Cp7Zal7IiYIiksIDAsIDAp"
    "CiAgICAgICAgc2VsZi5zcGluID0gUXRXaWRnZXRzLlFTcGluQm94KCkKICAgICAgICBzZWxmLnNwaW4uc2V0UmFuZ2UoMSwgNDApCiAgICAgICAgc2VsZi5z"
    "cGluLnNldFZhbHVlKDIpCiAgICAgICAgIyDrsKntlqXsiJgg7L2k67O067CV7Iqk6rCAIOyemCDrs7TsnbTrj4TroZ0g7KCB64u57ZWcIOqzoOyglSDtj63s"
    "nLzroZwg7ISk7KCVCiAgICAgICAgdHJ5OgogICAgICAgICAgICB3ID0gc2VsZi5zcGluLnNpemVIaW50KCkud2lkdGgoKQogICAgICAgICAgICBzZWxmLnNw"
    "aW4uc2V0Rml4ZWRXaWR0aChtYXgoNjAsIGludCh3ICogMC45KSkpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgc2VsZi5zcGluLnNl"
    "dEZpeGVkV2lkdGgoNjUpCiAgICAgICAgZy5hZGRXaWRnZXQoc2VsZi5zcGluLCAwLCAxKQoKICAgICAgICAjIOyekOuPmeyDneyEsSAvIO2FnO2UjOumvyDr"
    "soTtirw6IOyasOy4oSDsoJXroKwgKOyggOyepSDrsoTtirwg7KCc6rGwKQogICAgICAgIHNlbGYuYl9hdXRvID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCLs"
    "g53shLEiKQogICAgICAgIHNlbGYuYl90cGwgPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIu2FnO2UjOumvyIpCgogICAgICAgIHRyeToKICAgICAgICAgICAg"
    "YndfYXV0byA9IHNlbGYuYl9hdXRvLnNpemVIaW50KCkud2lkdGgoKQogICAgICAgICAgICBid190cGwgPSBzZWxmLmJfdHBsLnNpemVIaW50KCkud2lkdGgo"
    "KQogICAgICAgICAgICBzZWxmLmJfYXV0by5zZXRGaXhlZFdpZHRoKGludChid19hdXRvICogMS4wKSkKICAgICAgICAgICAgc2VsZi5iX3RwbC5zZXRGaXhl"
    "ZFdpZHRoKGludChid190cGwgKiAxLjApKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIHBhc3MKCiAgICAgICAgYnRuX3JvdyA9IFF0"
    "V2lkZ2V0cy5RSEJveExheW91dCgpCiAgICAgICAgYnRuX3Jvdy5hZGRTdHJldGNoKDEpCiAgICAgICAgYnRuX3Jvdy5hZGRXaWRnZXQoc2VsZi5iX2F1dG8p"
    "CiAgICAgICAgYnRuX3Jvdy5hZGRXaWRnZXQoc2VsZi5iX3RwbCkKICAgICAgICBnLmFkZExheW91dChidG5fcm93LCAwLCAzLCAxLCAyKQoKICAgICAgICAj"
    "IDHtlok6IOudvOuyqOuTpAogICAgICAgIGcuYWRkV2lkZ2V0KFF0V2lkZ2V0cy5RTGFiZWwoIuuwqe2WpeuyiO2YuCIpLCAxLCAwKQogICAgICAgIGcuYWRk"
    "V2lkZ2V0KFF0V2lkZ2V0cy5RTGFiZWwoIuyeheugpSDqt7jro7ko7YOtKSIpLCAxLCAyLCAxLCAyKQoKICAgICAgICAjIDJ+Ne2WiTog67Cp7Zal67KI7Zi4"
    "IOumrOyKpO2KuCAvIO2ZlOyCtO2RnCAvIOyeheugpSDqt7jro7ko7YOtKSAvIOy5tOyatO2EsAogICAgICAgIHNlbGYuZGlyID0gUXRXaWRnZXRzLlFMaXN0"
    "V2lkZ2V0KCkKICAgICAgICBzZWxmLmRpci5zZXRTZWxlY3Rpb25Nb2RlKFF0V2lkZ2V0cy5RQWJzdHJhY3RJdGVtVmlldy5FeHRlbmRlZFNlbGVjdGlvbikK"
    "ICAgICAgICBzZWxmLmRpci5zZXRGaXhlZFdpZHRoKDUwKQogICAgICAgIHNlbGYuZGlyLnNldE1pbmltdW1IZWlnaHQoMjkwKQogICAgICAgIGcuYWRkV2lk"
    "Z2V0KHNlbGYuZGlyLCAyLCAwLCA1LCAxLCBhbGlnbm1lbnQ9UXRDb3JlLlF0LkFsaWduUmlnaHQgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQoKICAgICAg"
    "ICB2YnRuID0gUXRXaWRnZXRzLlFWQm94TGF5b3V0KCkKICAgICAgICB2YnRuLnNldENvbnRlbnRzTWFyZ2lucygwLCAyLCAwLCAxKSAgIyDtmZTsgrTtkZwg"
    "7KKM7JqwIOyXrOuwsSDsobDsoJUKICAgICAgICB2YnRuLmFkZFN0cmV0Y2goMSkKICAgICAgICBzZWxmLnRvID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCLi"
    "lrYiKQogICAgICAgIHNlbGYuZnIgPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIuKXgCIpCiAgICAgICAgdmJ0bi5hZGRXaWRnZXQoc2VsZi50bykKICAgICAg"
    "ICB2YnRuLmFkZFdpZGdldChzZWxmLmZyKQogICAgICAgIHZidG4uYWRkU3RyZXRjaCgxKQogICAgICAgIGcuYWRkTGF5b3V0KHZidG4sIDIsIDEsIDQsIDEs"
    "IGFsaWdubWVudD1RdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKCiAgICAgICAgIyDsmKTrpbjsqr0g7JyEOiDsnoXr"
    "oKUg6re466O5KO2DrSkKICAgICAgICBzZWxmLnRhYnMgPSBRdFdpZGdldHMuUUxpc3RXaWRnZXQoKQogICAgICAgIHNlbGYudGFicy5zZXRGaXhlZFdpZHRo"
    "KDE1MCkKICAgICAgICAjIOyEuOuhnCDrhpLsnbTrpbwg642UIOykhOyXrOyEnCjslb0gMTAwIOygleuPhCkg7ZWY64uoIOy5tOyatO2EsCDsi5ztirgg6rO1"
    "6rCE7J2EIO2ZleuztAogICAgICAgIHRyeToKICAgICAgICAgICAgaCA9IHNlbGYudGFicy5zaXplSGludCgpLmhlaWdodCgpCiAgICAgICAgICAgIGlmIGgg"
    "PiAxMDA6CiAgICAgICAgICAgICAgICBzZWxmLnRhYnMuc2V0TWluaW11bUhlaWdodChtYXgoNDAsIGggLSAxMDApKQogICAgICAgICAgICAgICAgc2VsZi50"
    "YWJzLnNldE1heGltdW1IZWlnaHQobWF4KDQwLCBoIC0gMTAwKSkKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHNlbGYudGFicy5zZXRNaW5p"
    "bXVtSGVpZ2h0KDQwKQogICAgICAgICAgICAgICAgc2VsZi50YWJzLnNldE1heGltdW1IZWlnaHQoNDApCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAg"
    "ICAgICAgICAgcGFzcwogICAgICAgIGcuYWRkV2lkZ2V0KHNlbGYudGFicywgMiwgMiwgMiwgNCkKCiAgICAgICAgIyDsmKTrpbjsqr0g7JWE656YOiDsubTs"
    "mrTthLAg7YWM7J2067iUCiAgICAgICAgZy5hZGRXaWRnZXQoUXRXaWRnZXRzLlFMYWJlbCgi7Lm07Jq07YSwIiksIDQsIDIsIDEsIDIpCiAgICAgICAgc2Vs"
    "Zi5jdCA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXQoMCwgNCkKICAgICAgICBzZWxmLmN0LnNldE1pbmltdW1XaWR0aCgxMTApCiAgICAgICAgIyDshLjroZwg"
    "64aS7J2064+EIOyVvSAxMCDstpXshowKICAgICAgICB0cnk6CiAgICAgICAgICAgIGggPSBzZWxmLmN0LnNpemVIaW50KCkuaGVpZ2h0KCkKICAgICAgICAg"
    "ICAgaWYgaCA+IDEwOgogICAgICAgICAgICAgICAgc2VsZi5jdC5zZXRNaW5pbXVtSGVpZ2h0KDcwKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAg"
    "ICAgICAgIHBhc3MKICAgICAgICAjIOy5tOyatO2EsCDsi5ztirgg64aS7J2064qUIO2YhOyerCDroIjsnbTslYTsm4Mg67mE7Jyo7JeQ66eMIOunoeq4tOuL"
    "pCAo67OE64+EIOymneqwgCDsl4bsnYwpCiAgICAgICAgIyDsl7Qg6rWs7ISxOiDsubTsmrTthLAgLyDrsojtmLggLyDtkZzsi5zrqoUgLyAo67mI7Lm4KQog"
    "ICAgICAgIHNlbGYuY3Quc2V0SG9yaXpvbnRhbEhlYWRlckxhYmVscyhbIuy5tOyatO2EsCIsICLrsKntlqUiLCAi7ZGc7Iuc66qFIiwgIiJdKQogICAgICAg"
    "IHNlbGYuY3QudmVydGljYWxIZWFkZXIoKS5zZXRWaXNpYmxlKEZhbHNlKQogICAgICAgICMg7Lm07Jq07YSwIO2FjOydtOu4lCDtj7Dtirgg7YGs6riwIOy2"
    "leyGjCAo7J6F66Cl6re466O5IOyLnO2KuOyZgCDsnKDsgqztlZjqsowpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBmID0gc2VsZi5jdC5mb250KCkKICAg"
    "ICAgICAgICAgaWYgZi5wb2ludFNpemUoKSA+IDA6CiAgICAgICAgICAgICAgICBmLnNldFBvaW50U2l6ZShtYXgoOCwgZi5wb2ludFNpemUoKSAtIDMpKQog"
    "ICAgICAgICAgICAgICAgc2VsZi5jdC5zZXRGb250KGYpCiAgICAgICAgICAgICAgICBzZWxmLmN0Lmhvcml6b250YWxIZWFkZXIoKS5zZXRGb250KGYpCiAg"
    "ICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgICAgICMg7ZaJIOuGkuydtOuPhCDspITsl6zshJwg7IS466GcIOqwhOqyqeyd"
    "hCDstpXshowKICAgICAgICB0cnk6CiAgICAgICAgICAgIHZoID0gc2VsZi5jdC52ZXJ0aWNhbEhlYWRlcigpCiAgICAgICAgICAgIGggPSB2aC5kZWZhdWx0"
    "U2VjdGlvblNpemUoKQogICAgICAgICAgICBpZiBoID4gMTQ6CiAgICAgICAgICAgICAgICB2aC5zZXREZWZhdWx0U2VjdGlvblNpemUobWF4KDEwLCBoIC0g"
    "NikpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgICAgICMg7Zek642UOiDrp4jsp4Drp4kg7Je0KOu5iOy5uCnsnYAg"
    "7LWc64yA7ZWcIOyigeqyjCDsgqzsmqkgKOuCqOuKlCDqs7XqsITsnYQg7LGE7Jqw7KeAIOyViuuPhOuhnSkKICAgICAgICBoZWFkZXIgPSBzZWxmLmN0Lmhv"
    "cml6b250YWxIZWFkZXIoKQogICAgICAgIGhlYWRlci5zZXRTdHJldGNoTGFzdFNlY3Rpb24oRmFsc2UpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBoZWFk"
    "ZXIuc2V0U2VjdGlvblJlc2l6ZU1vZGUoMywgUXRXaWRnZXRzLlFIZWFkZXJWaWV3LkZpeGVkKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAg"
    "ICAgIHBhc3MKICAgICAgICAgICAgICAgICMg7Lm07Jq07YSwIOyLnO2KuCDsl7Qg6rCA66Gc7Y+t7J2EIDEvMiDsiJjspIDsnLzroZwg7LaV7IaMICjsu7Tt"
    "jKntirjtlZjqsowpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBzZWxmLmN0LnNldENvbHVtbldpZHRoKDAsIDYwKSAgICMg7Lm07Jq07YSwCiAgICAgICAg"
    "ICAgIHNlbGYuY3Quc2V0Q29sdW1uV2lkdGgoMSwgNDApICAgIyDrsKntlqUKICAgICAgICAgICAgc2VsZi5jdC5zZXRDb2x1bW5XaWR0aCgyLCAxMjApICAj"
    "IO2RnOyLnOuqhQogICAgICAgICAgICBzZWxmLmN0LnNldENvbHVtbldpZHRoKDMsIDEpICAgICMg67mI7Lm4IO2PrSDstZzrjIDtlZwg7LaV7IaMCiAgICAg"
    "ICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgICAgIHRyeToKICAgICAgICAgICAgc2VsZi5jdC5zZXRDb2x1bW5XaWR0aCgwLCA4"
    "MCkKICAgICAgICAgICAgc2VsZi5jdC5zZXRDb2x1bW5XaWR0aCgwLCA4MCkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICBwYXNzCiAg"
    "ICAgICAgZy5hZGRXaWRnZXQoc2VsZi5jdCwgNSwgMiwgMiwgNCkKCiAgICAgICAgIyDsubTsmrTthLAg7IWAIOuNlOu4lO2BtOumrSDsi5wg64uo7LaV7YKk"
    "IOygleuztCDtjJ3sl4UKICAgICAgICBzZWxmLmN0LmNlbGxEb3VibGVDbGlja2VkLmNvbm5lY3Qoc2VsZi5fb25fY291bnRlcl9jZWxsX2RvdWJsZV9jbGlj"
    "a2VkKQogICAgICAgICMg7ZGc7Iuc66qFIOuTsSDsubTsmrTthLDsi5ztirgg7Y647KeRIOymieyLnCDsoIDsnqUo7ZiE7J6sIOyngOygkCByb3fsl5Ag67CY"
    "7JiBKQogICAgICAgIHRyeToKICAgICAgICAgICAgc2VsZi5jdC5pdGVtQ2hhbmdlZC5jb25uZWN0KGxhbWJkYSAqXzogc2VsZi5fYXBwbHlfdG9fY3VycmVu"
    "dF9yb3coRmFsc2UpKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIHBhc3MKCiAgICAgICAgIyDsubTsmrTthLAg7ZWY64uoIOy2lOqw"
    "gC/sgq3soJwg67KE7Yq8IOygnOqxsCAo66CI7J207JWE7JuD7JeQIOy2lOqwgO2VmOyngCDslYrsnYwpCiAgICAgICAgaGIgPSBRdFdpZGdldHMuUUhCb3hM"
    "YXlvdXQoKQogICAgICAgIHNlbGYuY19hZGQgPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIuy2lOqwgCIpCiAgICAgICAgc2VsZi5jX2RlbCA9IFF0V2lkZ2V0"
    "cy5RUHVzaEJ1dHRvbigi7IKt7KCcIikKICAgICAgICAjIGhiLmFkZFdpZGdldChzZWxmLmNfYWRkKQogICAgICAgICMgaGIuYWRkV2lkZ2V0KHNlbGYuY19k"
    "ZWwpCiAgICAgICAgIyBoYi5hZGRTdHJldGNoKDEpCiAgICAgICAgIyBnLmFkZExheW91dChoYiwgNywgMywgMSwgMikKCiAgICAgICAgcmlnaHQuYWRkV2lk"
    "Z2V0KGdiLCAxKQoKICAgICAgICBzZWxmLmJfcHJldmlldyA9IFF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi7Iuc7Yq4IOuvuOumrOuztOq4sCIpCiAgICAgICAg"
    "cmlnaHQuYWRkV2lkZ2V0KHNlbGYuYl9wcmV2aWV3LCAwLCBhbGlnbm1lbnQ9UXRDb3JlLlF0LkFsaWduUmlnaHQpCgogICAgICAgIHJvb3QuYWRkTGF5b3V0"
    "KHJpZ2h0LCAxKQoKICAgICAgICAjIOugiOydtOyVhOybgyDruYTsnKgg7KGw7KCVCiAgICAgICAgIyDsnoXroKXqt7jro7ko7YOtKSDsmIHsl63snYQg7KGw"
    "6riIIOykhOydtOqzoCwg7ZWY64uoIOy5tOyatO2EsCDsi5ztirgg7JiB7Jet7J2EIOuKmOumsOuLpC4KICAgICAgICBnLnNldFJvd1N0cmV0Y2goMiwgMikK"
    "ICAgICAgICBnLnNldFJvd1N0cmV0Y2goNSwgMykKCiAgICAgICAgIyAtLS0tLS0tLSDsi5zqt7jrhJAg7Jew6rKwIC0tLS0tLS0tCiAgICAgICAgc2VsZi50"
    "YmwuY3VycmVudENlbGxDaGFuZ2VkLmNvbm5lY3Qoc2VsZi5fb25fc2VsZWN0X3JvdykKICAgICAgICBzZWxmLmJfYXV0by5jbGlja2VkLmNvbm5lY3Qoc2Vs"
    "Zi5nZW5fZGlycykKICAgICAgICBzZWxmLnRvLmNsaWNrZWQuY29ubmVjdChzZWxmLnRvX3RhYnMpCiAgICAgICAgc2VsZi5mci5jbGlja2VkLmNvbm5lY3Qo"
    "c2VsZi5mcm9tX3RhYnMpCiAgICAgICAgc2VsZi5jX2FkZC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5hZGRfY291bnRlcikKICAgICAgICBzZWxmLmNfZGVsLmNs"
    "aWNrZWQuY29ubmVjdChzZWxmLmRlbF9jb3VudGVyKQogICAgICAgIHNlbGYuYl9wcmV2aWV3LmNsaWNrZWQuY29ubmVjdChzZWxmLnByZXZpZXcpCiAgICAg"
    "ICAgIyDsnoXroKUg6re466O5KO2DrSkg642U67iU7YG066atIOyLnCDri6jstpXtgqQg7ISk7KCVIO2MneyXhQogICAgICAgIHNlbGYudGFicy5pdGVtRG91"
    "YmxlQ2xpY2tlZC5jb25uZWN0KHNlbGYuX29uX2dyb3VwX3RhYl9kb3VibGVfY2xpY2tlZCkKICAgICAgICBzZWxmLmJfYWRkLmNsaWNrZWQuY29ubmVjdChz"
    "ZWxmLmFkZF9zaXRlKQogICAgICAgIHNlbGYuYl9kZWwuY2xpY2tlZC5jb25uZWN0KHNlbGYuZGVsX3NpdGUpCiAgICAgICAgc2VsZi5iX2FwcGx5X2luLmNs"
    "aWNrZWQuY29ubmVjdChzZWxmLmFwcGx5X3RvX3NlbGVjdGVkKQogICAgICAgIHNlbGYuYl90b3AuY2xpY2tlZC5jb25uZWN0KHNlbGYubW92ZV9zaXRlX3Rv"
    "cCkKICAgICAgICBzZWxmLmJfdXAuY2xpY2tlZC5jb25uZWN0KGxhbWJkYTogc2VsZi5tb3ZlX3NpdGUoLTEpKQogICAgICAgIHNlbGYuYl9kbi5jbGlja2Vk"
    "LmNvbm5lY3QobGFtYmRhOiBzZWxmLm1vdmVfc2l0ZSgxKSkKICAgICAgICAjIO2FnO2UjOumv+yXkOyEnCDsnoXroKXqt7jro7kv7Lm07Jq07YSwIOu2iOuf"
    "rOyYpOq4sAogICAgICAgIHNlbGYuYl90cGwuY2xpY2tlZC5jb25uZWN0KHNlbGYuYXBwbHlfdGVtcGxhdGVfZnJvbV92ZWhpY2xlKQogICAgICAgICMg67Cp"
    "7Zal7IiYL+q3uOujuS/subTsmrTthLAg7ISk7KCV7J20IOuwlOuAlCDrlYzrp4jri6Qg7KeA7KCQ7KCV67O07JeQIOymieyLnCDrsJjsmIEKICAgICAgICBz"
    "ZWxmLnNwaW4udmFsdWVDaGFuZ2VkLmNvbm5lY3QobGFtYmRhICpfOiBzZWxmLl9hcHBseV90b19jdXJyZW50X3JvdyhGYWxzZSkpCgogICAgIyAtLS0tLS0t"
    "LS0tIOuCtOu2gCDtl6ztjbwgLS0tLS0tLS0tLQogICAgZGVmIF9yb3dfa2V5KHNlbGYsIHJvdz1Ob25lKToKICAgICAgICBpZiByb3cgaXMgTm9uZToKICAg"
    "ICAgICAgICAgcm93ID0gc2VsZi50YmwuY3VycmVudFJvdygpCiAgICAgICAgcmV0dXJuIHN0cihyb3cpCgogICAgZGVmIF9hcHBseV9zdGF0ZV9jb2xvcihz"
    "ZWxmLCBpdGVtKToKICAgICAgICAiIiLsp4DsoJDsoJXrs7Qg7IOB7YOcIOyFgCDsg4nsg4Eg7KeA7KCVOiDrjIDquLA96rKA7KCVLCDsp4Ttlok97YyM656R"
    "LCDsmYTro4w97Jew7ZqM7IOJIiIiCiAgICAgICAgaWYgbm90IGl0ZW06CiAgICAgICAgICAgIHJldHVybgogICAgICAgIHR4dCA9IGl0ZW0udGV4dCgpLnN0"
    "cmlwKCkKICAgICAgICBjb2xvcl9tYXAgPSB7CiAgICAgICAgICAgICLrjIDquLAiOiBRdEd1aS5RQ29sb3IoImJsYWNrIiksCiAgICAgICAgICAgICLsp4Tt"
    "lokiOiBRdEd1aS5RQ29sb3IoImJsdWUiKSwKICAgICAgICAgICAgIuyZhOujjCI6IFF0R3VpLlFDb2xvcigibGlnaHRncmF5IiksCiAgICAgICAgfQogICAg"
    "ICAgIGl0ZW0uc2V0Rm9yZWdyb3VuZChjb2xvcl9tYXAuZ2V0KHR4dCwgUXRHdWkuUUNvbG9yKCJibGFjayIpKSkKCgogICAgZGVmIF9uZXh0X2pvYl9ubyhz"
    "ZWxmKToKICAgICAgICAiIiIKICAgICAgICDsnpHsl4XrsojtmLjrpbwgJ1dOX1lZTU1ERGhobW1zc2ZmJyDtmJXsi53snLzroZwg7IOd7ISxLgogICAgICAg"
    "IOyYiDogMjAyNeuFhCAxMuyblCA07J28IDE07IucIDA067aEIDMw7LSIIDEzID0gV05fMjUxMjA0MTQwNDMwMTMKICAgICAgICAiIiIKICAgICAgICBub3cg"
    "PSBkdC5kYXRldGltZS5ub3coKQogICAgICAgICMg66eI7J207YGs66Gc7LSI66W8IDEvMTAwIOuLqOychCjrkZAg7J6Q66as7IiYKeuhnCDrs4DtmZgKICAg"
    "ICAgICBtczIgPSBpbnQobm93Lm1pY3Jvc2Vjb25kIC8gMTAwMDApICAjIDB+OTkKICAgICAgICByZXR1cm4gIldOXyIgKyBub3cuc3RyZnRpbWUoIiV5JW0l"
    "ZCVIJU0lUyIpICsgZiJ7bXMyOjAyZH0iCgogICAgZGVmIF9jb2xsZWN0X3VpKHNlbGYpOgoKICAgICAgICAjIO2YhOyerCBVSeyXkOyEnCDqt7jro7kv7Lm0"
    "7Jq07YSwL+uwqe2WpSDrpqzsiqTtirgv67Cp7Zal7IiY6rmM7KeAIOuqqOuRkCDsiJjsp5EKICAgICAgICBncm91cHMgPSBbc2VsZi50YWJzLml0ZW0oaSku"
    "dGV4dCgpIGZvciBpIGluIHJhbmdlKHNlbGYudGFicy5jb3VudCgpKV0KICAgICAgICBjb3VudGVycyA9IFtdCiAgICAgICAgZm9yIHIgaW4gcmFuZ2Uoc2Vs"
    "Zi5jdC5yb3dDb3VudCgpKToKICAgICAgICAgICAgZGVmIF90ZXh0KGNvbCk6CiAgICAgICAgICAgICAgICBpdGVtID0gc2VsZi5jdC5pdGVtKHIsIGNvbCkK"
    "ICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnRleHQoKS5zdHJpcCgpIGlmIGl0ZW0gZWxzZSAiIgogICAgICAgICAgICBjb3VudGVycy5hcHBlbmQoewog"
    "ICAgICAgICAgICAgICAgIm5hbWUiOiBfdGV4dCgwKSwKICAgICAgICAgICAgICAgICJkaXIiOiBfdGV4dCgxKSwKICAgICAgICAgICAgICAgICJsYWJlbCI6"
    "IF90ZXh0KDIpLAogICAgICAgICAgICB9KQogICAgICAgIGRpcnMgPSBbc2VsZi5kaXIuaXRlbShpKS50ZXh0KCkgZm9yIGkgaW4gcmFuZ2Uoc2VsZi5kaXIu"
    "Y291bnQoKSldCgogICAgICAgICMg7J2066+4IOyggOyepeuQnCDsp4DsoJAg642w7J207YSw6rCAIOyeiOuLpOuptCwg6re4IOyViOydmCBncm91cF9wcm9q"
    "ZWN0cyjqt7jro7nrs4Qg7LCo7KKF7Jyg7ZiVIOyEoO2Dneqwkinrpbwg6re464yA66GcIOqwgOyguOyYqOuLpC4KICAgICAgICB0cnk6CiAgICAgICAgICAg"
    "IHJvd19rZXkgPSBzZWxmLl9yb3dfa2V5KCkKICAgICAgICAgICAgcHJldiA9IHNlbGYuc2l0ZV9kYXRhLmdldChyb3dfa2V5LCB7fSkgaWYgaGFzYXR0cihz"
    "ZWxmLCAic2l0ZV9kYXRhIikgZWxzZSB7fQogICAgICAgICAgICBncm91cF9wcm9qZWN0cyA9IHByZXYuZ2V0KCJncm91cF9wcm9qZWN0cyIsIHt9KSBvciB7"
    "fQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIGdyb3VwX3Byb2plY3RzID0ge30KCiAgICAgICAgY2ZnID0geyJncm91cHMiOiBncm91"
    "cHMsICJjb3VudGVycyI6IGNvdW50ZXJzLCAiZGlycyI6IGRpcnMsICJzcGluIjogc2VsZi5zcGluLnZhbHVlKCl9CiAgICAgICAgaWYgZ3JvdXBfcHJvamVj"
    "dHM6CiAgICAgICAgICAgIGNmZ1siZ3JvdXBfcHJvamVjdHMiXSA9IGdyb3VwX3Byb2plY3RzCiAgICAgICAgcmV0dXJuIGNmZwoKCgogICAgIyAtLS0tLS0t"
    "LS0tIOy5tOyatO2EsCAvIOuLqOy2le2CpCDsl7Drj5kgLS0tLS0tLS0tLQogICAgZGVmIF9jdXJyZW50X3Byb2plY3Qoc2VsZik6CiAgICAgICAgIiIi7KGw"
    "7IKs7LCo7KKFIOyEpOyglSDtg63sl5DshJwg7ZiE7J6sIOyEoO2DneuQnCDssKjsooUg7Jyg7ZiVKFByb2plY3Qp7J2EIOuwmO2ZmC4iIiIKICAgICAgICB2"
    "ZWhfdGFiID0gZ2V0YXR0cihzZWxmLnBhZ2UsICJ2ZWgiLCBOb25lKQogICAgICAgIGlmIHZlaF90YWIgaXMgTm9uZToKICAgICAgICAgICAgcmV0dXJuIE5v"
    "bmUKICAgICAgICB0cnk6CiAgICAgICAgICAgIHByb2pfaW5kZXggPSB2ZWhfdGFiLmNiLmN1cnJlbnRJbmRleCgpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlv"
    "bjoKICAgICAgICAgICAgcmV0dXJuIE5vbmUKICAgICAgICBwcm9qZWN0cyA9IChzZWxmLnBhZ2UuZGF0YSBvciB7fSkuZ2V0KCJwcm9qZWN0cyIsIFtdKQog"
    "ICAgICAgIGlmIDAgPD0gcHJval9pbmRleCA8IGxlbihwcm9qZWN0cyk6CiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0c1twcm9qX2luZGV4XQogICAgICAg"
    "IHJldHVybiBOb25lCgogICAgZGVmIF9ob3RrZXlfc2hlZXRzKHNlbGYpOgogICAgICAgICIiIu2YhOyerCDtlITroZzsoJ3tirjsnZgg7Lm07Jq07YSwIOuL"
    "qOy2le2CpCDsi5ztirgg66qp66Gd7J2EIOuwmO2ZmC4iIiIKICAgICAgICBwcm9qID0gc2VsZi5fY3VycmVudF9wcm9qZWN0KCkKICAgICAgICBpZiBwcm9q"
    "IGlzIE5vbmU6CiAgICAgICAgICAgIHJldHVybiBbXQogICAgICAgIHJldHVybiBwcm9qLmdldCgiaG90a2V5X3NoZWV0c19nbG9iYWwiLCBbXSkgb3IgW10K"
    "CiAgICAKICAgIGRlZiBfb25fZ3JvdXBfdGFiX2RvdWJsZV9jbGlja2VkKHNlbGYsIGl0ZW0pOgogICAgICAgICIiIuyeheugpeq3uOujuSjtg60pIOuNlOu4"
    "lO2BtOumrSDsi5wsIO2VtOuLuSDqt7jro7nsl5Ag7Y+s7ZWo65CcIOuwqe2WpeuTpOydmCDri6jstpXtgqQg7Iuc7Yq466W8IOydvOq0hCDshKTsoJUuIiIi"
    "CiAgICAgICAgaWYgaXRlbSBpcyBOb25lOgogICAgICAgICAgICByZXR1cm4KCiAgICAgICAgbGFiZWwgPSBpdGVtLnRleHQoKSBvciAiIgogICAgICAgIGlt"
    "cG9ydCByZSBhcyBfcmUKICAgICAgICBkaXJzID0gW10KICAgICAgICBmb3IgcGFydCBpbiBfcmUuc3BsaXQociJbXjAtOV0rIiwgbGFiZWwpOgogICAgICAg"
    "ICAgICBpZiBwYXJ0LmlzZGlnaXQoKToKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBkaXJzLmFwcGVuZChpbnQocGFydCkpCiAg"
    "ICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICBkaXJzID0gc29ydGVkKHNldChkaXJzKSkK"
    "ICAgICAgICBpZiBub3QgZGlyczoKICAgICAgICAgICAgUXRXaWRnZXRzLlFNZXNzYWdlQm94LmluZm9ybWF0aW9uKHNlbGYsICLslYzrprwiLCAi7J20IO2D"
    "reyXkOyEnCDrsKntlqXrsojtmLjrpbwg7LC+7J2EIOyImCDsl4bsirXri4jri6QuIikKICAgICAgICAgICAgcmV0dXJuCgogICAgICAgIGRhdGEgPSBnZXRh"
    "dHRyKHNlbGYucGFnZSwgImRhdGEiLCBOb25lKSBvciB7fQogICAgICAgIHByb2plY3RzID0gZGF0YS5nZXQoInByb2plY3RzIiwgW10pCiAgICAgICAgaWYg"
    "bm90IHByb2plY3RzOgogICAgICAgICAgICBRdFdpZGdldHMuUU1lc3NhZ2VCb3guaW5mb3JtYXRpb24oc2VsZiwgIuyVjOumvCIsICLrqLzsoIAg7LCo7KKF"
    "6rSA66as7JeQ7IScIOywqOyiheycoO2YleqzvCDsubTsmrTthLAg64uo7LaV7YKk66W8IOyEpOygle2VmOyEuOyalC4iKQogICAgICAgICAgICByZXR1cm4K"
    "CiAgICAgICAgIyDquLDrs7gg7ZSE66Gc7KCd7Yq4IOyduOuNseyKpDoKICAgICAgICAjIDHsiJzsnIQ6IO2YhOyerCDsp4DsoJAoc2l0ZV9kYXRhKeyXkCDs"
    "oIDsnqXrkJwg6re466O567OEIOywqOyiheycoO2YlSDshKDtg53qsJIKICAgICAgICAjIDLsiJzsnIQ6IOyhsOyCrOywqOyihSDtg63snZgg7ZiE7J6sIOyE"
    "oO2DneqwkgogICAgICAgICAgICAgICAgIyDquLDrs7gg7ZSE66Gc7KCd7Yq4IOyduOuNseyKpDoKICAgICAgICAjIDHsiJzsnIQ6IO2YhOyerCDsp4DsoJAo"
    "c2l0ZV9kYXRhKeyXkCDsoIDsnqXrkJwg6re466O567OEIOywqOyiheycoO2YlSDshKDtg53qsJIKICAgICAgICAjIDLsiJzsnIQ6IOydtOuvuCDsnbQg6re4"
    "66O57J2YIOuwqe2WpeuTpOyXkCDsl7DqsrDrkJwg7Iuc7Yq4IOydtOumhOyXkOyEnCDstpTsoJUKICAgICAgICAjIDPsiJzsnIQ6IOyhsOyCrOywqOyihSDt"
    "g63snZgg7ZiE7J6sIOyEoO2DneqwkgogICAgICAgIHByb2pfaW5kZXggPSBOb25lCiAgICAgICAgdHJ5OgogICAgICAgICAgICByb3dfa2V5ID0gc2VsZi5f"
    "cm93X2tleSgpCiAgICAgICAgICAgIGNmZ19leGlzdGluZyA9IHNlbGYuc2l0ZV9kYXRhLmdldChyb3dfa2V5LCB7fSkgb3Ige30KICAgICAgICAgICAgZ3Jv"
    "dXBfcHJvamVjdHMgPSBjZmdfZXhpc3RpbmcuZ2V0KCJncm91cF9wcm9qZWN0cyIsIHt9KSBvciB7fQogICAgICAgICAgICBpZiBsYWJlbCBpbiBncm91cF9w"
    "cm9qZWN0czoKICAgICAgICAgICAgICAgIHNhdmVkX2lkeCA9IGludChncm91cF9wcm9qZWN0cy5nZXQobGFiZWwsIDApKQogICAgICAgICAgICAgICAgaWYg"
    "MCA8PSBzYXZlZF9pZHggPCBsZW4ocHJvamVjdHMpOgogICAgICAgICAgICAgICAgICAgIHByb2pfaW5kZXggPSBzYXZlZF9pZHgKICAgICAgICBleGNlcHQg"
    "RXhjZXB0aW9uOgogICAgICAgICAgICBwcm9qX2luZGV4ID0gTm9uZQoKICAgICAgICAjIOyggOyepeuQnCBncm91cF9wcm9qZWN0cyDsl5Ag6rCS7J20IOyX"
    "huycvOuptCwg7ZiE7J6sIOy5tOyatO2EsCDthYzsnbTruJTsl5Ag7ISk7KCV65CcIOyLnO2KuCDsnbTrpoTsnYQg7J207Jqp7ZW0IOy2lOyglQogICAgICAg"
    "IGlmIHByb2pfaW5kZXggaXMgTm9uZToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgIyDsnbQg6re466O5KGxhYmVsKeyXkCDtj6ztlajrkJwg"
    "67Cp7Zal65OkIOykkSwg7J2066+4IOyLnO2KuOqwgCDsp4DsoJXrkJwg67Cp7Zal7J2EIOywvuuKlOuLpC4KICAgICAgICAgICAgICAgIGV4aXN0aW5nX3No"
    "ZWV0ID0gTm9uZQogICAgICAgICAgICAgICAgZm9yIHJvdyBpbiByYW5nZShzZWxmLmN0LnJvd0NvdW50KCkpOgogICAgICAgICAgICAgICAgICAgIGRfaXRl"
    "bSA9IHNlbGYuY3QuaXRlbShyb3csIDEpCiAgICAgICAgICAgICAgICAgICAgbl9pdGVtID0gc2VsZi5jdC5pdGVtKHJvdywgMCkKICAgICAgICAgICAgICAg"
    "ICAgICBpZiBub3QgZF9pdGVtIG9yIG5vdCBuX2l0ZW06CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICAgICAgdHJ5"
    "OgogICAgICAgICAgICAgICAgICAgICAgICBkX3ZhbCA9IGludChkX2l0ZW0udGV4dCgpLnN0cmlwKCkpCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4"
    "Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgICAgICBpZiBkX3ZhbCBub3QgaW4gZGlyczoKICAgICAg"
    "ICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgICAgICBzaGVldF9uYW1lID0gbl9pdGVtLnRleHQoKS5zdHJpcCgpCiAgICAgICAg"
    "ICAgICAgICAgICAgaWYgbm90IHNoZWV0X25hbWU6CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICAgICAgZXhpc3Rp"
    "bmdfc2hlZXQgPSBzaGVldF9uYW1lCiAgICAgICAgICAgICAgICAgICAgYnJlYWsKCiAgICAgICAgICAgICAgICAjIOywvuydgCDsi5ztirgg7J2066aE7J20"
    "IOyeiOycvOuptCwg6re4IOyLnO2KuOulvCDtj6ztlajtlZjqs6Ag7J6I64qUIO2UhOuhnOygne2KuCDsnbjrjbHsiqTrpbwg7LC+64qU64ukLgogICAgICAg"
    "ICAgICAgICAgaWYgZXhpc3Rpbmdfc2hlZXQgYW5kIHByb2plY3RzOgogICAgICAgICAgICAgICAgICAgIGZvciBpZHgsIHByb2ogaW4gZW51bWVyYXRlKHBy"
    "b2plY3RzKToKICAgICAgICAgICAgICAgICAgICAgICAgc2hlZXRzX2xvY2FsID0gcHJvai5nZXQoImhvdGtleV9zaGVldHNfZ2xvYmFsIiwgW10pIG9yIFtd"
    "CiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBzIGluIHNoZWV0c19sb2NhbDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHN0cihzLmdldCgi"
    "bmFtZSIsICIiKSBvciAiIikuc3RyaXAoKSA9PSBleGlzdGluZ19zaGVldDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9qX2luZGV4ID0g"
    "aWR4CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgcHJval9pbmRleCBpcyBub3QgTm9u"
    "ZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICBwcm9qX2lu"
    "ZGV4ID0gTm9uZQoKICAgICAgICAjIOq3uOuemOuPhCBwcm9qX2luZGV4IOulvCDssL7sp4Ag66q77ZWY66m0IOyhsOyCrOywqOyihSDtg63snZgg7ZiE7J6s"
    "IOyEoO2DneqwkiDsgqzsmqkKICAgICAgICBpZiBwcm9qX2luZGV4IGlzIE5vbmU6CiAgICAgICAgICAgIHZlaF90YWIgPSBnZXRhdHRyKHNlbGYucGFnZSwg"
    "InZlaCIsIE5vbmUpCiAgICAgICAgICAgIGlmIHZlaF90YWIgaXMgbm90IE5vbmU6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAg"
    "aWR4ID0gdmVoX3RhYi5jYi5jdXJyZW50SW5kZXgoKQogICAgICAgICAgICAgICAgICAgIGlmIDAgPD0gaWR4IDwgbGVuKHByb2plY3RzKToKICAgICAgICAg"
    "ICAgICAgICAgICAgICAgcHJval9pbmRleCA9IGlkeAogICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICBwcm9q"
    "X2luZGV4ID0gMAoKICAgICAgICBpZiBwcm9qX2luZGV4IGlzIE5vbmU6CiAgICAgICAgICAgIHByb2pfaW5kZXggPSAwCiAgICAgICAgaWYgcHJval9pbmRl"
    "eCA9PSAwOgogICAgICAgICAgICB2ZWhfdGFiID0gZ2V0YXR0cihzZWxmLnBhZ2UsICJ2ZWgiLCBOb25lKQogICAgICAgICAgICBpZiB2ZWhfdGFiIGlzIG5v"
    "dCBOb25lOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIGlkeCA9IHZlaF90YWIuY2IuY3VycmVudEluZGV4KCkKICAgICAgICAg"
    "ICAgICAgICAgICBpZiAwIDw9IGlkeCA8IGxlbihwcm9qZWN0cyk6CiAgICAgICAgICAgICAgICAgICAgICAgIHByb2pfaW5kZXggPSBpZHgKICAgICAgICAg"
    "ICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgcGFzcwoKICAgICAgICBkbGcgPSBRdFdpZGdldHMuUURpYWxvZyhzZWxmKQog"
    "ICAgICAgIGRsZy5zZXRXaW5kb3dUaXRsZSgi7J6F66Cl6re466O5IOuLqOy2le2CpCDshKTsoJUgKOyngOygkOuzhCkiKQogICAgICAgIHZib3ggPSBRdFdp"
    "ZGdldHMuUVZCb3hMYXlvdXQoZGxnKQoKICAgICAgICAjIOywqOyiheycoO2YlSDsvaTrs7TrsJXsiqQKICAgICAgICBmb3JtX3RvcCA9IFF0V2lkZ2V0cy5R"
    "Rm9ybUxheW91dCgpCiAgICAgICAgY2JfcHJvaiA9IFF0V2lkZ2V0cy5RQ29tYm9Cb3goZGxnKQogICAgICAgIGZvciBwIGluIHByb2plY3RzOgogICAgICAg"
    "ICAgICBjYl9wcm9qLmFkZEl0ZW0ocC5nZXQoIm5hbWUiLCAiIikgb3IgIijsnbTrpoQg7JeG7J2MKSIpCiAgICAgICAgY2JfcHJvai5zZXRDdXJyZW50SW5k"
    "ZXgocHJval9pbmRleCkKICAgICAgICBmb3JtX3RvcC5hZGRSb3coIuywqOyiheycoO2YlToiLCBjYl9wcm9qKQogICAgICAgIHZib3guYWRkTGF5b3V0KGZv"
    "cm1fdG9wKQoKICAgICAgICAjIO2YhOyerCDsubTsmrTthLAg7YWM7J2067iU7JeQ7IScIOuwqe2WpeuzhOuhnCDsnbTrr7gg7KeA7KCV65CcIOyLnO2KuCDs"
    "nbTrpoTsnYQg7IiY7KeRCiAgICAgICAgY3VycmVudF9ieV9kaXIgPSB7fQogICAgICAgIGZvciByb3cgaW4gcmFuZ2Uoc2VsZi5jdC5yb3dDb3VudCgpKToK"
    "ICAgICAgICAgICAgZF9pdGVtID0gc2VsZi5jdC5pdGVtKHJvdywgMSkKICAgICAgICAgICAgbl9pdGVtID0gc2VsZi5jdC5pdGVtKHJvdywgMCkKICAgICAg"
    "ICAgICAgaWYgbm90IGRfaXRlbToKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIGRfdGV4dCA9IGRfaXRlbS50ZXh0KCkuc3RyaXAoKQog"
    "ICAgICAgICAgICBpZiBub3QgZF90ZXh0OgogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgaWYgbl9pdGVtOgogICAgICAgICAgICAgICAg"
    "Y3VycmVudF9ieV9kaXIuc2V0ZGVmYXVsdChkX3RleHQsIG5faXRlbS50ZXh0KCkuc3RyaXAoKSkKCiAgICAgICAgIyDrsKntlqXrs4Qg7L2k67O067CV7Iqk"
    "CiAgICAgICAgZGlyX2xheW91dCA9IFF0V2lkZ2V0cy5RRm9ybUxheW91dCgpCiAgICAgICAgZGlyX2NvbWJvcyA9IHt9CgogICAgICAgIGRlZiBfc2hlZXRf"
    "bmFtZXNfZm9yX3Byb2plY3QocF9pbmRleCk6CiAgICAgICAgICAgIGlmIG5vdCAoMCA8PSBwX2luZGV4IDwgbGVuKHByb2plY3RzKSk6CiAgICAgICAgICAg"
    "ICAgICByZXR1cm4gW10KICAgICAgICAgICAgc2hlZXRzID0gcHJvamVjdHNbcF9pbmRleF0uZ2V0KCJob3RrZXlfc2hlZXRzX2dsb2JhbCIsIFtdKSBvciBb"
    "XQogICAgICAgICAgICByZXR1cm4gW3N0cihzLmdldCgibmFtZSIsICIiKSBvciAiIikgZm9yIHMgaW4gc2hlZXRzXQoKICAgICAgICBkZWYgX3JlbG9hZF9k"
    "aXJfY29tYm9zKCk6CiAgICAgICAgICAgIG5hbWVzID0gX3NoZWV0X25hbWVzX2Zvcl9wcm9qZWN0KGNiX3Byb2ouY3VycmVudEluZGV4KCkpCiAgICAgICAg"
    "ICAgIGZvciBkLCBjb21ibyBpbiBkaXJfY29tYm9zLml0ZW1zKCk6CiAgICAgICAgICAgICAgICBwcmV2ID0gY29tYm8uY3VycmVudFRleHQoKS5zdHJpcCgp"
    "CiAgICAgICAgICAgICAgICBjb21iby5ibG9ja1NpZ25hbHMoVHJ1ZSkKICAgICAgICAgICAgICAgIGNvbWJvLmNsZWFyKCkKICAgICAgICAgICAgICAgIGNv"
    "bWJvLmFkZEl0ZW0oIiIpICAjIOu5hOybgCDshKDtg50KICAgICAgICAgICAgICAgIGZvciBuIGluIG5hbWVzOgogICAgICAgICAgICAgICAgICAgIGNvbWJv"
    "LmFkZEl0ZW0obikKICAgICAgICAgICAgICAgICMg6riw67O4IOyEoO2DnTog6riw7KG07JeQIOyggOyepeuQnCDqsJLsnbQg7J6I7Jy866m0IOyasOyEoAog"
    "ICAgICAgICAgICAgICAga2V5ID0gc3RyKGQpCiAgICAgICAgICAgICAgICBiYXNlID0gY3VycmVudF9ieV9kaXIuZ2V0KGtleSwgIiIpCiAgICAgICAgICAg"
    "ICAgICB0YXJnZXQgPSBiYXNlIG9yIHByZXYKICAgICAgICAgICAgICAgIGlmIHRhcmdldCBhbmQgdGFyZ2V0IGluIG5hbWVzOgogICAgICAgICAgICAgICAg"
    "ICAgIGNvbWJvLnNldEN1cnJlbnRJbmRleChuYW1lcy5pbmRleCh0YXJnZXQpICsgMSkKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAg"
    "ICAgY29tYm8uc2V0Q3VycmVudEluZGV4KDApCiAgICAgICAgICAgICAgICBjb21iby5ibG9ja1NpZ25hbHMoRmFsc2UpCgogICAgICAgIGRlZiBfcmVmcmVz"
    "aF9wcmV2aWV3X2FsbCgpOgogICAgICAgICAgICAjIOuvuOumrOuztOq4sCDroIjsnbTslYTsm4Mg7LSI6riw7ZmUCiAgICAgICAgICAgIHdoaWxlIHByZXZp"
    "ZXdfbGF5b3V0LmNvdW50KCk6CiAgICAgICAgICAgICAgICBpdGVtID0gcHJldmlld19sYXlvdXQudGFrZUF0KDApCiAgICAgICAgICAgICAgICB3ID0gaXRl"
    "bS53aWRnZXQoKQogICAgICAgICAgICAgICAgaWYgdyBpcyBub3QgTm9uZToKICAgICAgICAgICAgICAgICAgICB3LmRlbGV0ZUxhdGVyKCkKCiAgICAgICAg"
    "ICAgICMg7ZiE7J6sIOyEoO2DneuQnCDtlITroZzsoJ3tirjsnZgg7Iuc7Yq4IOuqqeuhnQogICAgICAgICAgICBwX2luZGV4ID0gY2JfcHJvai5jdXJyZW50"
    "SW5kZXgoKQogICAgICAgICAgICBpZiBub3QgKDAgPD0gcF9pbmRleCA8IGxlbihwcm9qZWN0cykpOgogICAgICAgICAgICAgICAgc2hlZXRzID0gW10KICAg"
    "ICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHNoZWV0cyA9IHByb2plY3RzW3BfaW5kZXhdLmdldCgiaG90a2V5X3NoZWV0c19nbG9iYWwiLCBbXSkg"
    "b3IgW10KCiAgICAgICAgICAgICMg6rCBIOuwqe2WpeuzhOuhnCDqt7jro7nrsJXsiqTrpbwg7LaU6rCACiAgICAgICAgICAgIGZvciBkIGluIGRpcnM6CiAg"
    "ICAgICAgICAgICAgICBjb21ibyA9IGRpcl9jb21ib3MuZ2V0KGQpCiAgICAgICAgICAgICAgICBncm91cF9ib3ggPSBRdFdpZGdldHMuUUdyb3VwQm94KGYi"
    "e2R967KIIOuwqe2WpSIpCiAgICAgICAgICAgICAgICBnYl9sYXlvdXQgPSBRdFdpZGdldHMuUVZCb3hMYXlvdXQoZ3JvdXBfYm94KQogICAgICAgICAgICAg"
    "ICAgZ2JfbGF5b3V0LnNldENvbnRlbnRzTWFyZ2lucyg0LCA0LCA0LCA0KQogICAgICAgICAgICAgICAgZ2JfbGF5b3V0LnNldFNwYWNpbmcoMikKCiAgICAg"
    "ICAgICAgICAgICBpZiBjb21ibyBpcyBOb25lOgogICAgICAgICAgICAgICAgICAgIGdiX2xheW91dC5hZGRXaWRnZXQoUXRXaWRnZXRzLlFMYWJlbCgi67Cp"
    "7ZalIOy9pOuztOuwleyKpOulvCDssL7snYQg7IiYIOyXhuyKteuLiOuLpC4iKSkKICAgICAgICAgICAgICAgICAgICBwcmV2aWV3X2xheW91dC5hZGRXaWRn"
    "ZXQoZ3JvdXBfYm94KQogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCgogICAgICAgICAgICAgICAgc2hlZXRfbmFtZSA9IGNvbWJvLmN1cnJlbnRUZXh0"
    "KCkuc3RyaXAoKQogICAgICAgICAgICAgICAgaWYgbm90IHNoZWV0X25hbWU6CiAgICAgICAgICAgICAgICAgICAgZ2JfbGF5b3V0LmFkZFdpZGdldChRdFdp"
    "ZGdldHMuUUxhYmVsKCLshKDtg53rkJwg64uo7LaV7YKkIOyLnO2KuOqwgCDsl4bsirXri4jri6QuIikpCiAgICAgICAgICAgICAgICAgICAgcHJldmlld19s"
    "YXlvdXQuYWRkV2lkZ2V0KGdyb3VwX2JveCkKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQoKICAgICAgICAgICAgICAgIHRhcmdldCA9IE5vbmUKICAg"
    "ICAgICAgICAgICAgIGZvciBzIGluIHNoZWV0czoKICAgICAgICAgICAgICAgICAgICBpZiBzdHIocy5nZXQoIm5hbWUiLCAiIikgb3IgIiIpID09IHNoZWV0"
    "X25hbWU6CiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHMKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsKCiAgICAgICAgICAgICAgICBp"
    "ZiB0YXJnZXQgaXMgTm9uZToKICAgICAgICAgICAgICAgICAgICBnYl9sYXlvdXQuYWRkV2lkZ2V0KFF0V2lkZ2V0cy5RTGFiZWwoZiIne3NoZWV0X25hbWV9"
    "JyDsi5ztirjrpbwg7LC+7J2EIOyImCDsl4bsirXri4jri6QuIikpCiAgICAgICAgICAgICAgICAgICAgcHJldmlld19sYXlvdXQuYWRkV2lkZ2V0KGdyb3Vw"
    "X2JveCkKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQoKICAgICAgICAgICAgICAgIGl0ZW1zID0gdGFyZ2V0LmdldCgiaXRlbXMiLCBbXSkgb3IgW10K"
    "ICAgICAgICAgICAgICAgIGlmIG5vdCBpdGVtczoKICAgICAgICAgICAgICAgICAgICBnYl9sYXlvdXQuYWRkV2lkZ2V0KFF0V2lkZ2V0cy5RTGFiZWwoIuuT"
    "seuhneuQnCDri6jstpXtgqTqsIAg7JeG7Iq164uI64ukLiIpKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBmb3IgcmVjIGlu"
    "IGl0ZW1zOgogICAgICAgICAgICAgICAgICAgICAgICBsYWJlbF90eHQgPSBzdHIocmVjLmdldCgi7LCo7KKF66qFIiwgIiIpKQogICAgICAgICAgICAgICAg"
    "ICAgICAgICBrZXlfdHh0ID0gc3RyKHJlYy5nZXQoIuuLqOy2le2CpCIsICIiKSkKICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gUXRXaWRnZXRzLlFI"
    "Qm94TGF5b3V0KCkKICAgICAgICAgICAgICAgICAgICAgICAgbGFiID0gUXRXaWRnZXRzLlFMYWJlbChmIntsYWJlbF90eHR9IO2CpCIpCiAgICAgICAgICAg"
    "ICAgICAgICAgICAgIGVkaXQgPSBRdFdpZGdldHMuUUxpbmVFZGl0KGtleV90eHQpCiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXQuc2V0UmVhZE9ubHko"
    "VHJ1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgZWRpdC5zZXRNYXhpbXVtV2lkdGgoODApCiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5hZGRXaWRn"
    "ZXQobGFiKQogICAgICAgICAgICAgICAgICAgICAgICByb3cuYWRkV2lkZ2V0KGVkaXQpCiAgICAgICAgICAgICAgICAgICAgICAgIGdiX2xheW91dC5hZGRM"
    "YXlvdXQocm93KQoKICAgICAgICAgICAgICAgIHByZXZpZXdfbGF5b3V0LmFkZFdpZGdldChncm91cF9ib3gpCgogICAgICAgIGRlZiBfb25fZGlyX2NvbWJv"
    "X2NoYW5nZWQoX2luZGV4LCBkKToKICAgICAgICAgICAgIyDsvaTrs7TrsJXsiqQg67OA6rK9IOyLnCDsoITssrQg67Cp7ZalIOuvuOumrOuztOq4sOulvCDr"
    "i6Tsi5wg6re466aw64ukLgogICAgICAgICAgICBfcmVmcmVzaF9wcmV2aWV3X2FsbCgpCiAgICAgICAgZm9yIGQgaW4gZGlyczoKICAgICAgICAgICAgY29t"
    "Ym8gPSBRdFdpZGdldHMuUUNvbWJvQm94KGRsZykKICAgICAgICAgICAgZGlyX2NvbWJvc1tkXSA9IGNvbWJvCiAgICAgICAgICAgIGRpcl9sYXlvdXQuYWRk"
    "Um93KGYie2R967KIIOuwqe2WpSIsIGNvbWJvKQogICAgICAgICAgICBjb21iby5jdXJyZW50SW5kZXhDaGFuZ2VkLmNvbm5lY3QobGFtYmRhIGlkeCwgZGQ9"
    "ZDogX29uX2Rpcl9jb21ib19jaGFuZ2VkKGlkeCwgZGQpKQoKICAgICAgICB2Ym94LmFkZExheW91dChkaXJfbGF5b3V0KQoKICAgICAgICAjIOuvuOumrOuz"
    "tOq4sCDsmIHsl60KICAgICAgICAjIOq3uOujueuwleyKpOulvCDsk7DrqbQg7KCc66qp6rO8IOuCtOyaqeydtCDqsrnss5Ag67O07J2064qUIOqyveyasOqw"
    "gCDsnojslrQsCiAgICAgICAgIyDsoJzrqqkg652867KoICsg7Iqk7YGs66GkIOyYgeyXrSDsobDtlansnLzroZwg6rWQ7LK07ZaI64ukLgogICAgICAgICMg"
    "66+466as67O06riwIOyYgeyXrTogUUdyb3VwQm94ICsgUVNjcm9sbEFyZWEg7KGw7ZWp7Jy866GcIOq1rOyEse2VmOyXrAogICAgICAgICMg7KCc66qp6rO8"
    "IOuCtOyaqeydtCDsnpDsl7DsiqTrn73qsowg67Cw7LmY65CY6rOgLCDtla3rqqnsnbQg66eO7J2EIOqyveyasCDsiqTtgazroaTroZwg7ZmV7J247ZWgIOyI"
    "mCDsnojrj4TroZ0g7ZWc64ukLgogICAgICAgIHByZXZpZXdfZ3JvdXAgPSBRdFdpZGdldHMuUUdyb3VwQm94KCLshKDtg53rkJwg64uo7LaV7YKkIOyLnO2K"
    "uCDrr7jrpqzrs7TquLAiKQogICAgICAgIHByZXZpZXdfZ3JvdXAuc2V0U3R5bGVTaGVldCgKICAgICAgICAgICAgIlFHcm91cEJveCB7IG1hcmdpbi10b3A6"
    "IDEycHg7IH0iCiAgICAgICAgICAgICJRR3JvdXBCb3g6OnRpdGxlIHsgc3ViY29udHJvbC1vcmlnaW46IG1hcmdpbjsgbGVmdDogOHB4OyB9IgogICAgICAg"
    "ICkKICAgICAgICBncm91cF9sYXlvdXQgPSBRdFdpZGdldHMuUVZCb3hMYXlvdXQocHJldmlld19ncm91cCkKICAgICAgICBncm91cF9sYXlvdXQuc2V0Q29u"
    "dGVudHNNYXJnaW5zKDQsIDQsIDQsIDQpCiAgICAgICAgZ3JvdXBfbGF5b3V0LnNldFNwYWNpbmcoMikKCiAgICAgICAgc2Nyb2xsID0gUXRXaWRnZXRzLlFT"
    "Y3JvbGxBcmVhKCkKICAgICAgICBzY3JvbGwuc2V0V2lkZ2V0UmVzaXphYmxlKFRydWUpCiAgICAgICAgcHJldmlld19jb250YWluZXIgPSBRdFdpZGdldHMu"
    "UVdpZGdldCgpCiAgICAgICAgcHJldmlld19sYXlvdXQgPSBRdFdpZGdldHMuUVZCb3hMYXlvdXQocHJldmlld19jb250YWluZXIpCiAgICAgICAgcHJldmll"
    "d19sYXlvdXQuc2V0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnblRvcCkKICAgICAgICBwcmV2aWV3X2xheW91dC5zZXRDb250ZW50c01hcmdpbnMoNCwgNCwg"
    "NCwgNCkKICAgICAgICBwcmV2aWV3X2xheW91dC5zZXRTcGFjaW5nKDIpCiAgICAgICAgc2Nyb2xsLnNldFdpZGdldChwcmV2aWV3X2NvbnRhaW5lcikKICAg"
    "ICAgICBncm91cF9sYXlvdXQuYWRkV2lkZ2V0KHNjcm9sbCkKCiAgICAgICAgdmJveC5hZGRXaWRnZXQocHJldmlld19ncm91cCkKCiAgICAgICAgY2JfcHJv"
    "ai5jdXJyZW50SW5kZXhDaGFuZ2VkLmNvbm5lY3QobGFtYmRhICpfOiAoX3JlbG9hZF9kaXJfY29tYm9zKCksIF9yZWZyZXNoX3ByZXZpZXdfYWxsKCkpKQoK"
    "ICAgICAgICAjIOy0iOq4sCDsvaTrs7TrsJXsiqQg7LGE7Jqw6riwCiAgICAgICAgX3JlbG9hZF9kaXJfY29tYm9zKCkKICAgICAgICAjIOuqqOuToCDrsKnt"
    "lqXsl5Ag64yA7ZWcIOuvuOumrOuztOq4sCDqsLHsi6AKICAgICAgICBfcmVmcmVzaF9wcmV2aWV3X2FsbCgpCgoKICAgICAgICAjIOuyhO2KvCDtlokKICAg"
    "ICAgICBidG5fcm93ID0gUXRXaWRnZXRzLlFIQm94TGF5b3V0KCkKICAgICAgICBidG5fcm93LmFkZFN0cmV0Y2goMSkKICAgICAgICBidG5fb2sgPSBRdFdp"
    "ZGdldHMuUVB1c2hCdXR0b24oIk9LIikKICAgICAgICBidG5fY2FuY2VsID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCJDYW5jZWwiKQogICAgICAgIGJ0bl9y"
    "b3cuYWRkV2lkZ2V0KGJ0bl9vaykKICAgICAgICBidG5fcm93LmFkZFdpZGdldChidG5fY2FuY2VsKQogICAgICAgIHZib3guYWRkTGF5b3V0KGJ0bl9yb3cp"
    "CgogICAgICAgIGRlZiBfb25fb2soKToKICAgICAgICAgICAgIyDshKDtg53rkJwg7Iuc7Yq466W8IOy5tOyatO2EsCDthYzsnbTruJTsl5Ag67CY7JiBCiAg"
    "ICAgICAgICAgIGZvciBkIGluIGRpcnM6CiAgICAgICAgICAgICAgICBzaGVldF9uYW1lID0gZGlyX2NvbWJvc1tkXS5jdXJyZW50VGV4dCgpLnN0cmlwKCkK"
    "ICAgICAgICAgICAgICAgIGlmIG5vdCBzaGVldF9uYW1lOgogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICBkaXJfc3RyID0g"
    "c3RyKGQpCiAgICAgICAgICAgICAgICBmb3VuZCA9IEZhbHNlCiAgICAgICAgICAgICAgICBmb3Igcm93IGluIHJhbmdlKHNlbGYuY3Qucm93Q291bnQoKSk6"
    "CiAgICAgICAgICAgICAgICAgICAgZF9pdGVtID0gc2VsZi5jdC5pdGVtKHJvdywgMSkKICAgICAgICAgICAgICAgICAgICBpZiBkX2l0ZW0gYW5kIGRfaXRl"
    "bS50ZXh0KCkuc3RyaXAoKSA9PSBkaXJfc3RyOgogICAgICAgICAgICAgICAgICAgICAgICBuYW1lX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRl"
    "bShzaGVldF9uYW1lKQogICAgICAgICAgICAgICAgICAgICAgICBuYW1lX2l0ZW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwg"
    "UXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgICAgICAgICAgICAgIyDsubTsmrTthLAg7J2066aEIOyXtOydgCDsgqzsmqnsnpAg7Y647KeR"
    "IOu2iOqwgAogICAgICAgICAgICAgICAgICAgICAgICBuYW1lX2l0ZW0uc2V0RmxhZ3MobmFtZV9pdGVtLmZsYWdzKCkgJiB+UXRDb3JlLlF0Lkl0ZW1Jc0Vk"
    "aXRhYmxlKQogICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN0LnNldEl0ZW0ocm93LCAwLCBuYW1lX2l0ZW0pCiAgICAgICAgICAgICAgICAgICAgICAg"
    "IGZvdW5kID0gVHJ1ZQogICAgICAgICAgICAgICAgIyDtlbTri7kg67Cp7Zal67KI7Zi47JeQIOuMgO2VnCDsubTsmrTthLAg7ZaJ7J20IOyXhuycvOuptCDs"
    "g4jroZwg7LaU6rCACiAgICAgICAgICAgICAgICBpZiBub3QgZm91bmQ6CiAgICAgICAgICAgICAgICAgICAgciA9IHNlbGYuY3Qucm93Q291bnQoKQogICAg"
    "ICAgICAgICAgICAgICAgIHNlbGYuY3QuaW5zZXJ0Um93KHIpCiAgICAgICAgICAgICAgICAgICAgbmFtZV9pdGVtID0gUXRXaWRnZXRzLlFUYWJsZVdpZGdl"
    "dEl0ZW0oc2hlZXRfbmFtZSkKICAgICAgICAgICAgICAgICAgICBuYW1lX2l0ZW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwg"
    "UXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgICAgICAgICBuYW1lX2l0ZW0uc2V0RmxhZ3MobmFtZV9pdGVtLmZsYWdzKCkgJiB+UXRDb3Jl"
    "LlF0Lkl0ZW1Jc0VkaXRhYmxlKQogICAgICAgICAgICAgICAgICAgIHNlbGYuY3Quc2V0SXRlbShyLCAwLCBuYW1lX2l0ZW0pCiAgICAgICAgICAgICAgICAg"
    "ICAgZGlyX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShkaXJfc3RyKQogICAgICAgICAgICAgICAgICAgIGRpcl9pdGVtLnNldFRleHRBbGln"
    "bm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlciB8IFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAgICAgICAgICAgICAgIyDrsKntlqUg7Je07J2A"
    "IOydveq4sCDsoITsmqkKICAgICAgICAgICAgICAgICAgICBkaXJfaXRlbS5zZXRGbGFncyhkaXJfaXRlbS5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNF"
    "ZGl0YWJsZSkKICAgICAgICAgICAgICAgICAgICBzZWxmLmN0LnNldEl0ZW0ociwgMSwgZGlyX2l0ZW0pCiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdC5z"
    "ZXRJdGVtKHIsIDIsIFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKCIiKSkKICAgICAgICAgICAgIyDtmITsnqwg7KeA7KCQIOyEpOygleydhCDsoIDsnqUK"
    "ICAgICAgICAgICAgc2VsZi5fYXBwbHlfdG9fY3VycmVudF9yb3coRmFsc2UpCiAgICAgICAgICAgICMg7J20IOyeheugpeq3uOujuSjtg60p7JeQIOyCrOya"
    "qeuQnCDssKjsooXsnKDtmJUo7ZSE66Gc7KCd7Yq4IOyduOuNseyKpCnsnYQg7ZWo6ruYIOyggOyepQogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAg"
    "ICByb3dfa2V5ID0gc2VsZi5fcm93X2tleSgpCiAgICAgICAgICAgICAgICBjZmdfc2F2ZWQgPSBzZWxmLnNpdGVfZGF0YS5nZXQocm93X2tleSwge30pIG9y"
    "IHt9CiAgICAgICAgICAgICAgICBncm91cF9wcm9qZWN0cyA9IGNmZ19zYXZlZC5nZXQoImdyb3VwX3Byb2plY3RzIiwge30pIG9yIHt9CiAgICAgICAgICAg"
    "ICAgICBncm91cF9wcm9qZWN0c1tsYWJlbF0gPSBjYl9wcm9qLmN1cnJlbnRJbmRleCgpCiAgICAgICAgICAgICAgICBjZmdfc2F2ZWRbImdyb3VwX3Byb2pl"
    "Y3RzIl0gPSBncm91cF9wcm9qZWN0cwogICAgICAgICAgICAgICAgc2VsZi5zaXRlX2RhdGFbcm93X2tleV0gPSBjZmdfc2F2ZWQKICAgICAgICAgICAgZXhj"
    "ZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgUXRXaWRnZXRzLlFNZXNzYWdlQm94LmluZm9ybWF0aW9uKHNlbGYsICLs"
    "mYTro4wiLCAi7J6F66Cl6re466O5IOuLqOy2le2CpCDshKTsoJXsnbQg7JmE66OM65CY7JeI7Iq164uI64ukLiIpCiAgICAgICAgICAgIGRsZy5hY2NlcHQo"
    "KQoKICAgICAgICBidG5fb2suY2xpY2tlZC5jb25uZWN0KF9vbl9vaykKICAgICAgICBidG5fY2FuY2VsLmNsaWNrZWQuY29ubmVjdChkbGcucmVqZWN0KQoK"
    "ICAgICAgICBkbGcuZXhlY18oKQoKICAgIGRlZiBfb25fY291bnRlcl9jZWxsX2RvdWJsZV9jbGlja2VkKHNlbGYsIHJvdywgY29sdW1uKToKICAgICAgICAi"
    "IiLsubTsmrTthLAg7Je07J2EIOuNlOu4lO2BtOumre2VmOuptCDtlbTri7kg7Lm07Jq07YSwIO2VreuqqeydmCDri6jstpXtgqQg6rWs7ISx7J2EIO2MneyX"
    "heycvOuhnCDrs7Tsl6zspIDri6QuIiIiCiAgICAgICAgIyDsubTsmrTthLAg7Je0KDDrsogp7J20IOyVhOuLjCDqsr3smrDripQg66y07IucCiAgICAgICAg"
    "aWYgY29sdW1uICE9IDA6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIG5hbWVfaXRlbSA9IHNlbGYuY3QuaXRlbShyb3csIDApCiAgICAgICAgZGlyX2l0"
    "ZW0gPSBzZWxmLmN0Lml0ZW0ocm93LCAxKQogICAgICAgIGlmIG5vdCBuYW1lX2l0ZW0gb3Igbm90IGRpcl9pdGVtOgogICAgICAgICAgICByZXR1cm4KICAg"
    "ICAgICBjb3VudGVyX25hbWUgPSBuYW1lX2l0ZW0udGV4dCgpLnN0cmlwKCkKICAgICAgICBkaXJfdGV4dCA9IGRpcl9pdGVtLnRleHQoKS5zdHJpcCgpIG9y"
    "ICI/IgoKICAgICAgICAjIOydtCDsp4DsoJAv67Cp7Zal7JeQIOuMgO2VtCDsi6TsoJzroZwg7IKs7Jqp7ZW07JW8IO2VoCDtlITroZzsoJ3tirgo7LCo7KKF"
    "7Jyg7ZiVKSDsnbjrjbHsiqTrpbwg6rOE7IKwCiAgICAgICAgZGF0YSA9IGdldGF0dHIoc2VsZi5wYWdlLCAiZGF0YSIsIHt9KSBpZiBoYXNhdHRyKHNlbGYu"
    "cGFnZSwgImRhdGEiKSBlbHNlIHt9CiAgICAgICAgcHJvamVjdHMgPSBkYXRhLmdldCgicHJvamVjdHMiLCBbXSkgaWYgaXNpbnN0YW5jZShkYXRhLCBkaWN0"
    "KSBlbHNlIFtdCgogICAgICAgIHByb2pfaW5kZXggPSBOb25lCiAgICAgICAgIyAx7Iic7JyEOiBzaXRlX2RhdGEg7JeQIOyggOyepeuQnCBncm91cF9wcm9q"
    "ZWN0cyDsl5DshJwg67Cp7Zal67OEIO2UhOuhnOygne2KuCDsnbjrjbHsiqQg7KGw7ZqMCiAgICAgICAgdHJ5OgogICAgICAgICAgICByb3dfa2V5ID0gc2Vs"
    "Zi5fcm93X2tleSgpCiAgICAgICAgICAgIGNmZyA9IHNlbGYuc2l0ZV9kYXRhLmdldChyb3dfa2V5LCB7fSkgb3Ige30KICAgICAgICAgICAgZ3JvdXBfcHJv"
    "amVjdHMgPSBjZmcuZ2V0KCJncm91cF9wcm9qZWN0cyIsIHt9KSBvciB7fQogICAgICAgICAgICBpbXBvcnQgcmUgYXMgX3JlCiAgICAgICAgICAgIHRyeToK"
    "ICAgICAgICAgICAgICAgIGRpcl92YWwgPSBpbnQoZGlyX3RleHQpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICBkaXJf"
    "dmFsID0gTm9uZQogICAgICAgICAgICBpZiBkaXJfdmFsIGlzIG5vdCBOb25lOgogICAgICAgICAgICAgICAgZm9yIGdycF9sYWJlbCwgcF9pZHggaW4gZ3Jv"
    "dXBfcHJvamVjdHMuaXRlbXMoKToKICAgICAgICAgICAgICAgICAgICBmb3IgcGFydCBpbiBfcmUuc3BsaXQociJbXjAtOV0rIiwgc3RyKGdycF9sYWJlbCkp"
    "OgogICAgICAgICAgICAgICAgICAgICAgICBpZiBub3QgcGFydC5pc2RpZ2l0KCk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAg"
    "ICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkX3ZhbCA9IGludChwYXJ0KQogICAgICAgICAgICAgICAgICAg"
    "ICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgICAgICAgICAgaWYgZF92"
    "YWwgPT0gZGlyX3ZhbDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9qX2luZGV4"
    "ID0gaW50KHBfaWR4KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg"
    "ICBwcm9qX2luZGV4ID0gTm9uZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgICAgICBpZiBwcm9qX2luZGV4IGlz"
    "IG5vdCBOb25lOgogICAgICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIHByb2pfaW5kZXgg"
    "PSBOb25lCgogICAgICAgICMgMuyInOychDog7KGw7IKs7LCo7KKFIO2DreydmCDtmITsnqwg7ISg7YOd6rCSIOyCrOyaqQogICAgICAgIGlmIHByb2pfaW5k"
    "ZXggaXMgTm9uZSBhbmQgcHJvamVjdHM6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHZlaF90YWIgPSBnZXRhdHRyKHNlbGYucGFnZSwgInZl"
    "aCIsIE5vbmUpCiAgICAgICAgICAgICAgICBpZiB2ZWhfdGFiIGlzIG5vdCBOb25lIGFuZCBoYXNhdHRyKHZlaF90YWIsICJjYiIpOgogICAgICAgICAgICAg"
    "ICAgICAgIGlkeCA9IHZlaF90YWIuY2IuY3VycmVudEluZGV4KCkKICAgICAgICAgICAgICAgICAgICBpZiAwIDw9IGlkeCA8IGxlbihwcm9qZWN0cyk6CiAg"
    "ICAgICAgICAgICAgICAgICAgICAgIHByb2pfaW5kZXggPSBpZHgKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgIHByb2pf"
    "aW5kZXggPSBOb25lCgogICAgICAgICMgM+yInOychDogX2hvdGtleV9zaGVldHMoKSDqsIAg7IKs7Jqp7ZWY64qUIO2YhOyerCDtlITroZzsoJ3tirgKICAg"
    "ICAgICBpZiBwcm9qX2luZGV4IGlzIG5vdCBOb25lIGFuZCAwIDw9IHByb2pfaW5kZXggPCBsZW4ocHJvamVjdHMpOgogICAgICAgICAgICBzaGVldHMgPSBw"
    "cm9qZWN0c1twcm9qX2luZGV4XS5nZXQoImhvdGtleV9zaGVldHNfZ2xvYmFsIiwgW10pIG9yIFtdCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc2hlZXRz"
    "ID0gc2VsZi5faG90a2V5X3NoZWV0cygpCgogICAgICAgIGlmIG5vdCBzaGVldHM6CiAgICAgICAgICAgIFF0V2lkZ2V0cy5RTWVzc2FnZUJveC5pbmZvcm1h"
    "dGlvbihzZWxmLCAi7JWM66a8IiwgIu2YhOyerCDssKjsooXsnKDtmJXsl5Ag7ISk7KCV65CcIOy5tOyatO2EsCDri6jstpXtgqQg7KCV67O06rCAIOyXhuyK"
    "teuLiOuLpC4iKQogICAgICAgICAgICByZXR1cm4KCiAgICAgICAgIyAxKSDsi5ztirggbmFtZSDqs7wg7KCV7ZmV7Z6IIOydvOy5mO2VmOuKlCDtla3rqqns"
    "nYQg7Jqw7ISgIOqygOyDiQogICAgICAgIHRhcmdldCA9IE5vbmUKICAgICAgICBmb3IgcyBpbiBzaGVldHM6CiAgICAgICAgICAgIGlmIHN0cihzLmdldCgi"
    "bmFtZSIsICIiKSkuc3RyaXAoKSA9PSBjb3VudGVyX25hbWU6CiAgICAgICAgICAgICAgICB0YXJnZXQgPSBzCiAgICAgICAgICAgICAgICBicmVhawoKICAg"
    "ICAgICAjIDIpIOyXhuycvOuptCBjb3VudGVyX25hbWUg7JWI7J2YIOyIq+yekOulvCDsnbTsmqntlbQg7J24642x7Iqk66GcIOy2lOyglSAoIu2VreuqqTEi"
    "LCAi7Lm07Jq07YSwMiIg65OxKQogICAgICAgIGlmIHRhcmdldCBpcyBOb25lOgogICAgICAgICAgICBpbXBvcnQgcmUgYXMgX3JlCiAgICAgICAgICAgIG0g"
    "PSBfcmUuc2VhcmNoKHIiKFxkKykiLCBjb3VudGVyX25hbWUpCiAgICAgICAgICAgIGlmIG06CiAgICAgICAgICAgICAgICBpZHggPSBpbnQobS5ncm91cCgx"
    "KSkgLSAxCiAgICAgICAgICAgICAgICBpZiAwIDw9IGlkeCA8IGxlbihzaGVldHMpOgogICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHNoZWV0c1tpZHhd"
    "CgogICAgICAgICMgMykg6re4656Y64+EIOuquyDssL7snLzrqbQsIOqwmeydgCDrsKntlqXrsojtmLjrpbwg6rCA7KeEIOuLpOuluCDsubTsmrTthLAg7ZaJ"
    "7JeQ7IScIOyLnO2KuCDsnbTrpoTsnYQg64yA7IugIOywvuuKlOuLpC4KICAgICAgICBpZiB0YXJnZXQgaXMgTm9uZToKICAgICAgICAgICAgZm9yIHIgaW4g"
    "cmFuZ2Uoc2VsZi5jdC5yb3dDb3VudCgpKToKICAgICAgICAgICAgICAgIGlmIHIgPT0gcm93OgogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAg"
    "ICAgICAgICAgICBhbHRfZGlyX2l0ZW0gPSBzZWxmLmN0Lml0ZW0ociwgMSkKICAgICAgICAgICAgICAgIGFsdF9uYW1lX2l0ZW0gPSBzZWxmLmN0Lml0ZW0o"
    "ciwgMCkKICAgICAgICAgICAgICAgIGlmIG5vdCBhbHRfZGlyX2l0ZW0gb3Igbm90IGFsdF9uYW1lX2l0ZW06CiAgICAgICAgICAgICAgICAgICAgY29udGlu"
    "dWUKICAgICAgICAgICAgICAgIGlmIChhbHRfZGlyX2l0ZW0udGV4dCgpIG9yICIiKS5zdHJpcCgpICE9IGRpcl90ZXh0OgogICAgICAgICAgICAgICAgICAg"
    "IGNvbnRpbnVlCiAgICAgICAgICAgICAgICBhbHRfbmFtZSA9IChhbHRfbmFtZV9pdGVtLnRleHQoKSBvciAiIikuc3RyaXAoKQogICAgICAgICAgICAgICAg"
    "aWYgbm90IGFsdF9uYW1lOgogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICBmb3IgcyBpbiBzaGVldHM6CiAgICAgICAgICAg"
    "ICAgICAgICAgaWYgc3RyKHMuZ2V0KCJuYW1lIiwgIiIpKS5zdHJpcCgpID09IGFsdF9uYW1lOgogICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBz"
    "CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICBpZiB0YXJnZXQgaXMgbm90IE5vbmU6CiAgICAgICAgICAgICAgICAgICAg"
    "YnJlYWsKCiAgICAgICAgIyA0KSDrp4jsp4Drp4kg7Iuc64+EOiDrqqjrk6Ag7LCo7KKF7Jyg7ZiV7J2YIOuLqOy2le2CpCDsi5ztirjsl5DshJwg6rCZ7J2A"
    "IOydtOumhOydhCDqsoDsg4kKICAgICAgICBpZiB0YXJnZXQgaXMgTm9uZSBhbmQgcHJvamVjdHM6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAg"
    "IGltcG9ydCByZSBhcyBfcmUKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBkaXJfdmFsID0gaW50KGRpcl90ZXh0KQogICAgICAg"
    "ICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICBkaXJfdmFsID0gTm9uZQogICAgICAgICAgICAgICAgZm9yIHBfaWR4LCBw"
    "IGluIGVudW1lcmF0ZShwcm9qZWN0cyk6CiAgICAgICAgICAgICAgICAgICAgZm9yIHMgaW4gcC5nZXQoImhvdGtleV9zaGVldHNfZ2xvYmFsIiwgW10pIG9y"
    "IFtdOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBzdHIocy5nZXQoIm5hbWUiLCAiIikpLnN0cmlwKCkgPT0gY291bnRlcl9uYW1lOgogICAgICAgICAg"
    "ICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcwogICAgICAgICAgICAgICAgICAgICAgICAgICAgIyDssL7snYAg6rK97JqwLCBzaXRlX2RhdGEg7J2YIGdy"
    "b3VwX3Byb2plY3RzIOyXkOuPhCDrs7TqsJUg7KCA7J6lCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAg"
    "ICAgICAgICAgcm93X2tleSA9IHNlbGYuX3Jvd19rZXkoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNmZ19zYXZlZCA9IHNlbGYuc2l0ZV9k"
    "YXRhLmdldChyb3dfa2V5LCB7fSkgb3Ige30KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHMgPSBjZmdfc2F2ZWQuZ2V0KCJncm91cHMi"
    "LCBbXSkgb3IgW10KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cF9wcm9qZWN0cyA9IGNmZ19zYXZlZC5nZXQoImdyb3VwX3Byb2plY3Rz"
    "Iiwge30pIG9yIHt9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgZGlyX3ZhbCBpcyBub3QgTm9uZToKICAgICAgICAgICAgICAgICAgICAg"
    "ICAgICAgICAgICAgICAgZm9yIGdycF9sYWJlbCBpbiBncm91cHM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgcGFydCBp"
    "biBfcmUuc3BsaXQociJbXjAtOV0rIiwgc3RyKGdycF9sYWJlbCkpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHBh"
    "cnQuaXNkaWdpdCgpIGFuZCBpbnQocGFydCkgPT0gZGlyX3ZhbDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3Jv"
    "dXBfcHJvamVjdHNbZ3JwX2xhYmVsXSA9IHBfaWR4CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNmZ19zYXZlZFsi"
    "Z3JvdXBfcHJvamVjdHMiXSA9IGdyb3VwX3Byb2plY3RzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2l0"
    "ZV9kYXRhW3Jvd19rZXldID0gY2ZnX3NhdmVkCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAg"
    "ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVl"
    "CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlv"
    "bjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAg"
    "ICAgIGlmIHRhcmdldCBpcyBub3QgTm9uZToKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAg"
    "ICAgICAgICAgICAgIHBhc3MKCiAgICAgICAgaWYgdGFyZ2V0IGlzIE5vbmU6CiAgICAgICAgICAgIFF0V2lkZ2V0cy5RTWVzc2FnZUJveC5pbmZvcm1hdGlv"
    "bigKICAgICAgICAgICAgICAgIHNlbGYsCiAgICAgICAgICAgICAgICAi7JWM66a8IiwKICAgICAgICAgICAgICAgIGYiJ3tjb3VudGVyX25hbWV9JyDtla3r"
    "qqnsl5Ag7Jew6rKw65CcIOuLqOy2le2CpCDsi5ztirjrpbwg7LC+7J2EIOyImCDsl4bsirXri4jri6QuXG4iCiAgICAgICAgICAgICAgICAi7J6F66Cl6re4"
    "66O5KO2DrSnsnZgg64uo7LaV7YKkIOyEpOygleyXkOyEnCDrqLzsoIAg7Iuc7Yq466W8IOyngOygle2VtCDso7zshLjsmpQuIiwKICAgICAgICAgICAgKQog"
    "ICAgICAgICAgICByZXR1cm4KCiAgICAgICAgaXRlbXMgPSB0YXJnZXQuZ2V0KCJpdGVtcyIsIFtdKQogICAgICAgIGRsZyA9IFF0V2lkZ2V0cy5RRGlhbG9n"
    "KHNlbGYpCiAgICAgICAgZGxnLnNldFdpbmRvd1RpdGxlKGYi64uo7LaV7YKkIOyEpOyglSAoe2Rpcl90ZXh0feuyiCDrsKntlqUpIikKICAgICAgICB2ID0g"
    "UXRXaWRnZXRzLlFWQm94TGF5b3V0KGRsZykKCiAgICAgICAgIyDsg4Hri6g6IOuwqe2WpSDsoJXrs7QKICAgICAgICBkaXJfbGFiZWwgPSBRdFdpZGdldHMu"
    "UUxhYmVsKGYie2Rpcl90ZXh0feuyiCDrsKntlqUiKQogICAgICAgIGRpcl9sYWJlbC5zZXRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduQ2VudGVyKQogICAg"
    "ICAgIGZvbnQgPSBkaXJfbGFiZWwuZm9udCgpCiAgICAgICAgZm9udC5zZXRCb2xkKFRydWUpCiAgICAgICAgZGlyX2xhYmVsLnNldEZvbnQoZm9udCkKICAg"
    "ICAgICB2LmFkZFdpZGdldChkaXJfbGFiZWwpCgogICAgICAgICMg6rCBIOywqOyiheuzhCDri6jstpXtgqQg7KCV67O066W8IOuCmOyXtCAo7J296riwIOyg"
    "hOyaqSkKICAgICAgICBmb3IgcmVjIGluIGl0ZW1zOgogICAgICAgICAgICByb3dfbGF5b3V0ID0gUXRXaWRnZXRzLlFIQm94TGF5b3V0KCkKICAgICAgICAg"
    "ICAgbmFtZSA9IHJlYy5nZXQoIuywqOyiheuqhSIsICIiKQogICAgICAgICAgICBrZXkgPSByZWMuZ2V0KCLri6jstpXtgqQiLCAiIikKICAgICAgICAgICAg"
    "bGJsID0gUXRXaWRnZXRzLlFMYWJlbChmIntuYW1lfSDtgqQiKQogICAgICAgICAgICBlZGl0ID0gUXRXaWRnZXRzLlFMaW5lRWRpdChrZXkpCiAgICAgICAg"
    "ICAgIGVkaXQuc2V0UmVhZE9ubHkoVHJ1ZSkKICAgICAgICAgICAgZWRpdC5zZXRNYXhpbXVtV2lkdGgoMTAwKQogICAgICAgICAgICByb3dfbGF5b3V0LmFk"
    "ZFdpZGdldChsYmwpCiAgICAgICAgICAgIHJvd19sYXlvdXQuYWRkV2lkZ2V0KGVkaXQpCiAgICAgICAgICAgIHJvd19sYXlvdXQuYWRkU3RyZXRjaCgxKQog"
    "ICAgICAgICAgICB2LmFkZExheW91dChyb3dfbGF5b3V0KQoKICAgICAgICBpZiBub3QgaXRlbXM6CiAgICAgICAgICAgIHYuYWRkV2lkZ2V0KFF0V2lkZ2V0"
    "cy5RTGFiZWwoIuuTseuhneuQnCDri6jstpXtgqQg7KCV67O06rCAIOyXhuyKteuLiOuLpC4iKSkKCiAgICAgICAgIyDri6vquLAg67KE7Yq8CiAgICAgICAg"
    "YnRuX3JvdyA9IFF0V2lkZ2V0cy5RSEJveExheW91dCgpCiAgICAgICAgYnRuX3Jvdy5hZGRTdHJldGNoKDEpCiAgICAgICAgYnRuX2Nsb3NlID0gUXRXaWRn"
    "ZXRzLlFQdXNoQnV0dG9uKCJDbG9zZSIpCiAgICAgICAgYnRuX2Nsb3NlLmNsaWNrZWQuY29ubmVjdChkbGcuYWNjZXB0KQogICAgICAgIGJ0bl9yb3cuYWRk"
    "V2lkZ2V0KGJ0bl9jbG9zZSkKICAgICAgICB2LmFkZExheW91dChidG5fcm93KQoKICAgICAgICBkbGcuZXhlY18oKQogICAgZGVmIGFwcGx5X3RlbXBsYXRl"
    "X2Zyb21fdmVoaWNsZShzZWxmKToKICAgICAgICAiIiLsobDsgqzssKjsooUg7ISk7KCV7JeQ7IScIOyEoO2DneuQnCDssKjsooUg7Jyg7ZiV7J2YIOyeheug"
    "peq3uOujuSDthZztlIzrpr/snYQg67aI65+s7JmAIOyggeyaqS4iIiIKICAgICAgICAjIFN1cnZleU1hbmFnZXJQYWdlIOuCtOydmCDsobDsgqzssKjsooUg"
    "7YOtKFN1cnZleVZlaGljbGVUYWIp7JeQ7IScIO2YhOyerCDtlITroZzsoJ3tirgg7J24642x7IqkIO2ZleyduAogICAgICAgIHZlaF90YWIgPSBnZXRhdHRy"
    "KHNlbGYucGFnZSwgInZlaCIsIE5vbmUpCiAgICAgICAgaWYgdmVoX3RhYiBpcyBOb25lOgogICAgICAgICAgICBRdFdpZGdldHMuUU1lc3NhZ2VCb3guaW5m"
    "b3JtYXRpb24oc2VsZiwgIuyVjOumvCIsICLsobDsgqzssKjsooUg7ISk7KCVIO2DrSDsoJXrs7Trpbwg7LC+7J2EIOyImCDsl4bsirXri4jri6QuIikKICAg"
    "ICAgICAgICAgcmV0dXJuCgogICAgICAgIHRyeToKICAgICAgICAgICAgcHJval9pbmRleCA9IHZlaF90YWIuY2IuY3VycmVudEluZGV4KCkKICAgICAgICBl"
    "eGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICBRdFdpZGdldHMuUU1lc3NhZ2VCb3guaW5mb3JtYXRpb24oc2VsZiwgIuyVjOumvCIsICLsobDsgqzssKjs"
    "ooUg7ISk7KCVIOy9pOuztOuwleyKpOulvCDssL7snYQg7IiYIOyXhuyKteuLiOuLpC4iKQogICAgICAgICAgICByZXR1cm4KCiAgICAgICAgcHJvamVjdHMg"
    "PSAoc2VsZi5wYWdlLmRhdGEgb3Ige30pLmdldCgicHJvamVjdHMiLCBbXSkKICAgICAgICBpZiBub3QgKDAgPD0gcHJval9pbmRleCA8IGxlbihwcm9qZWN0"
    "cykpOgogICAgICAgICAgICBRdFdpZGdldHMuUU1lc3NhZ2VCb3guaW5mb3JtYXRpb24oc2VsZiwgIuyVjOumvCIsICLrqLzsoIAg7KGw7IKs7LCo7KKFIOyE"
    "pOygleyXkOyEnCDssKjsooUg7Jyg7ZiV7J2EIOyEoO2Dne2VmOyEuOyalC4iKQogICAgICAgICAgICByZXR1cm4KCiAgICAgICAgcHJvaiA9IHByb2plY3Rz"
    "W3Byb2pfaW5kZXhdCiAgICAgICAgdGVtcGxhdGVzID0gcHJvai5nZXQoInRlbXBsYXRlcyIsIFtdKQogICAgICAgIGlmIG5vdCB0ZW1wbGF0ZXM6CiAgICAg"
    "ICAgICAgIFF0V2lkZ2V0cy5RTWVzc2FnZUJveC5pbmZvcm1hdGlvbihzZWxmLCAi7JWM66a8IiwgIuyEoO2DneuQnCDssKjsooUg7Jyg7ZiV7JeQIOuTseuh"
    "neuQnCDsnoXroKXqt7jro7kg7YWc7ZSM66a/7J20IOyXhuyKteuLiOuLpC4iKQogICAgICAgICAgICByZXR1cm4KCiAgICAgICAgIyDthZztlIzrpr8g7ISg"
    "7YOdIO2MneyXhQogICAgICAgIG5hbWVzID0gW3QuZ2V0KCJuYW1lIiwgIijrrLTsoJwpIikgb3IgIijrrLTsoJwpIiBmb3IgdCBpbiB0ZW1wbGF0ZXNdCiAg"
    "ICAgICAgbmFtZSwgb2sgPSBRdFdpZGdldHMuUUlucHV0RGlhbG9nLmdldEl0ZW0oc2VsZiwgIu2FnO2UjOumvyDshKDtg50iLCAi7J6F66Cl6re466O5IO2F"
    "nO2UjOumv+ydhCDshKDtg53tlZjshLjsmpQ6IiwgbmFtZXMsIDAsIEZhbHNlKQogICAgICAgIGlmIG5vdCBvazoKICAgICAgICAgICAgcmV0dXJuCiAgICAg"
    "ICAgdHJ5OgogICAgICAgICAgICBpZHggPSBuYW1lcy5pbmRleChuYW1lKQogICAgICAgIGV4Y2VwdCBWYWx1ZUVycm9yOgogICAgICAgICAgICBRdFdpZGdl"
    "dHMuUU1lc3NhZ2VCb3guaW5mb3JtYXRpb24oc2VsZiwgIuyVjOumvCIsICLshKDtg53tlZwg7YWc7ZSM66a/7J2EIOywvuydhCDsiJgg7JeG7Iq164uI64uk"
    "LiIpCiAgICAgICAgICAgIHJldHVybgoKICAgICAgICB0cGwgPSB0ZW1wbGF0ZXNbaWR4XQogICAgICAgIGRpcnNfbGlzdCA9IHRwbC5nZXQoImRpcnMiLCBb"
    "XSkgb3IgW10KICAgICAgICBjb3VudGVycyA9IHRwbC5nZXQoImNvdW50ZXJzIiwgW10pIG9yIFtdCgogICAgICAgICMg67Cp7Zal7IiYIOqzhOyCsDog7YWc"
    "7ZSM66a/7J2YIOq3uOujuS/subTsmrTthLDsl5DshJwg7IKs7Jqp65CcIOuwqe2WpeuyiO2YuOydmCDstZzrjJPqsJIKICAgICAgICBkaXJfbnVtcyA9IHNl"
    "dCgpCiAgICAgICAgZm9yIGMgaW4gY291bnRlcnM6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGQgPSBpbnQoc3RyKGMuZ2V0KCJkaXIiLCAi"
    "IikpLnN0cmlwKCkpCiAgICAgICAgICAgICAgICBkaXJfbnVtcy5hZGQoZCkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAg"
    "IHBhc3MKICAgICAgICBmb3IgbGFiZWwgaW4gZGlyc19saXN0OgogICAgICAgICAgICBwYXJ0cyA9IHN0cihsYWJlbCkuc3BsaXQoIi0iKQogICAgICAgICAg"
    "ICBmb3IgcCBpbiBwYXJ0czoKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBkaXJfbnVtcy5hZGQoaW50KHApKQogICAgICAgICAg"
    "ICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgaWYgZGlyX251bXM6CiAgICAgICAgICAgIG1heF9kaXIg"
    "PSBtYXgoZGlyX251bXMpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgbWF4X2RpciA9IG1heChzZWxmLnNwaW4udmFsdWUoKSwgMSkKCiAgICAgICAgIyDr"
    "sKntlqXsiJgg67CPIOuwqe2WpeuyiO2YuCDrpqzsiqTtirgg7J6s6rWs7ISxCiAgICAgICAgc2VsZi5zcGluLnNldFZhbHVlKG1heF9kaXIpCiAgICAgICAg"
    "c2VsZi5kaXIuY2xlYXIoKQogICAgICAgIGZvciBpIGluIHJhbmdlKDEsIHNlbGYuc3Bpbi52YWx1ZSgpICsgMSk6CiAgICAgICAgICAgIHNlbGYuZGlyLmFk"
    "ZEl0ZW0oc3RyKGkpKQoKICAgICAgICAjIOyeheugpeq3uOujuSjtg60pIOq1rOyEsSDsoIHsmqkKICAgICAgICBzZWxmLnRhYnMuY2xlYXIoKQogICAgICAg"
    "IGZvciBnbmFtZSBpbiBkaXJzX2xpc3Q6CiAgICAgICAgICAgIHNlbGYudGFicy5hZGRJdGVtKHN0cihnbmFtZSkpCgogICAgICAgICMg7Lm07Jq07YSwIO2F"
    "jOydtOu4lCDqtazshLEg7KCB7JqpCiAgICAgICAgc2VsZi5jdC5zZXRSb3dDb3VudCgwKQogICAgICAgIGZvciBjIGluIGNvdW50ZXJzOgogICAgICAgICAg"
    "ICByID0gc2VsZi5jdC5yb3dDb3VudCgpCiAgICAgICAgICAgIHNlbGYuY3QuaW5zZXJ0Um93KHIpCiAgICAgICAgICAgIG5hbWVfaXRlbSA9IFF0V2lkZ2V0"
    "cy5RVGFibGVXaWRnZXRJdGVtKGMuZ2V0KCJuYW1lIiwgIiIpKQogICAgICAgICAgICBuYW1lX2l0ZW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxp"
    "Z25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgIyDsubTsmrTthLAg7J2066aEIOyXtOydgCDsgqzsmqnsnpAg7Y647KeR"
    "IOu2iOqwgAogICAgICAgICAgICBuYW1lX2l0ZW0uc2V0RmxhZ3MobmFtZV9pdGVtLmZsYWdzKCkgJiB+UXRDb3JlLlF0Lkl0ZW1Jc0VkaXRhYmxlKQogICAg"
    "ICAgICAgICBkaXJfaXRlbSA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKHN0cihjLmdldCgiZGlyIiwgIiIpKSkKICAgICAgICAgICAgZGlyX2l0ZW0u"
    "c2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgIyDrsKntlqUg7Je0"
    "7J2AIOydveq4sCDsoITsmqkKICAgICAgICAgICAgZGlyX2l0ZW0uc2V0RmxhZ3MoZGlyX2l0ZW0uZmxhZ3MoKSAmIH5RdENvcmUuUXQuSXRlbUlzRWRpdGFi"
    "bGUpCiAgICAgICAgICAgIGxhYmVsX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShjLmdldCgibGFiZWwiLCAiIikpCiAgICAgICAgICAgIHNl"
    "bGYuY3Quc2V0SXRlbShyLCAwLCBuYW1lX2l0ZW0pCiAgICAgICAgICAgIGRpcl9pdGVtLnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRl"
    "ciB8IFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAgICAgIHNlbGYuY3Quc2V0SXRlbShyLCAxLCBkaXJfaXRlbSkKICAgICAgICAgICAgc2VsZi5j"
    "dC5zZXRJdGVtKHIsIDIsIGxhYmVsX2l0ZW0pCgogICAgICAgICMg7ZiE7J6sIOyngOygkO2WieyXkCDshKTsoJUg7KaJ7IucIOuwmOyYgQogICAgICAgIHNl"
    "bGYuX2FwcGx5X3RvX2N1cnJlbnRfcm93KEZhbHNlKQoKICAgIGRlZiBfbG9hZF91aShzZWxmLCByb3cpOgogICAgICAgIGtleSA9IHNlbGYuX3Jvd19rZXko"
    "cm93KQogICAgICAgIGNmZyA9IHNlbGYuc2l0ZV9kYXRhLmdldChrZXksIHt9KQogICAgICAgICMg67Cp7Zal7IiYIC8g67Cp7Zal67KI7Zi4IOumrOyKpO2K"
    "uAogICAgICAgIHNwaW5fdmFsID0gY2ZnLmdldCgic3BpbiIpCiAgICAgICAgaWYgaXNpbnN0YW5jZShzcGluX3ZhbCwgaW50KSBhbmQgMSA8PSBzcGluX3Zh"
    "bCA8PSA0MDoKICAgICAgICAgICAgc2VsZi5zcGluLnNldFZhbHVlKHNwaW5fdmFsKQogICAgICAgIGRpcnMgPSBjZmcuZ2V0KCJkaXJzIikgb3IgW10KICAg"
    "ICAgICBzZWxmLmRpci5jbGVhcigpCiAgICAgICAgaWYgZGlyczoKICAgICAgICAgICAgZm9yIGQgaW4gZGlyczoKICAgICAgICAgICAgICAgIHNlbGYuZGly"
    "LmFkZEl0ZW0oc3RyKGQpKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgICMg7KCA7J6l65CcIOuwqe2WpSDrpqzsiqTtirjqsIAg7JeG7Jy866m0IO2YhOye"
    "rCDsiqTtlYAg6rCSIOq4sOykgOycvOuhnCAxLi5OIOyDneyEsQogICAgICAgICAgICBmb3IgaSBpbiByYW5nZSgxLCBzZWxmLnNwaW4udmFsdWUoKSArIDEp"
    "OgogICAgICAgICAgICAgICAgc2VsZi5kaXIuYWRkSXRlbShzdHIoaSkpCgogICAgICAgICMg7J6F66ClIOq3uOujuSjtg60pCiAgICAgICAgc2VsZi50YWJz"
    "LmNsZWFyKCkKICAgICAgICBmb3IgZ25hbWUgaW4gY2ZnLmdldCgiZ3JvdXBzIiwgW10pOgogICAgICAgICAgICBzZWxmLnRhYnMuYWRkSXRlbShnbmFtZSkK"
    "CiAgICAgICAgIyDsubTsmrTthLAg7YWM7J2067iUCiAgICAgICAgc2VsZi5jdC5zZXRSb3dDb3VudCgwKQogICAgICAgIGZvciBjIGluIGNmZy5nZXQoImNv"
    "dW50ZXJzIiwgW10pOgogICAgICAgICAgICByID0gc2VsZi5jdC5yb3dDb3VudCgpCiAgICAgICAgICAgIHNlbGYuY3QuaW5zZXJ0Um93KHIpCiAgICAgICAg"
    "ICAgIG5hbWVfaXRlbSA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKGMuZ2V0KCJuYW1lIiwgIiIpKQogICAgICAgICAgICBuYW1lX2l0ZW0uc2V0VGV4"
    "dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgIyDsubTsmrTthLAg7J2066aE"
    "IOyXtOydgCDsgqzsmqnsnpAg7Y647KeRIOu2iOqwgAogICAgICAgICAgICBuYW1lX2l0ZW0uc2V0RmxhZ3MobmFtZV9pdGVtLmZsYWdzKCkgJiB+UXRDb3Jl"
    "LlF0Lkl0ZW1Jc0VkaXRhYmxlKQogICAgICAgICAgICBkaXJfaXRlbSA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKHN0cihjLmdldCgiZGlyIiwgIiIp"
    "KSkKICAgICAgICAgICAgZGlyX2l0ZW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikK"
    "ICAgICAgICAgICAgIyDrsKntlqUg7Je07J2AIOydveq4sCDsoITsmqkKICAgICAgICAgICAgZGlyX2l0ZW0uc2V0RmxhZ3MoZGlyX2l0ZW0uZmxhZ3MoKSAm"
    "IH5RdENvcmUuUXQuSXRlbUlzRWRpdGFibGUpCiAgICAgICAgICAgIGxhYmVsX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShjLmdldCgibGFi"
    "ZWwiLCAiIikpCiAgICAgICAgICAgIHNlbGYuY3Quc2V0SXRlbShyLCAwLCBuYW1lX2l0ZW0pCiAgICAgICAgICAgIGRpcl9pdGVtLnNldFRleHRBbGlnbm1l"
    "bnQoUXRDb3JlLlF0LkFsaWduSENlbnRlciB8IFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAgICAgIHNlbGYuY3Quc2V0SXRlbShyLCAxLCBkaXJf"
    "aXRlbSkKICAgICAgICAgICAgc2VsZi5jdC5zZXRJdGVtKHIsIDIsIGxhYmVsX2l0ZW0pCgogICAgZGVmIF9vbl9zZWxlY3Rfcm93KHNlbGYsIGN1cl9yb3cs"
    "IGN1cl9jb2wsIHByZXZfcm93LCBwcmV2X2NvbCk6CiAgICAgICAgaWYgcHJldl9yb3cgaXMgbm90IE5vbmUgYW5kIHByZXZfcm93ID49IDA6CiAgICAgICAg"
    "ICAgIHNlbGYuc2l0ZV9kYXRhW3NlbGYuX3Jvd19rZXkocHJldl9yb3cpXSA9IHNlbGYuX2NvbGxlY3RfdWkoKQogICAgICAgIGlmIGN1cl9yb3cgaXMgbm90"
    "IE5vbmUgYW5kIGN1cl9yb3cgPj0gMDoKICAgICAgICAgICAgc2VsZi5fbG9hZF91aShjdXJfcm93KQoKICAgICMgLS0tLS0tLS0tLSDrsKntlqUv6re466O5"
    "L+y5tOyatO2EsCBVSSAtLS0tLS0tLS0tCiAgICBkZWYgZ2VuX2RpcnMoc2VsZik6CiAgICAgICAgIiIiCiAgICAgICAg67Cp7Zal67KI7Zi4IOyDneyEsToK"
    "ICAgICAgICAtIOyKpO2VgOuwleyKpCDqsJIoMX5OKeydhCDquLDspIDsnLzroZwg7KCE7LK0IOuwqe2WpeuyiO2YuOulvCDrp4zrk6Ag65KkCiAgICAgICAg"
    "LSDsnbTrr7gg7J6F66Cl6re466O5KO2DrSnsl5Ag7Y+s7ZWo65CcIOuwqe2WpeydgCDsoJzsmbjtlZjsl6wg64Ko7J2AIOuwqe2WpeunjCDrpqzsiqTtirjs"
    "l5Ag7ZGc7Iuc7ZWp64uI64ukLgogICAgICAgICIiIgogICAgICAgIGltcG9ydCByZSBhcyBfcmUKCiAgICAgICAgYWxsX2RpcnMgPSBzZXQocmFuZ2UoMSwg"
    "c2VsZi5zcGluLnZhbHVlKCkgKyAxKSkKICAgICAgICB1c2VkX2RpcnMgPSBzZXQoKQogICAgICAgICMg7YOt7JeQIOydtOuvuCDsgqzsmqnrkJwg67Cp7Zal"
    "67KI7Zi4IOyImOynkQogICAgICAgIGZvciBpIGluIHJhbmdlKHNlbGYudGFicy5jb3VudCgpKToKICAgICAgICAgICAgbGFiZWwgPSBzZWxmLnRhYnMuaXRl"
    "bShpKS50ZXh0KCkKICAgICAgICAgICAgZm9yIHBhcnQgaW4gX3JlLnNwbGl0KHIiW14wLTldKyIsIGxhYmVsKToKICAgICAgICAgICAgICAgIGlmIHBhcnQu"
    "aXNkaWdpdCgpOgogICAgICAgICAgICAgICAgICAgIHVzZWRfZGlycy5hZGQoaW50KHBhcnQpKQoKICAgICAgICByZW1haW4gPSBzb3J0ZWQoZCBmb3IgZCBp"
    "biBhbGxfZGlycyBpZiBkIG5vdCBpbiB1c2VkX2RpcnMpCiAgICAgICAgc2VsZi5kaXIuY2xlYXIoKQogICAgICAgIGZvciBkIGluIHJlbWFpbjoKICAgICAg"
    "ICAgICAgc2VsZi5kaXIuYWRkSXRlbShzdHIoZCkpCiAgICAgICAgIyDrsKntlqUg66as7Iqk7Yq46rCAIOuwlOuAjOuptCDtmITsnqwg7KeA7KCQ7J2YIOyE"
    "pOygleuPhCDqsLHsi6AKICAgICAgICBzZWxmLl9hcHBseV90b19jdXJyZW50X3JvdyhGYWxzZSkKCiAgICBkZWYgdG9fdGFicyhzZWxmKToKICAgICAgICAi"
    "IiLshKDtg53rkJwg67Cp7Zal67KI7Zi465Ok7J2EIO2VmOuCmOydmCDsnoXroKXqt7jro7ko7YOtKeycvOuhnCDstpTqsIDtlZjqs6AsIO2VtOuLuSDrsKnt"
    "lqXsnYAg67Cp7Zal67KI7Zi4IOumrOyKpO2KuOyXkOyEnCDsoJzqsbAuIiIiCiAgICAgICAgaXRlbXMgPSBzZWxmLmRpci5zZWxlY3RlZEl0ZW1zKCkKICAg"
    "ICAgICBpZiBub3QgaXRlbXM6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIHNlbHMgPSBbaXQudGV4dCgpIGZvciBpdCBpbiBpdGVtc10KICAgICAgICB0"
    "cnk6CiAgICAgICAgICAgIG51bXMgPSBzb3J0ZWQoaW50KHgpIGZvciB4IGluIHNlbHMpCiAgICAgICAgICAgIGxhYmVsID0gIi0iLmpvaW4oc3RyKG4pIGZv"
    "ciBuIGluIG51bXMpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgbGFiZWwgPSAiLSIuam9pbihzZWxzKQogICAgICAgICMg7J6F66Cl"
    "6re466O5IO2DrSDstpTqsIAKICAgICAgICBzZWxmLnRhYnMuYWRkSXRlbShsYWJlbCkKCiAgICAgICAgIyDstpTqsIDrkJwg67Cp7Zal67KI7Zi464qUIOyi"
    "jOy4oSDrsKntlqXrsojtmLgg66as7Iqk7Yq47JeQ7IScIOygnOqxsCjspJHrs7Ug67Cp7KeAKQogICAgICAgIHJvd3MgPSBzb3J0ZWQoe3NlbGYuZGlyLnJv"
    "dyhpdCkgZm9yIGl0IGluIGl0ZW1zfSwgcmV2ZXJzZT1UcnVlKQogICAgICAgIGZvciByIGluIHJvd3M6CiAgICAgICAgICAgIHNlbGYuZGlyLnRha2VJdGVt"
    "KHIpCgogICAgICAgICMg7ISk7KCVIOuwmOyYgQogICAgICAgIHNlbGYuX2FwcGx5X3RvX2N1cnJlbnRfcm93KEZhbHNlKQoKICAgIGRlZiBmcm9tX3RhYnMo"
    "c2VsZik6CiAgICAgICAgIiIi7ISg7YOd65CcIOyeheugpeq3uOujuSjtg60p7J2EIOygnOqxsO2VmOqzoCwg6re4IOyViOyXkCDtj6ztlajrkJwg67Cp7Zal"
    "67KI7Zi466W8IOuLpOyLnCDrsKntlqXrsojtmLgg66as7Iqk7Yq47JeQIOuzteybkC4iIiIKICAgICAgICBpbXBvcnQgcmUgYXMgX3JlCgogICAgICAgIGl0"
    "ZW1zID0gc2VsZi50YWJzLnNlbGVjdGVkSXRlbXMoKQogICAgICAgIGlmIG5vdCBpdGVtczoKICAgICAgICAgICAgcmV0dXJuCgogICAgICAgICMg7YOt7JeQ"
    "7IScIOuzteybkO2VtOyVvCDtlaAg67Cp7Zal67KI7Zi4IOyImOynkQogICAgICAgIHJlc3RvcmVfZGlycyA9IHNldCgpCiAgICAgICAgZm9yIGl0IGluIGl0"
    "ZW1zOgogICAgICAgICAgICBsYWJlbCA9IGl0LnRleHQoKQogICAgICAgICAgICBmb3IgcGFydCBpbiBfcmUuc3BsaXQociJbXjAtOV0rIiwgbGFiZWwpOgog"
    "ICAgICAgICAgICAgICAgaWYgcGFydC5pc2RpZ2l0KCk6CiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZV9kaXJzLmFkZChpbnQocGFydCkpCgogICAgICAg"
    "ICMg7ISg7YOd65CcIO2DrSDsoJzqsbAKICAgICAgICBmb3IgaXQgaW4gaXRlbXM6CiAgICAgICAgICAgIHNlbGYudGFicy50YWtlSXRlbShzZWxmLnRhYnMu"
    "cm93KGl0KSkKCiAgICAgICAgIyDsnbTrr7gg66as7Iqk7Yq47JeQIOyeiOuKlCDrsKntlqXrsojtmLjsmYAg7KSR67O165CY7KeAIOyViuuPhOuhnSDssrTt"
    "gawKICAgICAgICBleGlzdGluZyA9IHNldCgpCiAgICAgICAgZm9yIGkgaW4gcmFuZ2Uoc2VsZi5kaXIuY291bnQoKSk6CiAgICAgICAgICAgIHRyeToKICAg"
    "ICAgICAgICAgICAgIGV4aXN0aW5nLmFkZChpbnQoc2VsZi5kaXIuaXRlbShpKS50ZXh0KCkpKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAg"
    "ICAgICAgICAgICAgcGFzcwoKICAgICAgICAjIOyIq+yekCDquLDspIAg7Jik66aE7LCo7IicIOychOy5mOyXkCDrp57qsowg67O17JuQCiAgICAgICAgZm9y"
    "IGQgaW4gc29ydGVkKHJlc3RvcmVfZGlycyk6CiAgICAgICAgICAgIGlmIGQgaW4gZXhpc3Rpbmc6CiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAg"
    "ICAgICBwb3MgPSBzZWxmLmRpci5jb3VudCgpCiAgICAgICAgICAgIGZvciBpIGluIHJhbmdlKHNlbGYuZGlyLmNvdW50KCkpOgogICAgICAgICAgICAgICAg"
    "dHJ5OgogICAgICAgICAgICAgICAgICAgIGN1ciA9IGludChzZWxmLmRpci5pdGVtKGkpLnRleHQoKSkKICAgICAgICAgICAgICAgICAgICBpZiBkIDwgY3Vy"
    "OgogICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBpCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICBleGNlcHQgRXhj"
    "ZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIHNlbGYuZGlyLmluc2VydEl0ZW0ocG9zLCBzdHIoZCkpCgogICAgICAg"
    "ICMg7ISk7KCVIOuwmOyYgQogICAgICAgIHNlbGYuX2FwcGx5X3RvX2N1cnJlbnRfcm93KEZhbHNlKQoKICAgIGRlZiBhZGRfY291bnRlcihzZWxmKToKICAg"
    "ICAgICByID0gc2VsZi5jdC5yb3dDb3VudCgpCiAgICAgICAgc2VsZi5jdC5pbnNlcnRSb3cocikKICAgICAgICBuYW1lX2l0ZW0gPSBRdFdpZGdldHMuUVRh"
    "YmxlV2lkZ2V0SXRlbShmIuy5tOyatO2EsHtyKzF9IikKICAgICAgICBuYW1lX2l0ZW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVy"
    "IHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICBuYW1lX2l0ZW0uc2V0RmxhZ3MobmFtZV9pdGVtLmZsYWdzKCkgJiB+UXRDb3JlLlF0Lkl0ZW1J"
    "c0VkaXRhYmxlKQogICAgICAgIGRpcl9pdGVtID0gUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oIjEiKQogICAgICAgIGRpcl9pdGVtLnNldFRleHRBbGln"
    "bm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlciB8IFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAgIyDrsKntlqUg7Je07J2AIOydveq4sCDsoITs"
    "mqkKICAgICAgICBkaXJfaXRlbS5zZXRGbGFncyhkaXJfaXRlbS5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNFZGl0YWJsZSkKICAgICAgICBsYWJlbF9p"
    "dGVtID0gUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oIiIpCiAgICAgICAgc2VsZi5jdC5zZXRJdGVtKHIsIDAsIG5hbWVfaXRlbSkKICAgICAgICBkaXJf"
    "aXRlbS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXIgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQogICAgICAgIHNlbGYuY3Quc2V0"
    "SXRlbShyLCAxLCBkaXJfaXRlbSkKICAgICAgICBzZWxmLmN0LnNldEl0ZW0ociwgMiwgbGFiZWxfaXRlbSkKICAgICAgICAjIOy5tOyatO2EsCDqtazshLHs"
    "nbQg67CU64CM66m0IOuwlOuhnCDsoIDsnqUKICAgICAgICBzZWxmLl9hcHBseV90b19jdXJyZW50X3JvdyhGYWxzZSkKCiAgICBkZWYgZGVsX2NvdW50ZXIo"
    "c2VsZik6CiAgICAgICAgciA9IHNlbGYuY3QuY3VycmVudFJvdygpCiAgICAgICAgaWYgciA+PSAwOgogICAgICAgICAgICBzZWxmLmN0LnJlbW92ZVJvdyhy"
    "KQogICAgICAgICAgICAjIOy5tOyatO2EsCDqtazshLHsnbQg67CU64CM66m0IOuwlOuhnCDsoIDsnqUKICAgICAgICAgICAgc2VsZi5fYXBwbHlfdG9fY3Vy"
    "cmVudF9yb3coRmFsc2UpCgogICAgIyAtLS0tLS0tLS0tIOyngOygkCDtlokg7LaU6rCAL+yCreygnCAtLS0tLS0tLS0tCiAgICBkZWYgYWRkX3NpdGUoc2Vs"
    "Zik6CiAgICAgICAgciA9IHNlbGYudGJsLnJvd0NvdW50KCkKICAgICAgICBzZWxmLnRibC5pbnNlcnRSb3cocikKCiAgICAgICAgIyDsiJzrsog6IOqwgOya"
    "tOuNsCDsoJXroKwgKOyCrOyaqeyekCDtjrjsp5Eg67aI6rCAKQogICAgICAgIG51bV9pdGVtID0gUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oc3RyKHIg"
    "KyAxKSkKICAgICAgICBudW1faXRlbS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXIgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQog"
    "ICAgICAgIG51bV9pdGVtLnNldEZsYWdzKG51bV9pdGVtLmZsYWdzKCkgJiB+UXRDb3JlLlF0Lkl0ZW1Jc0VkaXRhYmxlKQogICAgICAgIHNlbGYudGJsLnNl"
    "dEl0ZW0ociwgMCwgbnVtX2l0ZW0pCgogICAgICAgICMg7KeA67KIOiDqsIDsmrTrjbAg7KCV66CsCiAgICAgICAgamlidW5faXRlbSA9IFF0V2lkZ2V0cy5R"
    "VGFibGVXaWRnZXRJdGVtKCIiKQogICAgICAgIGppYnVuX2l0ZW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0"
    "LkFsaWduVkNlbnRlcikKICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsIDEsIGppYnVuX2l0ZW0pCgogICAgICAgICMg7KeA7KCQ66qFOiDqsIDsmrTrjbAg"
    "7KCV66CsCiAgICAgICAgbmFtZV9pdGVtID0gUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oIiIpCiAgICAgICAgbmFtZV9pdGVtLnNldFRleHRBbGlnbm1l"
    "bnQoUXRDb3JlLlF0LkFsaWduSENlbnRlciB8IFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShyLCAyLCBuYW1lX2l0"
    "ZW0pCgogICAgICAgICMg7J6R7JeF67KI7Zi4OiDsoITssrQg6rO87JeF7JeQ7IScIOykkeuzteuQmOyngCDslYrqsowg7J6Q64+ZIOu2gOyXrCAo6rCA7Jq0"
    "642wIOygleugrCwg7Y647KeRIOu2iOqwgCkKICAgICAgICBqb2Jfbm8gPSBzZWxmLl9uZXh0X2pvYl9ubygpCiAgICAgICAgam9iX2l0ZW0gPSBRdFdpZGdl"
    "dHMuUVRhYmxlV2lkZ2V0SXRlbShqb2Jfbm8pCiAgICAgICAgam9iX2l0ZW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwgUXRD"
    "b3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICBqb2JfaXRlbS5zZXRGbGFncyhqb2JfaXRlbS5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNFZGl0YWJs"
    "ZSkKICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsIDMsIGpvYl9pdGVtKQoKICAgICAgICAjIOuwqe2WpeyImDog6rCA7Jq0642wIOygleugrCAo7IKs7Jqp"
    "7J6QIO2OuOynkSDrtojqsIApCiAgICAgICAgZGlyX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShzdHIoc2VsZi5zcGluLnZhbHVlKCkpKQog"
    "ICAgICAgIGRpcl9pdGVtLnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlciB8IFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAg"
    "ZGlyX2l0ZW0uc2V0RmxhZ3MoZGlyX2l0ZW0uZmxhZ3MoKSAmIH5RdENvcmUuUXQuSXRlbUlzRWRpdGFibGUpCiAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShy"
    "LCA0LCBkaXJfaXRlbSkKCiAgICAgICAgIyDsg4Htg5w6IOyhsOyCrCDsoJXrs7Qg7YOt7J2YIOynhO2WieyDge2DnOulvCDrsJjsmIEKICAgICAgICBzdGF0"
    "ZV90ZXh0ID0gIiIKICAgICAgICB0cnk6CiAgICAgICAgICAgIHN0YXRlX3RleHQgPSBzZWxmLnBhZ2UuaW5mby5jYl9zdGF0ZS5jdXJyZW50VGV4dCgpCiAg"
    "ICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgc3RhdGVfdGV4dCA9ICLrjIDquLAiCiAgICAgICAgaWYgbm90IHN0YXRlX3RleHQ6CiAgICAg"
    "ICAgICAgIHN0YXRlX3RleHQgPSAi64yA6riwIgogICAgICAgIHN0YXRlX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShzdGF0ZV90ZXh0KQog"
    "ICAgICAgIHN0YXRlX2l0ZW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAg"
    "ICBzdGF0ZV9pdGVtLnNldEZsYWdzKHN0YXRlX2l0ZW0uZmxhZ3MoKSAmIH5RdENvcmUuUXQuSXRlbUlzRWRpdGFibGUpCiAgICAgICAgc2VsZi5fYXBwbHlf"
    "c3RhdGVfY29sb3Ioc3RhdGVfaXRlbSkKICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsIDUsIHN0YXRlX2l0ZW0pCgogICAgICAgICMg67mIIOyKrOuhryDs"
    "l7QoNinsnYAg67mE7JuM65GgCiAgICAgICAgc2VsZi5zaXRlX2RhdGFbc2VsZi5fcm93X2tleShyKV0gPSB7Imdyb3VwcyI6IFtdLCAiY291bnRlcnMiOiBb"
    "XX0KCiAgICBkZWYgZGVsX3NpdGUoc2VsZik6CiAgICAgICAgIiIi7ISg7YOd65CcIOyngOygkCDtloko7Jes65+sIOqwnCDshKDtg50g6rCA64qlKeydhCDs"
    "gq3soJztlZjqs6Ag7Iic67KIL+yEpOygleydhCDsnqzsoJXroKwuIiIiCiAgICAgICAgcm93cyA9IHNlbGYuZ2V0KCkKICAgICAgICBpZiBub3Qgcm93czoK"
    "ICAgICAgICAgICAgcmV0dXJuCgogICAgICAgICMg7ISg7YOd65CcIO2WiSDsnbjrjbHsiqQg7IiY7KeRICjsl4bsnLzrqbQg7ZiE7J6sIO2WieunjCDsgqzs"
    "mqkpCiAgICAgICAgc2VsX3Jvd3MgPSBzb3J0ZWQoe2lkeC5yb3coKSBmb3IgaWR4IGluIHNlbGYudGJsLnNlbGVjdGVkSW5kZXhlcygpfSkKICAgICAgICBp"
    "ZiBub3Qgc2VsX3Jvd3MgYW5kIHNlbGYudGJsLmN1cnJlbnRSb3coKSA+PSAwOgogICAgICAgICAgICBzZWxfcm93cyA9IFtzZWxmLnRibC5jdXJyZW50Um93"
    "KCldCiAgICAgICAgaWYgbm90IHNlbF9yb3dzOgogICAgICAgICAgICByZXR1cm4KCiAgICAgICAgIyDrkqTsl5DshJzrtoDthLAg7IKt7KCc7ZW07JW8IOyd"
    "uOuNseyKpOqwgCDqvKzsnbTsp4Ag7JWK7J2MCiAgICAgICAgZm9yIHIgaW4gcmV2ZXJzZWQoc2VsX3Jvd3MpOgogICAgICAgICAgICBpZiAwIDw9IHIgPCBs"
    "ZW4ocm93cyk6CiAgICAgICAgICAgICAgICBkZWwgcm93c1tyXQoKICAgICAgICAjIOyngOygkOygleuztC/subTsmrTthLAg6rWs7ISx7J2EIOuLpOyLnCDs"
    "hLjtjIXtlZjsl6wgc2l0ZV9kYXRh6rmM7KeAIO2VqOq7mCDsoJXrpqwKICAgICAgICBzZWxmLnNldChyb3dzKQoKICAgIGRlZiBfYXBwbHlfdG9fY3VycmVu"
    "dF9yb3coc2VsZiwgc2hvd19tZXNzYWdlPUZhbHNlKToKICAgICAgICAiIiLtmITsnqwg7ISg7YOd65CcIOyngOygkCDtlonsl5Ag7Lm07Jq07YSwIOyEpOyg"
    "leydhCDsponsi5wg67CY7JiB7ZWY6rOgLAogICAgICAgICfsnoXroKUg6re466O5KO2DrSkn7JeQIOyLpOygnOuhnCDtj6ztlajrkJwg67Cp7Zal67KI7Zi4"
    "66eM7J2EIOq4sOykgOycvOuhnCDrsKntlqXsiJjrpbwg6rOE7IKw7ZWp64uI64ukLgogICAgICAgIOuYkO2VnCwg6re466O567OE66GcIOyEoO2Dne2VnCDs"
    "sKjsooXsnKDtmJUo7ZSE66Gc7KCd7Yq4IOyduOuNseyKpCkg7KCV67O0KGdyb3VwX3Byb2plY3RzKeuKlCDquLDsobQg6rCS7J2EIOycoOyngO2VqeuLiOuL"
    "pC4iIiIKICAgICAgICByID0gc2VsZi50YmwuY3VycmVudFJvdygpCiAgICAgICAgaWYgciA8IDA6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIGNmZyA9"
    "IHNlbGYuX2NvbGxlY3RfdWkoKQogICAgICAgIHJvd19rZXkgPSBzZWxmLl9yb3dfa2V5KHIpCiAgICAgICAgcHJldiA9IHNlbGYuc2l0ZV9kYXRhLmdldChy"
    "b3dfa2V5LCB7fSkgb3Ige30KICAgICAgICAjIOq4sOyhtOyXkCDsoIDsnqXrkJwgZ3JvdXBfcHJvamVjdHMo6re466O567OEIOywqOyiheycoO2YlSDshKDt"
    "g53qsJIp64qUIOycoOyngAogICAgICAgIGlmICJncm91cF9wcm9qZWN0cyIgaW4gcHJldjoKICAgICAgICAgICAgY2ZnWyJncm91cF9wcm9qZWN0cyJdID0g"
    "cHJldi5nZXQoImdyb3VwX3Byb2plY3RzIiwge30pCiAgICAgICAgc2VsZi5zaXRlX2RhdGFbcm93X2tleV0gPSBjZmcKCiAgICAgICAgIyDrsKntlqXsiJgg"
    "PSDsnoXroKXqt7jro7ko7YOtKeyXkCDtj6ztlajrkJwg66qo65OgIOuwqe2WpeuyiO2YuOydmCAi7KKF66WYIOyImCIKICAgICAgICAjICjrgqjsnYAg67Cp"
    "7Zal67KI7Zi4IOumrOyKpO2KuOuKlCDtj6ztlajtlZjsp4Ag7JWK7J2MKQogICAgICAgIGltcG9ydCByZSBhcyBfcmUKCiAgICAgICAgZGlyX251bWJlcnMg"
    "PSBzZXQoKQogICAgICAgIGZvciBsYWJlbCBpbiBjZmcuZ2V0KCJncm91cHMiLCBbXSk6CiAgICAgICAgICAgIGZvciBwYXJ0IGluIF9yZS5zcGxpdChyIlte"
    "MC05XSsiLCBsYWJlbCk6CiAgICAgICAgICAgICAgICBpZiBwYXJ0LmlzZGlnaXQoKToKICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAg"
    "ICAgICAgICAgIGRpcl9udW1iZXJzLmFkZChpbnQocGFydCkpCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAg"
    "ICAgICAgICAgcGFzcwoKICAgICAgICAjIOyeheugpeq3uOujueydtCDtlZjrgpjrj4Qg7JeG64uk66m0LCDsiqTtlYDrsJXsiqQg6rCSKOq4sOuzuCDrsKnt"
    "lqXsiJgp7J2EIOq3uOuMgOuhnCDsgqzsmqkKICAgICAgICBjbnQgPSBsZW4oZGlyX251bWJlcnMpIGlmIGRpcl9udW1iZXJzIGVsc2Ugc2VsZi5zcGluLnZh"
    "bHVlKCkKCiAgICAgICAgZGlyX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShzdHIoY250KSkKICAgICAgICBkaXJfaXRlbS5zZXRUZXh0QWxp"
    "Z25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXIgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQogICAgICAgICMg67Cp7Zal7IiY64qUIO2VreyDgSDsnpDr"
    "j5kg6rOE7IKw65CY66+A66GcIO2OuOynkSDrtojqsIDriqXtlZjqsowg6rOg7KCVCiAgICAgICAgZGlyX2l0ZW0uc2V0RmxhZ3MoZGlyX2l0ZW0uZmxhZ3Mo"
    "KSAmIH5RdENvcmUuUXQuSXRlbUlzRWRpdGFibGUpCiAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShyLCA0LCBkaXJfaXRlbSkKICAgICAgICBpZiBzaG93X21l"
    "c3NhZ2U6CiAgICAgICAgICAgIFF0V2lkZ2V0cy5RTWVzc2FnZUJveC5pbmZvcm1hdGlvbihzZWxmLCAi7KCB7JqpIiwgIuyEoO2DnSDsp4DsoJDsl5Ag7J6F"
    "66Cl6re466O5L+y5tOyatO2EsCDqtazshLHsnbQg7KCA7J6l65CY7JeI7Iq164uI64ukLiIpCiAgICBkZWYgYXBwbHlfdG9fc2VsZWN0ZWQoc2VsZik6CiAg"
    "ICAgICAgIiIiW+uyhO2KvOyaqV0g7ZiE7J6sIOyEoO2DneuQnCDsp4DsoJDsl5Ag7Lm07Jq07YSwIOyEpOygleydhCDsoIDsnqUgKOyVjOumvCDtkZzsi5wp"
    "LiIiIgogICAgICAgIGlmIHNlbGYudGJsLmN1cnJlbnRSb3coKSA8IDA6CiAgICAgICAgICAgIFF0V2lkZ2V0cy5RTWVzc2FnZUJveC5pbmZvcm1hdGlvbihz"
    "ZWxmLCAi7JWM66a8IiwgIuyijOy4oSDsp4DsoJDsnYQg66i87KCAIOyEoO2Dne2VmOyEuOyalC4iKQogICAgICAgICAgICByZXR1cm4KICAgICAgICBzZWxm"
    "Ll9hcHBseV90b19jdXJyZW50X3JvdyhzaG93X21lc3NhZ2U9VHJ1ZSkKCiAgICBkZWYgbW92ZV9zaXRlKHNlbGYsIGRpcmVjdGlvbik6CiAgICAgICAgIiIi"
    "7KeA7KCQIO2WieydhCDsnIQv7JWE656Y66GcIOydtOuPmS4iIiIKICAgICAgICByID0gc2VsZi50YmwuY3VycmVudFJvdygpCiAgICAgICAgaWYgciA8IDA6"
    "CiAgICAgICAgICAgIHJldHVybgogICAgICAgIG5ld19yID0gciArIGRpcmVjdGlvbgogICAgICAgIGlmIG5vdCAoMCA8PSBuZXdfciA8IHNlbGYudGJsLnJv"
    "d0NvdW50KCkpOgogICAgICAgICAgICByZXR1cm4KICAgICAgICAjIO2YhOyerCDtlonsnZgg7Lm07Jq07YSwIOyEpOygleydhCDrqLzsoIAg7KCA7J6lCiAg"
    "ICAgICAgc2VsZi5fYXBwbHlfdG9fY3VycmVudF9yb3coc2hvd19tZXNzYWdlPUZhbHNlKQogICAgICAgICMg7KCE7LK0IOyngOygkOygleuztCArIOy5tOya"
    "tO2EsCDshKTsoJXsnYQg6rCA7KC47JmAIOyInOyEnOulvCDrsJTqvrjqs6Ag64uk7IucIOyEuO2MhQogICAgICAgIHJvd3MgPSBzZWxmLmdldCgpCiAgICAg"
    "ICAgcm93c1tyXSwgcm93c1tuZXdfcl0gPSByb3dzW25ld19yXSwgcm93c1tyXQogICAgICAgIHNlbGYuc2V0KHJvd3MpCiAgICAgICAgIyDsg4gg7JyE7LmY"
    "IO2WieydhCDshKDtg50gJiDtj6zsu6TsiqQg7J2064+ZCiAgICAgICAgdHJ5OgogICAgICAgICAgICBzZWxmLnRibC5zZXRDdXJyZW50Q2VsbChuZXdfciwg"
    "MCkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBzZWxmLnRibC5zZWxlY3RSb3cobmV3X3IpCiAg"
    "ICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICBwYXNzCgoKICAgIGRlZiBtb3ZlX3NpdGVfdG9wKHNlbGYpOgogICAgICAgICIi"
    "IuyEoO2DneuQnCDsp4DsoJAg7ZaJ7J2EIOy1nOyDgeuLqCgx67KIIO2WiSnsnLzroZwg7J2064+ZLiIiIgogICAgICAgIHIgPSBzZWxmLnRibC5jdXJyZW50"
    "Um93KCkKICAgICAgICBpZiByIDw9IDA6CiAgICAgICAgICAgIHJldHVybgogICAgICAgICMg7ZiE7J6sIO2WieydmCDsubTsmrTthLAg7ISk7KCV7J2EIOuo"
    "vOyggCDsoIDsnqUKICAgICAgICBzZWxmLl9hcHBseV90b19jdXJyZW50X3JvdyhzaG93X21lc3NhZ2U9RmFsc2UpCiAgICAgICAgcm93cyA9IHNlbGYuZ2V0"
    "KCkKICAgICAgICBpZiBub3QgKDAgPD0gciA8IGxlbihyb3dzKSk6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIHJvdyA9IHJvd3MucG9wKHIpCiAgICAg"
    "ICAgcm93cy5pbnNlcnQoMCwgcm93KQogICAgICAgIHNlbGYuc2V0KHJvd3MpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBzZWxmLnRibC5zZXRDdXJyZW50"
    "Q2VsbCgwLCAwKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHNlbGYudGJsLnNlbGVjdFJvdygw"
    "KQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgcGFzcwoKICAgICMgLS0tLS0tLS0tLSDsoIDsnqUv67O17JuQIC0tLS0t"
    "LS0tLS0KICAgIGRlZiBnZXQoc2VsZik6CiAgICAgICAgIiIi7KeA7KCQ7KCV67O0ICsg7Lm07Jq07YSwIOyEpOygleq5jOyngCDrqqjrkZAg7KCA7J6lIiIi"
    "CiAgICAgICAgIyDtmITsnqwg7ISg7YOd65CcIOyngOygkOydmCDstZzsi6Ag7Y647KeRIOuCtOyaqeydhCBzaXRlX2RhdGHsl5Ag67CY7JiBCiAgICAgICAg"
    "dHJ5OgogICAgICAgICAgICBzZWxmLl9hcHBseV90b19jdXJyZW50X3JvdyhGYWxzZSkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICBw"
    "YXNzCiAgICAgICAgb3V0ID0gW10KICAgICAgICBmb3IgciBpbiByYW5nZShzZWxmLnRibC5yb3dDb3VudCgpKToKICAgICAgICAgICAgZGVmIF90ZXh0KGNv"
    "bCk6CiAgICAgICAgICAgICAgICBpdGVtID0gc2VsZi50YmwuaXRlbShyLCBjb2wpCiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50ZXh0KCkuc3RyaXAo"
    "KSBpZiBpdGVtIGVsc2UgIiIKICAgICAgICAgICAga2V5ID0gc2VsZi5fcm93X2tleShyKQogICAgICAgICAgICBjZmcgPSBzZWxmLnNpdGVfZGF0YS5nZXQo"
    "a2V5LCB7Imdyb3VwcyI6IFtdLCAiY291bnRlcnMiOiBbXX0pCiAgICAgICAgICAgIHJlYyA9IHsKICAgICAgICAgICAgICAgICLsiJzrsogiOiByICsgMSwK"
    "ICAgICAgICAgICAgICAgICLsp4DrsogiOiBfdGV4dCgxKSwKICAgICAgICAgICAgICAgICLsp4DsoJDrqoUiOiBfdGV4dCgyKSwKICAgICAgICAgICAgICAg"
    "ICLsnpHsl4XrsojtmLgiOiBfdGV4dCgzKSwKICAgICAgICAgICAgICAgICLrsKntlqXsiJgiOiBfdGV4dCg0KSwKICAgICAgICAgICAgICAgICLsg4Htg5wi"
    "OiBfdGV4dCg1KSwKICAgICAgICAgICAgICAgICJncm91cHMiOiBjZmcuZ2V0KCJncm91cHMiLCBbXSksCiAgICAgICAgICAgICAgICAiY291bnRlcnMiOiBj"
    "ZmcuZ2V0KCJjb3VudGVycyIsIFtdKSwKICAgICAgICAgICAgfQogICAgICAgICAgICBvdXQuYXBwZW5kKHJlYykKICAgICAgICByZXR1cm4gb3V0CgogICAg"
    "ZGVmIHNldChzZWxmLCByb3dzKToKICAgICAgICAiIiLsoIDsnqXrkJwg7KeA7KCQ7KCV67O0IOuzteybkCIiIgogICAgICAgIHNlbGYudGJsLnNldFJvd0Nv"
    "dW50KDApCiAgICAgICAgc2VsZi5zaXRlX2RhdGEgPSB7fQogICAgICAgIHJvd3MgPSByb3dzIG9yIFtdCiAgICAgICAgZm9yIHIsIHJvdyBpbiBlbnVtZXJh"
    "dGUocm93cyk6CiAgICAgICAgICAgIHNlbGYudGJsLmluc2VydFJvdyhzZWxmLnRibC5yb3dDb3VudCgpKQogICAgICAgICAgICAjIOyInOuyiCAo7Y647KeR"
    "IOu2iOqwgCkKICAgICAgICAgICAgbnVtX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShzdHIociArIDEpKQogICAgICAgICAgICBudW1faXRl"
    "bS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXIgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQogICAgICAgICAgICBudW1faXRlbS5z"
    "ZXRGbGFncyhudW1faXRlbS5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNFZGl0YWJsZSkKICAgICAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShyLCAwLCBu"
    "dW1faXRlbSkKICAgICAgICAgICAgIyDsp4DrsoggKOqwgOyatOuNsCDsoJXroKwpIC8g7KeA7KCQ66qFIC8g7J6R7JeF67KI7Zi4IC8g67Cp7Zal7IiYIC8g"
    "7IOB7YOcCiAgICAgICAgICAgIGppYnVuX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShzdHIocm93LmdldCgi7KeA67KIIiwgIiIpKSkKICAg"
    "ICAgICAgICAgamlidW5faXRlbS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXIgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQogICAg"
    "ICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsIDEsIGppYnVuX2l0ZW0pCiAgICAgICAgICAgIG5hbWVfaXRlbSA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJ"
    "dGVtKHN0cihyb3cuZ2V0KCLsp4DsoJDrqoUiLCAiIikpKQogICAgICAgICAgICBuYW1lX2l0ZW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUuUXQuQWxpZ25I"
    "Q2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShyLCAyLCBuYW1lX2l0ZW0pCiAgICAgICAgICAg"
    "IGpvYl9pdGVtID0gUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oc3RyKHJvdy5nZXQoIuyekeyXheuyiO2YuCIsICIiKSkpCiAgICAgICAgICAgIGpvYl9p"
    "dGVtLnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlciB8IFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAgICAgIGpvYl9pdGVt"
    "LnNldEZsYWdzKGpvYl9pdGVtLmZsYWdzKCkgJiB+UXRDb3JlLlF0Lkl0ZW1Jc0VkaXRhYmxlKQogICAgICAgICAgICBzZWxmLnRibC5zZXRJdGVtKHIsIDMs"
    "IGpvYl9pdGVtKQogICAgICAgICAgICBkaXJfaXRlbSA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKHN0cihyb3cuZ2V0KCLrsKntlqXsiJgiLCAiIikp"
    "KQogICAgICAgICAgICBkaXJfaXRlbS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkhDZW50ZXIgfCBRdENvcmUuUXQuQWxpZ25WQ2VudGVyKQog"
    "ICAgICAgICAgICBkaXJfaXRlbS5zZXRGbGFncyhkaXJfaXRlbS5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNFZGl0YWJsZSkKICAgICAgICAgICAgc2Vs"
    "Zi50Ymwuc2V0SXRlbShyLCA0LCBkaXJfaXRlbSkKICAgICAgICAgICAgc3RhdGVfaXRlbSA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKHN0cihyb3cu"
    "Z2V0KCLsg4Htg5wiLCAiIikpKQogICAgICAgICAgICBzdGF0ZV9pdGVtLnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduSENlbnRlciB8IFF0Q29y"
    "ZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAgICAgIHN0YXRlX2l0ZW0uc2V0RmxhZ3Moc3RhdGVfaXRlbS5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNF"
    "ZGl0YWJsZSkKICAgICAgICAgICAgc2VsZi5fYXBwbHlfc3RhdGVfY29sb3Ioc3RhdGVfaXRlbSkKICAgICAgICAgICAgc2VsZi50Ymwuc2V0SXRlbShyLCA1"
    "LCBzdGF0ZV9pdGVtKQoKICAgICAgICAgICAgIyDsubTsmrTthLAg6rWs7ISxIOuzteybkOyaqSDrqZTrqqjrpqwKICAgICAgICAgICAgc2VsZi5zaXRlX2Rh"
    "dGFbc2VsZi5fcm93X2tleShyKV0gPSB7CiAgICAgICAgICAgICAgICAiZ3JvdXBzIjogcm93LmdldCgiZ3JvdXBzIiwgW10pLAogICAgICAgICAgICAgICAg"
    "ImNvdW50ZXJzIjogcm93LmdldCgiY291bnRlcnMiLCBbXSksCiAgICAgICAgICAgIH0KCiAgICAjIC0tLS0tLS0tLS0g7Iuc7Yq4IOuvuOumrOuztOq4sCAt"
    "LS0tLS0tLS0tCiAgICBkZWYgcHJldmlldyhzZWxmKToKICAgICAgICAiIiLsp4DsoJDsoJXrs7Qg7Iuc7Yq4IOuvuOumrOuztOq4sCAo67Cp7Zal67OEKS4K"
    "ICAgICAgICDqsIEg67Cp7Zal7JeQIOuMgO2VtCwg7ZW064u5IOuwqe2WpeyXkCDsl7DqsrDrkJwg64uo7LaV7YKkIOyLnO2KuOqwgCDsnojsnLzrqbQKICAg"
    "ICAgICDqt7gg7Iuc7Yq47J2YIOywqOyiheuqheydhCDsl7Qg7KCc66qp7Jy866GcIOyCrOyaqe2VqeuLiOuLpC4KICAgICAgICAo7JeG7Jy866m0IO2UhOuh"
    "nOygne2KuCDquLDrs7gg7LCo7KKF66qF7J2EIOyCrOyaqSkKICAgICAgICAiIiIKICAgICAgICAjIOyLnOqwhOuMgOuKlCDsobDsgqzsi5zqsIQg7YOt7JeQ"
    "7IScIOqwgOyguOyYtAogICAgICAgIHRyeToKICAgICAgICAgICAgdGltZXMgPSBzZWxmLnBhZ2UudGltZS5nZXQoKQogICAgICAgIGV4Y2VwdCBFeGNlcHRp"
    "b246CiAgICAgICAgICAgIHRpbWVzID0gW10KCiAgICAgICAgIyDtmITsnqwg7ISg7YOd65CcIOyngOygkOydmCDqt7jro7kv7Lm07Jq07YSwIOygleuztAog"
    "ICAgICAgIGNmZyA9IHt9CiAgICAgICAgciA9IHNlbGYudGJsLmN1cnJlbnRSb3coKQogICAgICAgIGlmIHIgPj0gMDoKICAgICAgICAgICAgY2ZnID0gc2Vs"
    "Zi5zaXRlX2RhdGEuZ2V0KHNlbGYuX3Jvd19rZXkociksIHt9KQogICAgICAgICAgICBncm91cHMgPSBjZmcuZ2V0KCJncm91cHMiKSBvciBbIjEiXQogICAg"
    "ICAgICAgICBjb3VudGVyX2NmZyA9IGNmZy5nZXQoImNvdW50ZXJzIikgb3IgW10KICAgICAgICBlbHNlOgogICAgICAgICAgICBncm91cHMgPSBbIjEiXQog"
    "ICAgICAgICAgICBjb3VudGVyX2NmZyA9IFtdCgogICAgICAgICMg67Cp7Zal67OE66GcIOyXsOqysOuQnCDri6jstpXtgqQg7Iuc7Yq4IOydtOumhCDrp6Tt"
    "lZE6IHvrsKntlqXrsojtmLg6IOyLnO2KuOydtOumhH0KICAgICAgICBkaXJfdG9fc2hlZXQgPSB7fQogICAgICAgIGZvciByZWMgaW4gY291bnRlcl9jZmc6"
    "CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGRfc3RyID0gc3RyKHJlYy5nZXQoImRpciIsICIiKSkuc3RyaXAoKQogICAgICAgICAgICAgICAg"
    "c2hlZXRfbmFtZSA9IHN0cihyZWMuZ2V0KCJuYW1lIiwgIiIpKS5zdHJpcCgpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAg"
    "ICBjb250aW51ZQogICAgICAgICAgICBpZiBub3QgZF9zdHIgb3Igbm90IHNoZWV0X25hbWU6CiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAg"
    "ICBpZiBub3QgZF9zdHIuaXNkaWdpdCgpOgogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgZF92YWwg"
    "PSBpbnQoZF9zdHIpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICBpZiBzaGVldF9u"
    "YW1lOgogICAgICAgICAgICAgICAgZGlyX3RvX3NoZWV0W2RfdmFsXSA9IHNoZWV0X25hbWUKCiAgICAgICAgIyDqt7jro7kg66y47J6Q7Je0KOyYiDogIjQt"
    "NS02IiwgIjctOC05Iinsl5DshJwg7Iuk7KCcIOyCrOyaqe2VmOuKlCDrsKntlqXrsojtmLjrp4wg7LaU7LacCiAgICAgICAgaW1wb3J0IHJlIGFzIF9yZQog"
    "ICAgICAgIGRpcl9udW1iZXJzID0gc2V0KCkKICAgICAgICBmb3IgbGFiZWwgaW4gZ3JvdXBzOgogICAgICAgICAgICBmb3IgcGFydCBpbiBfcmUuc3BsaXQo"
    "ciJbXjAtOV0rIiwgc3RyKGxhYmVsKSk6CiAgICAgICAgICAgICAgICBpZiBwYXJ0LmlzZGlnaXQoKToKICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAg"
    "ICAgICAgICAgICAgICAgICAgIGRpcl9udW1iZXJzLmFkZChpbnQocGFydCkpCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAg"
    "ICAgICAgICAgICAgICAgICAgcGFzcwoKICAgICAgICBpZiBkaXJfbnVtYmVyczoKICAgICAgICAgICAgZGlyX2xpc3QgPSBzb3J0ZWQoZGlyX251bWJlcnMp"
    "CiAgICAgICAgZWxzZToKICAgICAgICAgICAgIyDqt7jro7kg7KCV67O06rCAIOu5hOyWtCDsnojripQg6rK97JqwIDHrsogg67Cp7Zal66eMIOyhtOyerO2V"
    "nOuLpOqzoCDqsIDsoJUKICAgICAgICAgICAgZGlyX2xpc3QgPSBbMV0KCiAgICAgICAgIyDtlITroZzsoJ3tirgv7LCo7KKFL+uLqOy2le2CpCDsi5ztirgg"
    "7KCV67O0CiAgICAgICAgZGF0YSA9IGdldGF0dHIoc2VsZi5wYWdlLCAiZGF0YSIsIHt9KSBpZiBoYXNhdHRyKHNlbGYucGFnZSwgImRhdGEiKSBlbHNlIHt9"
    "CiAgICAgICAgcHJvamVjdHMgPSBkYXRhLmdldCgicHJvamVjdHMiLCBbXSkgaWYgaXNpbnN0YW5jZShkYXRhLCBkaWN0KSBlbHNlIFtdCgogICAgICAgICMg"
    "7ZiE7J6sIOyngOygkOydmCBncm91cF9wcm9qZWN0cyjqt7jro7nrs4Qg7LCo7KKF7Jyg7ZiVIOyduOuNseyKpCnsl5DshJwg67Cp7Zal67OEIO2UhOuhnOyg"
    "ne2KuCDsnbjrjbHsiqTrpbwg6rOE7IKwCiAgICAgICAgZGlyX3RvX3Byb2pfaW5kZXggPSB7fQogICAgICAgIGdyb3VwX3Byb2plY3RzID0gY2ZnLmdldCgi"
    "Z3JvdXBfcHJvamVjdHMiLCB7fSkgb3Ige30KICAgICAgICBmb3IgZ3JwX2xhYmVsLCBwX2lkeCBpbiBncm91cF9wcm9qZWN0cy5pdGVtcygpOgogICAgICAg"
    "ICAgICB0cnk6CiAgICAgICAgICAgICAgICBwX2lkeF9pbnQgPSBpbnQocF9pZHgpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAg"
    "ICAgICBjb250aW51ZQogICAgICAgICAgICBmb3IgcGFydCBpbiBfcmUuc3BsaXQociJbXjAtOV0rIiwgc3RyKGdycF9sYWJlbCkpOgogICAgICAgICAgICAg"
    "ICAgaWYgcGFydC5pc2RpZ2l0KCk6CiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICBkX3ZhbCA9IGludChwYXJ0KQog"
    "ICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICAgICAg"
    "ZGlyX3RvX3Byb2pfaW5kZXhbZF92YWxdID0gcF9pZHhfaW50CgogICAgICAgIGRlZiBfZGVmYXVsdF9jb2xzX2Zvcl9kaXJlY3Rpb24oZCk6CiAgICAgICAg"
    "ICAgICIiIu2VtOuLuSDrsKntlqXsnZgg6riw67O4IOywqOyihSDsl7Qg66qp66Gd7J2EIOuwmO2ZmCAo64uo7LaV7YKkIOyLnO2KuOqwgCDsl4bsnYQg65WM"
    "IOyCrOyaqSkuIiIiCiAgICAgICAgICAgIGlmIG5vdCBwcm9qZWN0czoKICAgICAgICAgICAgICAgIHJldHVybiBbIuywqOyihTEiLCAi7LCo7KKFMiJdCiAg"
    "ICAgICAgICAgIHByb2pfaWR4ID0gZGlyX3RvX3Byb2pfaW5kZXguZ2V0KGQsIE5vbmUpCiAgICAgICAgICAgICMg7KCA7J6l65CcIOqwkuydtCDsl4bsnLzr"
    "qbQg7KGw7IKs7LCo7KKFIO2DreydmCDtmITsnqwg7ISg7YOd6rCS7J2EIOyCrOyaqQogICAgICAgICAgICBpZiBwcm9qX2lkeCBpcyBOb25lOgogICAgICAg"
    "ICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIHZlaF90YWIgPSBnZXRhdHRyKHNlbGYucGFnZSwgInZlaCIsIE5vbmUpCiAgICAgICAgICAgICAg"
    "ICAgICAgaWYgdmVoX3RhYiBpcyBub3QgTm9uZSBhbmQgaGFzYXR0cih2ZWhfdGFiLCAiY2IiKToKICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gdmVo"
    "X3RhYi5jYi5jdXJyZW50SW5kZXgoKQogICAgICAgICAgICAgICAgICAgICAgICBpZiAwIDw9IGlkeCA8IGxlbihwcm9qZWN0cyk6CiAgICAgICAgICAgICAg"
    "ICAgICAgICAgICAgICBwcm9qX2lkeCA9IGlkeAogICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICBwcm9qX2lk"
    "eCA9IE5vbmUKICAgICAgICAgICAgaWYgcHJval9pZHggaXMgTm9uZToKICAgICAgICAgICAgICAgIHByb2pfaWR4ID0gMAogICAgICAgICAgICBpZiBub3Qg"
    "KDAgPD0gcHJval9pZHggPCBsZW4ocHJvamVjdHMpKToKICAgICAgICAgICAgICAgIHByb2pfaWR4ID0gMAogICAgICAgICAgICBwcm9qX2xvY2FsID0gcHJv"
    "amVjdHNbcHJval9pZHhdCiAgICAgICAgICAgIHZlaGljbGVfcm93cyA9IHByb2pfbG9jYWwuZ2V0KCJ2ZWhpY2xlX3NldCIpIG9yIFtdCiAgICAgICAgICAg"
    "IGNvbHMgPSBbdi5nZXQoIuywqOyiheuqhSIsICIiKSBmb3IgdiBpbiB2ZWhpY2xlX3Jvd3NdCiAgICAgICAgICAgIHJldHVybiBjb2xzIG9yIFsi7LCo7KKF"
    "MSIsICLssKjsooUyIl0KCiAgICAgICAgZGVmIF9jb2xzX2Zvcl9kaXJlY3Rpb24oZCk6CiAgICAgICAgICAgICIiIu2VtOuLuSDrsKntlqXsl5Ag7Jew6rKw"
    "65CcIOuLqOy2le2CpCDsi5ztirjqsIAg7J6I7Jy866m0IOq3uCDsi5ztirjsnZgg7LCo7KKF66qF7J2EIOyCrOyaqe2VmOqzoCwKICAgICAgICAgICAg6re4"
    "66CH7KeAIOyViuycvOuptCBncm91cF9wcm9qZWN0cy/sobDsgqzssKjsooUg7ISk7KCV7JeQIOuUsOuluCDquLDrs7gg7LCo7KKF66qF7J2EIOyCrOyaqe2V"
    "nOuLpC4iIiIKICAgICAgICAgICAgc2hlZXRfbmFtZSA9IGRpcl90b19zaGVldC5nZXQoZCkKICAgICAgICAgICAgaWYgc2hlZXRfbmFtZSBhbmQgcHJvamVj"
    "dHM6CiAgICAgICAgICAgICAgICAjIOuqqOuToCDtlITroZzsoJ3tirjsl5DshJwg7Iuc7Yq466W8IOywvuyVhOuzuOuLpC4KICAgICAgICAgICAgICAgIGZv"
    "ciBwcm9qX2xvY2FsIGluIHByb2plY3RzOgogICAgICAgICAgICAgICAgICAgIHNoZWV0cyA9IHByb2pfbG9jYWwuZ2V0KCJob3RrZXlfc2hlZXRzX2dsb2Jh"
    "bCIpIG9yIFtdCiAgICAgICAgICAgICAgICAgICAgZm9yIHMgaW4gc2hlZXRzOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBzdHIocy5nZXQoIm5hbWUi"
    "LCAiIikpLnN0cmlwKCkgPT0gc2hlZXRfbmFtZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gcy5nZXQoIml0ZW1zIikgb3IgW10KICAg"
    "ICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHMgPSBbc3RyKGl0LmdldCgi7LCo7KKF66qFIiwgIiIpKSBmb3IgaXQgaW4gaXRlbXNdCiAgICAgICAgICAg"
    "ICAgICAgICAgICAgICAgICBpZiBjb2xzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xzCiAgICAgICAgICAgICMg7JeG7Jy8"
    "66m0IO2UhOuhnOygne2KuCDquLDrs7gg7LCo7KKF66qF7J2EIOyCrOyaqQogICAgICAgICAgICByZXR1cm4gX2RlZmF1bHRfY29sc19mb3JfZGlyZWN0aW9u"
    "KGQpCgogICAgICAgIGRsZyA9IFF0V2lkZ2V0cy5RRGlhbG9nKHNlbGYpCiAgICAgICAgZGxnLnNldFdpbmRvd1RpdGxlKCLsi5ztirgg67O06riwIikKCiAg"
    "ICAgICAgbGF5ID0gUXRXaWRnZXRzLlFWQm94TGF5b3V0KGRsZykKICAgICAgICB0aXRsZV9sYWJlbCA9IFF0V2lkZ2V0cy5RTGFiZWwoIuyngOygkOygleuz"
    "tCDsi5ztirgg66+466as67O06riwICjrsKntlqXrs4QpIikKICAgICAgICB0aXRsZV9sYWJlbC5zZXRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduTGVmdCB8"
    "IFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAgZm9udCA9IHRpdGxlX2xhYmVsLmZvbnQoKQogICAgICAgIGZvbnQuc2V0Qm9sZChUcnVlKQogICAg"
    "ICAgIHRpdGxlX2xhYmVsLnNldEZvbnQoZm9udCkKICAgICAgICBsYXkuYWRkV2lkZ2V0KHRpdGxlX2xhYmVsKQoKICAgICAgICB0YWJzID0gUXRXaWRnZXRz"
    "LlFUYWJXaWRnZXQoKQogICAgICAgIGxheS5hZGRXaWRnZXQodGFicywgMSkKCiAgICAgICAgIyDqsIEgIuyeheugpeq3uOujuSLsnbQg7JWE64uI6528IOyL"
    "pOygnCDrsKntlqXrsojtmLjrs4TroZwg7Iuc7Yq466W8IOq1rOyEsQogICAgICAgIGZvciBkIGluIGRpcl9saXN0OgogICAgICAgICAgICBjb2xzID0gX2Nv"
    "bHNfZm9yX2RpcmVjdGlvbihkKQogICAgICAgICAgICB0YmwgPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0KGxlbih0aW1lcyksIDEgKyBsZW4oY29scykgKyAx"
    "KQogICAgICAgICAgICB0Ymwuc2V0SG9yaXpvbnRhbEhlYWRlckxhYmVscyhbIuyLnOqwhOuMgCJdICsgY29scyArIFsiIl0pCiAgICAgICAgICAgIHRibC5o"
    "b3Jpem9udGFsSGVhZGVyKCkuc2V0U3RyZXRjaExhc3RTZWN0aW9uKFRydWUpCiAgICAgICAgICAgIHRibC52ZXJ0aWNhbEhlYWRlcigpLnNldFZpc2libGUo"
    "RmFsc2UpCgogICAgICAgICAgICBmb3IgaSwgcm93IGluIGVudW1lcmF0ZSh0aW1lcyk6CiAgICAgICAgICAgICAgICBsYWJlbCA9IGYie3Jvdy5nZXQoJ+yL"
    "nOyekScsJycpfX57cm93LmdldCgn7KKF66OMJywnJyl9IgogICAgICAgICAgICAgICAgaXQgPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShsYWJlbCkK"
    "ICAgICAgICAgICAgICAgIGl0LnNldFRleHRBbGlnbm1lbnQoUXRDb3JlLlF0LkFsaWduTGVmdCB8IFF0Q29yZS5RdC5BbGlnblZDZW50ZXIpCiAgICAgICAg"
    "ICAgICAgICB0Ymwuc2V0SXRlbShpLCAwLCBpdCkKCiAgICAgICAgICAgICAgICBmb3IgYyBpbiByYW5nZShsZW4oY29scykpOgogICAgICAgICAgICAgICAg"
    "ICAgIG51bSA9IFF0V2lkZ2V0cy5RVGFibGVXaWRnZXRJdGVtKCIwIikKICAgICAgICAgICAgICAgICAgICBudW0uc2V0VGV4dEFsaWdubWVudChRdENvcmUu"
    "UXQuQWxpZ25IQ2VudGVyIHwgUXRDb3JlLlF0LkFsaWduVkNlbnRlcikKICAgICAgICAgICAgICAgICAgICB0Ymwuc2V0SXRlbShpLCAxICsgYywgbnVtKQoK"
    "ICAgICAgICAgICAgICAgIGJsYW5rID0gUXRXaWRnZXRzLlFUYWJsZVdpZGdldEl0ZW0oIiIpCiAgICAgICAgICAgICAgICBibGFuay5zZXRGbGFncyhibGFu"
    "ay5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNFZGl0YWJsZSkKICAgICAgICAgICAgICAgIHRibC5zZXRJdGVtKGksIDEgKyBsZW4oY29scyksIGJsYW5r"
    "KQoKICAgICAgICAgICAgdGFicy5hZGRUYWIodGJsLCBmIntkfeuyiCDrsKntlqUiKQoKICAgICAgICBidG4gPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIuuL"
    "q+q4sCIpCiAgICAgICAgbGF5LmFkZFdpZGdldChidG4sIDAsIGFsaWdubWVudD1RdENvcmUuUXQuQWxpZ25SaWdodCkKICAgICAgICBidG4uY2xpY2tlZC5j"
    "b25uZWN0KGRsZy5hY2NlcHQpCiAgICAgICAgZGxnLnJlc2l6ZSgxMTAwLCA2ODApCiAgICAgICAgZGxnLmV4ZWNfKCkKCgoKY2xhc3MgU3VydmV5TWFuYWdl"
    "clBhZ2UoUXRXaWRnZXRzLlFXaWRnZXQpOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIGRhdGEsIHBhcmVudD1Ob25lKToKICAgICAgICBzdXBlcigpLl9faW5p"
    "dF9fKHBhcmVudCk7IHNlbGYuZGF0YT1kYXRhCiAgICAgICAgaD1RdFdpZGdldHMuUUhCb3hMYXlvdXQoc2VsZikKICAgICAgICBsZWZ0PVF0V2lkZ2V0cy5R"
    "VkJveExheW91dCgpOyBzZWxmLmxzdD1RdFdpZGdldHMuUUxpc3RXaWRnZXQoKTsKICAgICAgICBzZWxmLmxzdC5zZXRGaXhlZFdpZHRoKDIyMCkKICAgICAg"
    "ICBzZWxmLmxzdC5zZXRNaW5pbXVtV2lkdGgoMjIwKQogICAgICAgIHNlbGYubHN0LnNldE1heGltdW1XaWR0aCgyMjApCiAgICAgICAgbGVmdC5hZGRXaWRn"
    "ZXQoc2VsZi5sc3QsMSkKICAgICAgICAjIEFkZCBoZWFkZXIgbGFiZWwgYWJvdmUgdGhlIGxpc3QgYXMgcmVxdWVzdGVkICgi6rO87JeF66qFIikKICAgICAg"
    "ICB0cnk6CiAgICAgICAgICAgIGxlZnQuaW5zZXJ0V2lkZ2V0KDAsIFF0V2lkZ2V0cy5RTGFiZWwoIuqzvOyXheuqhSIpKQogICAgICAgIGV4Y2VwdCBFeGNl"
    "cHRpb246CiAgICAgICAgICAgIHBhc3MKICAgICAgICBoYj1RdFdpZGdldHMuUUhCb3hMYXlvdXQoKTsgc2VsZi5iX25ldz1RdFdpZGdldHMuUVB1c2hCdXR0"
    "b24oIuyDiOyhsOyCrCIpOyBzZWxmLmJfZHVwPVF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi67O17KCcIik7IHNlbGYuYl9kZWw9UXRXaWRnZXRzLlFQdXNoQnV0"
    "dG9uKCLsgq3soJwiKQogICAgICAgIGZvciBiIGluIChzZWxmLmJfbmV3LHNlbGYuYl9kdXAsc2VsZi5iX2RlbCk6IGhiLmFkZFdpZGdldChiKQogICAgICAg"
    "IGxlZnQuYWRkTGF5b3V0KGhiKTsgaC5hZGRMYXlvdXQobGVmdCwxKQogICAgICAgIHNlbGYudGFicz1RdFdpZGdldHMuUVRhYldpZGdldCgpCiAgICAgICAg"
    "c2VsZi5pbmZvPVN1cnZleUluZm9UYWIoc2VsZik7IHNlbGYudGltZT1TdXJ2ZXlUaW1lVGFiKHNlbGYpOyBzZWxmLnZlaD1TdXJ2ZXlWZWhpY2xlVGFiKHNl"
    "bGYpOyBzZWxmLnNpdGVzPVN1cnZleVNpdGVzVGFiKHNlbGYpCiAgICAgICAgc2VsZi50YWJzLmFkZFRhYihzZWxmLmluZm8sIuyhsOyCrCDsoJXrs7QiKTsg"
    "c2VsZi50YWJzLmFkZFRhYihzZWxmLnRpbWUsIuyhsOyCrOyLnOqwhCDshKTsoJUiKTsgc2VsZi50YWJzLmFkZFRhYihzZWxmLnZlaCwi7KGw7IKs7LCo7KKF"
    "IOyEpOyglSIpOyBzZWxmLnRhYnMuYWRkVGFiKHNlbGYuc2l0ZXMsIuyhsOyCrOyngOygkCDshKTsoJUiKQogICAgICAgIGJveD1RdFdpZGdldHMuUVZCb3hM"
    "YXlvdXQoKTsgYm94LmFkZFdpZGdldChzZWxmLnRhYnMsMSk7IGI9UXRXaWRnZXRzLlFIQm94TGF5b3V0KCk7IGIuYWRkU3RyZXRjaCgxKTsgc2VsZi5iX3Jl"
    "Zz1RdFdpZGdldHMuUVB1c2hCdXR0b24oIuuTseuhnSIpOyBzZWxmLmJfc2F2ZT1RdFdpZGdldHMuUVB1c2hCdXR0b24oIuyggOyepSIpOyBiLmFkZFdpZGdl"
    "dChzZWxmLmJfcmVnKTsgYi5hZGRXaWRnZXQoc2VsZi5iX3NhdmUpOyBib3guYWRkTGF5b3V0KGIpOyBoLmFkZExheW91dChib3gsMykKICAgICAgICBzZWxm"
    "LmJfbmV3LmNsaWNrZWQuY29ubmVjdChzZWxmLmFkZF9zdXJ2ZXkpOyBzZWxmLmJfZHVwLmNsaWNrZWQuY29ubmVjdChzZWxmLmR1cF9zdXJ2ZXkpOyBzZWxm"
    "LmJfZGVsLmNsaWNrZWQuY29ubmVjdChzZWxmLmRlbF9zdXJ2ZXkpOyBzZWxmLmJfc2F2ZS5jbGlja2VkLmNvbm5lY3Qoc2VsZi5wZXJzaXN0X2N1cnJlbnQp"
    "OyBzZWxmLmxzdC5jdXJyZW50Um93Q2hhbmdlZC5jb25uZWN0KHNlbGYubG9hZF9jdXJyZW50KTsgc2VsZi5sc3QuaXRlbURvdWJsZUNsaWNrZWQuY29ubmVj"
    "dChzZWxmLnJlbmFtZV9zdXJ2ZXkpCiAgICAgICAgc2VsZi5yZWxvYWRfbGlzdCgpCgogICAgZGVmIHN1cnZleXMoc2VsZik6IHJldHVybiBzZWxmLmRhdGFb"
    "InN1cnZleXMiXQogICAgZGVmIHJlbG9hZF9saXN0KHNlbGYsIHByZWZlcnJlZF9pbmRleD1Ob25lKToKICAgICAgICBzZWxmLmxzdC5jbGVhcigpOyAKICAg"
    "ICAgICBmb3IgcyBpbiBzZWxmLnN1cnZleXMoKToKICAgICAgICAgICAgaW5mbyA9IHMuZ2V0KCJpbmZvIiwge30pCiAgICAgICAgICAgIG5hbWUgPSBpbmZv"
    "LmdldCgibmFtZSIsIijsoJzrqqkg7JeG7J2MKSIpCiAgICAgICAgICAgIHN0YXRlID0gaW5mby5nZXQoInN0YXRlIiwi64yA6riwIikKICAgICAgICAgICAg"
    "aXRlbSA9IFF0V2lkZ2V0cy5RTGlzdFdpZGdldEl0ZW0obmFtZSkKICAgICAgICAgICAgIyDqs7zsl4XrqoUg66as7Iqk7Yq4IOynhO2WieyDge2DnCDsg4ns"
    "g4E6IOuMgOq4sD3qsoDsoJUsIOynhO2WiT3tjIzrnpEsIOyZhOujjD3sl7Dtmozsg4kKICAgICAgICAgICAgY29sb3JfbWFwID0geyLrjIDquLAiOiBRdEd1"
    "aS5RQ29sb3IoImJsYWNrIiksICLsp4TtlokiOiBRdEd1aS5RQ29sb3IoImJsdWUiKSwgIuyZhOujjCI6IFF0R3VpLlFDb2xvcigibGlnaHRncmF5Iil9CiAg"
    "ICAgICAgICAgIGl0ZW0uc2V0Rm9yZWdyb3VuZChjb2xvcl9tYXAuZ2V0KHN0YXRlLCBRdEd1aS5RQ29sb3IoImJsYWNrIikpKQogICAgICAgICAgICBzZWxm"
    "LmxzdC5hZGRJdGVtKGl0ZW0pCiAgICAgICAgaWYgc2VsZi5sc3QuY291bnQoKToKICAgICAgICAgICAgaWYgcHJlZmVycmVkX2luZGV4IGlzIE5vbmU6CiAg"
    "ICAgICAgICAgICAgICBwcmVmZXJyZWRfaW5kZXggPSAwCiAgICAgICAgICAgIHByZWZlcnJlZF9pbmRleCA9IG1heCgwLCBtaW4ocHJlZmVycmVkX2luZGV4"
    "LCBzZWxmLmxzdC5jb3VudCgpLTEpKQogICAgICAgICAgICBzZWxmLmxzdC5zZXRDdXJyZW50Um93KHByZWZlcnJlZF9pbmRleCkKCiAgICBkZWYgY3VycmVu"
    "dChzZWxmKToKICAgICAgICBpPXNlbGYubHN0LmN1cnJlbnRSb3coKQogICAgICAgIHJldHVybiBzZWxmLnN1cnZleXMoKVtpXSBpZiAwPD1pPGxlbihzZWxm"
    "LnN1cnZleXMoKSkgZWxzZSBOb25lCgogICAgZGVmIHJlbmFtZV9zdXJ2ZXkoc2VsZiwgaXRlbT1Ob25lKToKICAgICAgICBpZiBpdGVtIGlzIE5vbmU6CiAg"
    "ICAgICAgICAgIGl0ZW0gPSBzZWxmLmxzdC5jdXJyZW50SXRlbSgpCiAgICAgICAgaWYgbm90IGl0ZW06CiAgICAgICAgICAgIHJldHVybgogICAgICAgIGN1"
    "cl9pbmRleCA9IHNlbGYubHN0LmN1cnJlbnRSb3coKQogICAgICAgIGlmIG5vdCAoMCA8PSBjdXJfaW5kZXggPCBsZW4oc2VsZi5zdXJ2ZXlzKCkpKToKICAg"
    "ICAgICAgICAgcmV0dXJuCiAgICAgICAgaW5mbyA9IHNlbGYuc3VydmV5cygpW2N1cl9pbmRleF0uc2V0ZGVmYXVsdCgiaW5mbyIsIHt9KQogICAgICAgIG9s"
    "ZF9uYW1lID0gaW5mby5nZXQoIm5hbWUiLCBpdGVtLnRleHQoKSkKICAgICAgICBuYW1lLCBvayA9IFF0V2lkZ2V0cy5RSW5wdXREaWFsb2cuZ2V0VGV4dChz"
    "ZWxmLCAi7IiY7KCVIiwgIuydtOumhDoiLCB0ZXh0PW9sZF9uYW1lKQogICAgICAgIGlmIG9rIGFuZCBuYW1lLnN0cmlwKCk6CiAgICAgICAgICAgIGluZm9b"
    "Im5hbWUiXSA9IG5hbWUuc3RyaXAoKQogICAgICAgICAgICBzYXZlX2RhdGEoc2VsZi5kYXRhKQogICAgICAgICAgICBzZWxmLnJlbG9hZF9saXN0KHByZWZl"
    "cnJlZF9pbmRleD1jdXJfaW5kZXgpCgogICAgZGVmIGFkZF9zdXJ2ZXkoc2VsZik6CiAgICAgICAgZD17ImluZm8iOnsicHVycG9zZSI6IuydvOuwmCDsobDs"
    "gqzsmqko66qo65Og7J6R7JeF7J6QIOuFuOy2nCkiLCJzdGF0ZSI6IuuMgOq4sCIsIm5hbWUiOiLsg4gg7KGw7IKsIiwic24iOm5leHRfc24oKSwicmVnX2Rh"
    "dGUiOmR0LmRhdGUudG9kYXkoKS5zdHJmdGltZSgiJVktJW0tJWQiKSwiY2xpZW50IjoiIiwgInBlcmlvZCI6W2R0LmRhdGUudG9kYXkoKS5zdHJmdGltZSgi"
    "JVktJW0tJWQiKSxkdC5kYXRlLnRvZGF5KCkuc3RyZnRpbWUoIiVZLSVtLSVkIildLCAiZGVzYyI6IiJ9LCAidGltZXMiOltdLCAidmVoaWNsZSI6e30sICJz"
    "aXRlcyI6W119CiAgICAgICAgc2VsZi5zdXJ2ZXlzKCkuYXBwZW5kKGQpOyBzYXZlX2RhdGEoc2VsZi5kYXRhKTsgc2VsZi5yZWxvYWRfbGlzdCgpOyBzZWxm"
    "LmxzdC5zZXRDdXJyZW50Um93KHNlbGYubHN0LmNvdW50KCktMSkKCiAgICBkZWYgZHVwX3N1cnZleShzZWxmKToKICAgICAgICBjdXIgPSBzZWxmLmN1cnJl"
    "bnQoKQogICAgICAgIGlmIG5vdCBjdXI6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIGltcG9ydCBjb3B5CiAgICAgICAgbmV3X3N1cnYgPSBjb3B5LmRl"
    "ZXBjb3B5KGN1cikKCiAgICAgICAgIyAtLS0g7J6R7JeF67KI7Zi4IOyerOu2gOyXrCAtLS0KICAgICAgICAjIGVudiDsoITssrTsl5DshJwg7IKs7JqpIOyk"
    "keyduCDsnpHsl4XrsojtmLgg7IiY7KeRCiAgICAgICAgbnVtcyA9IFtdCiAgICAgICAgZGF0YSA9IHNlbGYuZGF0YSBpZiBpc2luc3RhbmNlKHNlbGYuZGF0"
    "YSwgZGljdCkgZWxzZSB7fQogICAgICAgIGZvciBzdXJ2IGluIGRhdGEuZ2V0KCJzdXJ2ZXlzIiwgW10pOgogICAgICAgICAgICBmb3Igcm93IGluIHN1cnYu"
    "Z2V0KCJzaXRlcyIsIFtdKToKICAgICAgICAgICAgICAgIGppZCA9IHJvdy5nZXQoIuyekeyXheuyiO2YuCIsICIiKQogICAgICAgICAgICAgICAgaWYgaXNp"
    "bnN0YW5jZShqaWQsIHN0cikgYW5kIGppZC5zdGFydHN3aXRoKCJXTl8iKToKICAgICAgICAgICAgICAgICAgICB0YWlsID0gamlkWzM6XQogICAgICAgICAg"
    "ICAgICAgICAgIGlmIHRhaWwuaXNkaWdpdCgpOgogICAgICAgICAgICAgICAgICAgICAgICBudW1zLmFwcGVuZChpbnQodGFpbCkpCgogICAgICAgICMg7IOI"
    "IOuyiO2YuCDsi5zsnpHqsJIKICAgICAgICBuID0gbWF4KG51bXMpICsgMSBpZiBudW1zIGVsc2UgMQoKICAgICAgICAjIOuzteygnOuQnCDqs7zsl4XsnZgg"
    "7KeA7KCQ65Ok7JeQIOuMgO2VtCDsg4gg7J6R7JeF67KI7Zi4IOu2gOyXrAogICAgICAgIGZvciByb3cgaW4gbmV3X3N1cnYuZ2V0KCJzaXRlcyIsIFtdKToK"
    "ICAgICAgICAgICAgcm93WyLsnpHsl4XrsojtmLgiXSA9IGYiV05fe246MDRkfSIKICAgICAgICAgICAgbiArPSAxCgogICAgICAgICMgZW527JeQIOy2lOqw"
    "gCDrsI8g7KCA7J6lCiAgICAgICAgc2VsZi5zdXJ2ZXlzKCkuYXBwZW5kKG5ld19zdXJ2KQogICAgICAgIHNhdmVfZGF0YShzZWxmLmRhdGEpCgogICAgICAg"
    "ICMg66as7Iqk7Yq4IOqwseyLoCDtm4QsIOuwqeq4iCDrs7XsoJzrkJwg7ZWt66qpIOyEoO2DnQogICAgICAgIHNlbGYucmVsb2FkX2xpc3QocHJlZmVycmVk"
    "X2luZGV4PXNlbGYubHN0LmNvdW50KCkgLSAxKQoKCgogICAgZGVmIGRlbF9zdXJ2ZXkoc2VsZik6CiAgICAgICAgaT1zZWxmLmxzdC5jdXJyZW50Um93KCk7"
    "IAogICAgICAgIGlmIGk8MDogcmV0dXJuCiAgICAgICAgaWYgUXRXaWRnZXRzLlFNZXNzYWdlQm94LnF1ZXN0aW9uKHNlbGYsIuyCreygnCDtmZXsnbgiLCLs"
    "gq3soJztlaDquYzsmpQ/Iik9PVF0V2lkZ2V0cy5RTWVzc2FnZUJveC5ZZXM6CiAgICAgICAgICAgIHNlbGYuc3VydmV5cygpLnBvcChpKTsgc2F2ZV9kYXRh"
    "KHNlbGYuZGF0YSk7IAogICAgICAgICAgICBwcmVmZXJyZWQgPSBtYXgoMCwgbWluKGksIGxlbihzZWxmLnN1cnZleXMoKSktMSkpCiAgICAgICAgICAgIHNl"
    "bGYucmVsb2FkX2xpc3QocHJlZmVycmVkX2luZGV4PXByZWZlcnJlZCkKCiAgICBkZWYgcGVyc2lzdF9jdXJyZW50KHNlbGYpOgogICAgICAgIGk9c2VsZi5s"
    "c3QuY3VycmVudFJvdygpOyAKICAgICAgICBpZiBpPDA6IHJldHVybgogICAgICAgIGQ9c2VsZi5zdXJ2ZXlzKClbaV0KICAgICAgICBkWyJpbmZvIl09c2Vs"
    "Zi5pbmZvLmdldCgpOyBkWyJ0aW1lcyJdPXNlbGYudGltZS5nZXQoKTsgZFsidmVoaWNsZSJdPXNlbGYudmVoLmdldCgpOyBkWyJzaXRlcyJdPXNlbGYuc2l0"
    "ZXMuZ2V0KCkKICAgICAgICBzYXZlX2RhdGEoc2VsZi5kYXRhKTsgc2VsZi5yZWxvYWRfbGlzdCgpCgogICAgZGVmIGxvYWRfY3VycmVudChzZWxmLCpfKToK"
    "ICAgICAgICBkPXNlbGYuY3VycmVudCgpCiAgICAgICAgaWYgbm90IGQ6CiAgICAgICAgICAgIHNlbGYuaW5mby5zZXQoe30pOyBzZWxmLnRpbWUuc2V0KFtd"
    "KTsgc2VsZi52ZWguc2V0KHt9KTsgc2VsZi5zaXRlcy5zZXQoW10pOyByZXR1cm4KICAgICAgICBzZWxmLmluZm8uc2V0KGQuZ2V0KCJpbmZvIikpOyBzZWxm"
    "LnRpbWUuc2V0KGQuZ2V0KCJ0aW1lcyIpKTsgc2VsZi52ZWguc2V0KGQuZ2V0KCJ2ZWhpY2xlIikpOyBzZWxmLnNpdGVzLnNldChkLmdldCgic2l0ZXMiKSkK"
    "CiMgLS0tLS0tLS0tLS0tLS0tLSDrqZTsnbgg64uk7J207Ja866Gc6re4IC0tLS0tLS0tLS0tLS0tLS0KCgojIC0tLS0tLS0tLS0tLS0tLS0g7IKs7Jqp7J6Q"
    "IOq0gOumrCAtLS0tLS0tLS0tLS0tLS0tCmNsYXNzIFVzZXJFZGl0RGlhbG9nKFF0V2lkZ2V0cy5RRGlhbG9nKToKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBw"
    "YXJlbnQ9Tm9uZSwgcmVjb3JkPU5vbmUpOgogICAgICAgIHN1cGVyKCkuX19pbml0X18ocGFyZW50KQogICAgICAgIHNlbGYuc2V0V2luZG93VGl0bGUoIuyC"
    "rOyaqeyekCDtjrjsp5EiKQogICAgICAgIHNlbGYuX2RhdGEgPSBOb25lCiAgICAgICAgbGF5b3V0ID0gUXRXaWRnZXRzLlFGb3JtTGF5b3V0KHNlbGYpCgog"
    "ICAgICAgIHNlbGYuZWRfbmFtZSA9IFF0V2lkZ2V0cy5RTGluZUVkaXQoKQogICAgICAgIHNlbGYuZWRfaWQgPSBRdFdpZGdldHMuUUxpbmVFZGl0KCkKICAg"
    "ICAgICBzZWxmLmVkX3B3ID0gUXRXaWRnZXRzLlFMaW5lRWRpdCgpCiAgICAgICAgc2VsZi5lZF9wdy5zZXRFY2hvTW9kZShRdFdpZGdldHMuUUxpbmVFZGl0"
    "LlBhc3N3b3JkKQoKICAgICAgICBzZWxmLmNiX3JvbGUgPSBRdFdpZGdldHMuUUNvbWJvQm94KCkKICAgICAgICBzZWxmLmNiX3JvbGUuYWRkSXRlbXMoWyLs"
    "nbzrsJjsgqzsmqnsnpAiLCAi6rSA66as7J6QIl0pCgogICAgICAgIHNlbGYuY2Jfc3RhdHVzID0gUXRXaWRnZXRzLlFDb21ib0JveCgpCiAgICAgICAgc2Vs"
    "Zi5jYl9zdGF0dXMuYWRkSXRlbXMoWyLsgqzsmqkiLCAi7KCV7KeAIl0pCgogICAgICAgIHRvZGF5ID0gUXRDb3JlLlFEYXRlLmN1cnJlbnREYXRlKCkKICAg"
    "ICAgICBzZWxmLmR0X3JlZyA9IFF0V2lkZ2V0cy5RRGF0ZUVkaXQodG9kYXkpCiAgICAgICAgc2VsZi5kdF9yZWcuc2V0Q2FsZW5kYXJQb3B1cChUcnVlKQog"
    "ICAgICAgIHNlbGYuZHRfcmVnLnNldERpc3BsYXlGb3JtYXQoInl5eXktTU0tZGQiKQoKICAgICAgICBzZWxmLmR0X3N0YXJ0ID0gUXRXaWRnZXRzLlFEYXRl"
    "RWRpdCh0b2RheSkKICAgICAgICBzZWxmLmR0X3N0YXJ0LnNldENhbGVuZGFyUG9wdXAoVHJ1ZSkKICAgICAgICBzZWxmLmR0X3N0YXJ0LnNldERpc3BsYXlG"
    "b3JtYXQoInl5eXktTU0tZGQiKQoKICAgICAgICBzZWxmLmR0X2VuZCA9IFF0V2lkZ2V0cy5RRGF0ZUVkaXQodG9kYXkuYWRkWWVhcnMoMSkpCiAgICAgICAg"
    "c2VsZi5kdF9lbmQuc2V0Q2FsZW5kYXJQb3B1cChUcnVlKQogICAgICAgIHNlbGYuZHRfZW5kLnNldERpc3BsYXlGb3JtYXQoInl5eXktTU0tZGQiKQoKICAg"
    "ICAgICBzZWxmLmVkX2V4dHJhID0gUXRXaWRnZXRzLlFMaW5lRWRpdCgpCgogICAgICAgIGxheW91dC5hZGRSb3coIuydtOumhCIsIHNlbGYuZWRfbmFtZSkK"
    "ICAgICAgICBsYXlvdXQuYWRkUm93KCLslYTsnbTrlJQiLCBzZWxmLmVkX2lkKQogICAgICAgIGxheW91dC5hZGRSb3coIuu5hOuwgOuyiO2YuCIsIHNlbGYu"
    "ZWRfcHcpCiAgICAgICAgbGF5b3V0LmFkZFJvdygi6raM7ZWcIiwgc2VsZi5jYl9yb2xlKQogICAgICAgIGxheW91dC5hZGRSb3coIuuTseuhneydvOyekCIs"
    "IHNlbGYuZHRfcmVnKQogICAgICAgIGxheW91dC5hZGRSb3coIuyDge2DnCIsIHNlbGYuY2Jfc3RhdHVzKQogICAgICAgIGxheW91dC5hZGRSb3coIuyLnOye"
    "keydvCIsIHNlbGYuZHRfc3RhcnQpCiAgICAgICAgbGF5b3V0LmFkZFJvdygi7KKF66OM7J28Iiwgc2VsZi5kdF9lbmQpCiAgICAgICAgbGF5b3V0LmFkZFJv"
    "dygi67aA6rCA7KCV67O0Iiwgc2VsZi5lZF9leHRyYSkKCiAgICAgICAgYnRucyA9IFF0V2lkZ2V0cy5RRGlhbG9nQnV0dG9uQm94KFF0V2lkZ2V0cy5RRGlh"
    "bG9nQnV0dG9uQm94Lk9rIHwgUXRXaWRnZXRzLlFEaWFsb2dCdXR0b25Cb3guQ2FuY2VsKQogICAgICAgIGxheW91dC5hZGRSb3coYnRucykKICAgICAgICBi"
    "dG5zLmFjY2VwdGVkLmNvbm5lY3Qoc2VsZi5hY2NlcHQpCiAgICAgICAgYnRucy5yZWplY3RlZC5jb25uZWN0KHNlbGYucmVqZWN0KQoKICAgICAgICBpZiBy"
    "ZWNvcmQ6CiAgICAgICAgICAgIHNlbGYuZWRfbmFtZS5zZXRUZXh0KHJlY29yZC5nZXQoIuydtOumhCIsICIiKSkKICAgICAgICAgICAgc2VsZi5lZF9pZC5z"
    "ZXRUZXh0KHJlY29yZC5nZXQoIuyVhOydtOuUlCIsICIiKSkKICAgICAgICAgICAgc2VsZi5lZF9wdy5zZXRUZXh0KHJlY29yZC5nZXQoIuu5hOuwgOuyiO2Y"
    "uCIsICIiKSkKICAgICAgICAgICAgcm9sZSA9IHJlY29yZC5nZXQoIuq2jO2VnCIpIG9yICLsnbzrsJjsgqzsmqnsnpAiCiAgICAgICAgICAgIGlkeCA9IHNl"
    "bGYuY2Jfcm9sZS5maW5kVGV4dChyb2xlKQogICAgICAgICAgICBpZiBpZHggPj0gMDoKICAgICAgICAgICAgICAgIHNlbGYuY2Jfcm9sZS5zZXRDdXJyZW50"
    "SW5kZXgoaWR4KQogICAgICAgICAgICBzdGF0dXMgPSByZWNvcmQuZ2V0KCLsg4Htg5wiKSBvciAi7IKs7JqpIgogICAgICAgICAgICBpZHggPSBzZWxmLmNi"
    "X3N0YXR1cy5maW5kVGV4dChzdGF0dXMpCiAgICAgICAgICAgIGlmIGlkeCA+PSAwOgogICAgICAgICAgICAgICAgc2VsZi5jYl9zdGF0dXMuc2V0Q3VycmVu"
    "dEluZGV4KGlkeCkKICAgICAgICAgICAgZm9yIHdpZGdldCwga2V5IGluIFsKICAgICAgICAgICAgICAgIChzZWxmLmR0X3JlZywgIuuTseuhneydvOyekCIp"
    "LAogICAgICAgICAgICAgICAgKHNlbGYuZHRfc3RhcnQsICLsi5zsnpHsnbwiKSwKICAgICAgICAgICAgICAgIChzZWxmLmR0X2VuZCwgIuyiheujjOydvCIp"
    "LAogICAgICAgICAgICBdOgogICAgICAgICAgICAgICAgdmFsID0gcmVjb3JkLmdldChrZXkpCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAg"
    "ICAgICAgaWYgaXNpbnN0YW5jZSh2YWwsIHN0cikgYW5kIHZhbDoKICAgICAgICAgICAgICAgICAgICAgICAgZCA9IFF0Q29yZS5RRGF0ZS5mcm9tU3RyaW5n"
    "KHZhbCwgInl5eXktTU0tZGQiKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBkLmlzVmFsaWQoKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdp"
    "ZGdldC5zZXREYXRlKGQpCiAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgc2Vs"
    "Zi5lZF9leHRyYS5zZXRUZXh0KHJlY29yZC5nZXQoIuu2gOqwgOygleuztCIsICIiKSkKCiAgICBkZWYgZ2V0X2RhdGEoc2VsZik6CiAgICAgICAgcmV0dXJu"
    "IHNlbGYuX2RhdGEKCiAgICBkZWYgYWNjZXB0KHNlbGYpOgogICAgICAgIG5hbWUgPSBzZWxmLmVkX25hbWUudGV4dCgpLnN0cmlwKCkKICAgICAgICB1c2Vy"
    "X2lkID0gc2VsZi5lZF9pZC50ZXh0KCkuc3RyaXAoKQogICAgICAgIGlmIG5vdCB1c2VyX2lkOgogICAgICAgICAgICBRdFdpZGdldHMuUU1lc3NhZ2VCb3gu"
    "d2FybmluZyhzZWxmLCAi7ZmV7J24IiwgIuyVhOydtOuUlOulvCDsnoXroKXtlbTso7zshLjsmpQuIikKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgcmVn"
    "ID0gc2VsZi5kdF9yZWcuZGF0ZSgpLnRvU3RyaW5nKCJ5eXl5LU1NLWRkIikKICAgICAgICBzdGFydCA9IHNlbGYuZHRfc3RhcnQuZGF0ZSgpLnRvU3RyaW5n"
    "KCJ5eXl5LU1NLWRkIikKICAgICAgICBlbmQgPSBzZWxmLmR0X2VuZC5kYXRlKCkudG9TdHJpbmcoInl5eXktTU0tZGQiKQogICAgICAgIHNlbGYuX2RhdGEg"
    "PSB7CiAgICAgICAgICAgICLsnbTrpoQiOiBuYW1lLAogICAgICAgICAgICAi7JWE7J2065SUIjogdXNlcl9pZCwKICAgICAgICAgICAgIuu5hOuwgOuyiO2Y"
    "uCI6IHNlbGYuZWRfcHcudGV4dCgpLAogICAgICAgICAgICAi6raM7ZWcIjogc2VsZi5jYl9yb2xlLmN1cnJlbnRUZXh0KCksCiAgICAgICAgICAgICLrk7Hr"
    "oZ3snbzsnpAiOiByZWcsCiAgICAgICAgICAgICLsg4Htg5wiOiBzZWxmLmNiX3N0YXR1cy5jdXJyZW50VGV4dCgpLAogICAgICAgICAgICAi7Iuc7J6R7J28"
    "Ijogc3RhcnQsCiAgICAgICAgICAgICLsooXro4zsnbwiOiBlbmQsCiAgICAgICAgICAgICLrtoDqsIDsoJXrs7QiOiBzZWxmLmVkX2V4dHJhLnRleHQoKS5z"
    "dHJpcCgpLAogICAgICAgIH0KICAgICAgICBzdXBlcigpLmFjY2VwdCgpCgoKY2xhc3MgVXNlck1hbmFnZXJQYWdlKFF0V2lkZ2V0cy5RV2lkZ2V0KToKICAg"
    "IGRlZiBfX2luaXRfXyhzZWxmLCBkYXRhLCBwYXJlbnQ9Tm9uZSk6CiAgICAgICAgc3VwZXIoKS5fX2luaXRfXyhwYXJlbnQpCiAgICAgICAgc2VsZi5kYXRh"
    "ID0gZGF0YQogICAgICAgIHYgPSBRdFdpZGdldHMuUVZCb3hMYXlvdXQoc2VsZikKCiAgICAgICAgbGJsID0gUXRXaWRnZXRzLlFMYWJlbCgKICAgICAgICAg"
    "ICAgIu2UhOuhnOq3uOueqCDsgqzsmqnsnpAg6rOE7KCV7J2EIOq0gOumrO2VqeuLiOuLpC5cbiIKICAgICAgICAgICAgIi0g6raM7ZWc7J20ICfqtIDrpqzs"
    "npAn7J24IOqzhOygleunjCDqtIDrpqzsnpAg66qo65Oc66W8IOyCrOyaqe2VoCDsiJgg7J6I7Iq164uI64ukLlxuIgogICAgICAgICAgICAiLSDsg4Htg5zq"
    "sIAgJ+yCrOyaqSfsnbgg6rOE7KCV66eMIOuhnOq3uOyduCDqsIDriqXtlanri4jri6QuIgogICAgICAgICkKICAgICAgICBsYmwuc2V0V29yZFdyYXAoVHJ1"
    "ZSkKICAgICAgICB2LmFkZFdpZGdldChsYmwpCgogICAgICAgIHNlbGYudGFibGUgPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0KDAsIDEwKQogICAgICAgIHNl"
    "bGYudGFibGUuc2V0SG9yaXpvbnRhbEhlYWRlckxhYmVscygKICAgICAgICAgICAgWyLrsojtmLgiLCAi7J2066aEIiwgIuyVhOydtOuUlCIsICLruYTrsIDr"
    "sojtmLgiLCAi6raM7ZWcIiwgIuuTseuhneydvOyekCIsICLsg4Htg5wiLCAi7IKs7Jqp6riw6rCEIiwgIuu2gOqwgOygleuztCIsICIiXQogICAgICAgICkK"
    "ICAgICAgICBoZWFkZXIgPSBzZWxmLnRhYmxlLmhvcml6b250YWxIZWFkZXIoKQogICAgICAgIGhlYWRlci5zZXRTZWN0aW9uUmVzaXplTW9kZShRdFdpZGdl"
    "dHMuUUhlYWRlclZpZXcuU3RyZXRjaCkKICAgICAgICAjIOuyiO2YuCDsl7TsnYAg6rCA66GcIO2PreydhCDrjZQg7J6R6rKMLCDqt7jrpqzqs6Ag64uk66W4"
    "IOyXtOqzvCDrj4Xrpr3soIHsnLzroZwg7KGw7KCVCiAgICAgICAgdHJ5OgogICAgICAgICAgICBoZWFkZXIuc2V0U2VjdGlvblJlc2l6ZU1vZGUoMCwgUXRX"
    "aWRnZXRzLlFIZWFkZXJWaWV3LlJlc2l6ZVRvQ29udGVudHMpCiAgICAgICAgICAgIHNlbGYudGFibGUuc2V0Q29sdW1uV2lkdGgoMCwgNDApCiAgICAgICAg"
    "ZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgICAgICMg7ZaJIOuyiO2YuCjsoozsuKEg7Iir7J6QKeuKlCDsiKjquYAKICAgICAgICB0"
    "cnk6CiAgICAgICAgICAgIHNlbGYudGFibGUudmVydGljYWxIZWFkZXIoKS5zZXRWaXNpYmxlKEZhbHNlKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAg"
    "ICAgICAgICAgIHBhc3MKICAgICAgICBzZWxmLnRhYmxlLnNldFNlbGVjdGlvbkJlaGF2aW9yKFF0V2lkZ2V0cy5RQWJzdHJhY3RJdGVtVmlldy5TZWxlY3RS"
    "b3dzKQogICAgICAgIHNlbGYudGFibGUuc2V0RWRpdFRyaWdnZXJzKFF0V2lkZ2V0cy5RQWJzdHJhY3RJdGVtVmlldy5Ob0VkaXRUcmlnZ2VycykKICAgICAg"
    "ICB2LmFkZFdpZGdldChzZWxmLnRhYmxlLCAxKQoKICAgICAgICBoYiA9IFF0V2lkZ2V0cy5RSEJveExheW91dCgpCiAgICAgICAgc2VsZi5jaGtfYWxsID0g"
    "UXRXaWRnZXRzLlFDaGVja0JveCgi7KCE7LK067O06riwIikKICAgICAgICBzZWxmLmNoa19hbGwuc2V0Q2hlY2tlZChUcnVlKQogICAgICAgIHNlbGYuY2hr"
    "X2FsbC50b2dnbGVkLmNvbm5lY3Qoc2VsZi5yZWxvYWQpCiAgICAgICAgaGIuYWRkV2lkZ2V0KHNlbGYuY2hrX2FsbCkKICAgICAgICBoYi5hZGRTdHJldGNo"
    "KDEpCiAgICAgICAgYnRuX2FkZCA9IFF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi7LaU6rCAIikKICAgICAgICBidG5fZWRpdCA9IFF0V2lkZ2V0cy5RUHVzaEJ1"
    "dHRvbigi7IiY7KCVIikKICAgICAgICBidG5fZGVsID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCLsgq3soJwiKQogICAgICAgIGhiLmFkZFdpZGdldChidG5f"
    "YWRkKQogICAgICAgIGhiLmFkZFdpZGdldChidG5fZWRpdCkKICAgICAgICBoYi5hZGRXaWRnZXQoYnRuX2RlbCkKICAgICAgICB2LmFkZExheW91dChoYikK"
    "CiAgICAgICAgYnRuX2FkZC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5hZGRfdXNlcikKICAgICAgICBidG5fZWRpdC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5lZGl0"
    "X3VzZXIpCiAgICAgICAgYnRuX2RlbC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5kZWxfdXNlcikKCiAgICAgICAgc2VsZi5yb3dfbWFwID0gW10KICAgICAgICBz"
    "ZWxmLnJlbG9hZCgpCgogICAgZGVmIF91c2VycyhzZWxmKToKICAgICAgICByZXR1cm4gc2VsZi5kYXRhLmdldCgidXNlcnMiLCBbXSkKCiAgICBkZWYgcmVs"
    "b2FkKHNlbGYpOgogICAgICAgIHVzZXJzID0gc2VsZi5fdXNlcnMoKQogICAgICAgIHNob3dfYWxsID0gc2VsZi5jaGtfYWxsLmlzQ2hlY2tlZCgpCiAgICAg"
    "ICAgc2VsZi50YWJsZS5zZXRSb3dDb3VudCgwKQogICAgICAgIHNlbGYucm93X21hcCA9IFtdCgogICAgICAgIGZvciBpZHgsIHJlYyBpbiBlbnVtZXJhdGUo"
    "dXNlcnMpOgogICAgICAgICAgICBpZiAobm90IHNob3dfYWxsKSBhbmQgcmVjLmdldCgi7IOB7YOcIiwgIuyCrOyaqSIpICE9ICLsgqzsmqkiOgogICAgICAg"
    "ICAgICAgICAgY29udGludWUKICAgICAgICAgICAgcm93ID0gc2VsZi50YWJsZS5yb3dDb3VudCgpCiAgICAgICAgICAgIHNlbGYudGFibGUuaW5zZXJ0Um93"
    "KHJvdykKICAgICAgICAgICAgc2VsZi5yb3dfbWFwLmFwcGVuZChpZHgpCgogICAgICAgICAgICByZWMuc2V0ZGVmYXVsdCgi67KI7Zi4IiwgaWR4ICsgMSkK"
    "ICAgICAgICAgICAgbnVtX2l0ZW0gPSBRdFdpZGdldHMuUVRhYmxlV2lkZ2V0SXRlbShzdHIocmVjLmdldCgi67KI7Zi4IiwgaWR4ICsgMSkpKQogICAgICAg"
    "ICAgICBudW1faXRlbS5zZXRUZXh0QWxpZ25tZW50KFF0Q29yZS5RdC5BbGlnbkNlbnRlcikKICAgICAgICAgICAgbnVtX2l0ZW0uc2V0RmxhZ3MobnVtX2l0"
    "ZW0uZmxhZ3MoKSAmIH5RdENvcmUuUXQuSXRlbUlzRWRpdGFibGUpCiAgICAgICAgICAgIHNlbGYudGFibGUuc2V0SXRlbShyb3csIDAsIG51bV9pdGVtKQoK"
    "ICAgICAgICAgICAgZGVmIF9pdGVtKHRleHQsIGFsaWduX2NlbnRlcj1GYWxzZSk6CiAgICAgICAgICAgICAgICBpdCA9IFF0V2lkZ2V0cy5RVGFibGVXaWRn"
    "ZXRJdGVtKHRleHQgb3IgIiIpCiAgICAgICAgICAgICAgICBpZiBhbGlnbl9jZW50ZXI6CiAgICAgICAgICAgICAgICAgICAgaXQuc2V0VGV4dEFsaWdubWVu"
    "dChRdENvcmUuUXQuQWxpZ25DZW50ZXIpCiAgICAgICAgICAgICAgICBpdC5zZXRGbGFncyhpdC5mbGFncygpICYgflF0Q29yZS5RdC5JdGVtSXNFZGl0YWJs"
    "ZSkKICAgICAgICAgICAgICAgIHJldHVybiBpdAoKICAgICAgICAgICAgc2VsZi50YWJsZS5zZXRJdGVtKHJvdywgMSwgX2l0ZW0ocmVjLmdldCgi7J2066aE"
    "IiwgIiIpLCBUcnVlKSkKICAgICAgICAgICAgc2VsZi50YWJsZS5zZXRJdGVtKHJvdywgMiwgX2l0ZW0ocmVjLmdldCgi7JWE7J2065SUIiwgIiIpLCBUcnVl"
    "KSkKICAgICAgICAgICAgcHdfZGlzcGxheSA9ICIqKioqKiIgaWYgcmVjLmdldCgi67mE67CA67KI7Zi4IikgZWxzZSAiIgogICAgICAgICAgICBzZWxmLnRh"
    "YmxlLnNldEl0ZW0ocm93LCAzLCBfaXRlbShwd19kaXNwbGF5LCBUcnVlKSkKICAgICAgICAgICAgc2VsZi50YWJsZS5zZXRJdGVtKHJvdywgNCwgX2l0ZW0o"
    "cmVjLmdldCgi6raM7ZWcIiwgIiIpLCBUcnVlKSkKICAgICAgICAgICAgc2VsZi50YWJsZS5zZXRJdGVtKHJvdywgNSwgX2l0ZW0ocmVjLmdldCgi65Ox66Gd"
    "7J287J6QIiwgIiIpLCBUcnVlKSkKICAgICAgICAgICAgc2VsZi50YWJsZS5zZXRJdGVtKHJvdywgNiwgX2l0ZW0ocmVjLmdldCgi7IOB7YOcIiwgIiIpLCBU"
    "cnVlKSkKCiAgICAgICAgICAgIHN0YXJ0ID0gcmVjLmdldCgi7Iuc7J6R7J28IiwgIiIpCiAgICAgICAgICAgIGVuZCA9IHJlYy5nZXQoIuyiheujjOydvCIs"
    "ICIiKQogICAgICAgICAgICBwZXJpb2QgPSAiIgogICAgICAgICAgICBpZiBzdGFydCBvciBlbmQ6CiAgICAgICAgICAgICAgICBwZXJpb2QgPSBmIntzdGFy"
    "dH0gfiB7ZW5kfSIuc3RyaXAoKQogICAgICAgICAgICBzZWxmLnRhYmxlLnNldEl0ZW0ocm93LCA3LCBfaXRlbShwZXJpb2QsIFRydWUpKQogICAgICAgICAg"
    "ICBzZWxmLnRhYmxlLnNldEl0ZW0ocm93LCA4LCBfaXRlbShyZWMuZ2V0KCLrtoDqsIDsoJXrs7QiLCAiIikpKQogICAgICAgICAgICBzZWxmLnRhYmxlLnNl"
    "dEl0ZW0ocm93LCA5LCBfaXRlbSgiIikpCgogICAgICAgICAgICAjIOq0gOumrOyekCDtlonsnYAg67mo6rCE7IOJ7Jy866GcIOqwleyhsAogICAgICAgICAg"
    "ICBpZiByZWMuZ2V0KCLqtoztlZwiKSA9PSAi6rSA66as7J6QIjoKICAgICAgICAgICAgICAgIGZvciBjb2wgaW4gcmFuZ2UoMSwgOSk6CiAgICAgICAgICAg"
    "ICAgICAgICAgaXRlbSA9IHNlbGYudGFibGUuaXRlbShyb3csIGNvbCkKICAgICAgICAgICAgICAgICAgICBpZiBpdGVtOgogICAgICAgICAgICAgICAgICAg"
    "ICAgICBpdGVtLnNldEZvcmVncm91bmQoUXRHdWkuUUJydXNoKFF0R3VpLlFDb2xvcigicmVkIikpKQoKICAgICAgICBzZWxmLnRhYmxlLnJlc2l6ZUNvbHVt"
    "bnNUb0NvbnRlbnRzKCkKCiAgICBkZWYgY3VycmVudF9pbmRleChzZWxmKToKICAgICAgICByb3cgPSBzZWxmLnRhYmxlLmN1cnJlbnRSb3coKQogICAgICAg"
    "IGlmIHJvdyA8IDAgb3Igcm93ID49IGxlbihzZWxmLnJvd19tYXApOgogICAgICAgICAgICByZXR1cm4gTm9uZQogICAgICAgIHJldHVybiBzZWxmLnJvd19t"
    "YXBbcm93XQoKICAgIGRlZiBhZGRfdXNlcihzZWxmKToKICAgICAgICBkbGcgPSBVc2VyRWRpdERpYWxvZyhzZWxmKQogICAgICAgIGlmIGRsZy5leGVjXygp"
    "ID09IFF0V2lkZ2V0cy5RRGlhbG9nLkFjY2VwdGVkOgogICAgICAgICAgICBkYXRhID0gZGxnLmdldF9kYXRhKCkKICAgICAgICAgICAgaWYgZGF0YSBpcyBO"
    "b25lOgogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIHVzZXJzID0gc2VsZi5fdXNlcnMoKQogICAgICAgICAgICB1c2Vycy5hcHBlbmQoZGF0"
    "YSkKICAgICAgICAgICAgc2VsZi5kYXRhWyJ1c2VycyJdID0gdXNlcnMKICAgICAgICAgICAgc2F2ZV9kYXRhKHNlbGYuZGF0YSkKICAgICAgICAgICAgc2Vs"
    "Zi5yZWxvYWQoKQoKICAgIGRlZiBlZGl0X3VzZXIoc2VsZik6CiAgICAgICAgaWR4ID0gc2VsZi5jdXJyZW50X2luZGV4KCkKICAgICAgICBpZiBpZHggaXMg"
    "Tm9uZToKICAgICAgICAgICAgUXRXaWRnZXRzLlFNZXNzYWdlQm94LmluZm9ybWF0aW9uKHNlbGYsICLslYzrprwiLCAi7IiY7KCV7ZWgIOyCrOyaqeyekOul"
    "vCDshKDtg53tlZjshLjsmpQuIikKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgdXNlcnMgPSBzZWxmLl91c2VycygpCiAgICAgICAgcmVjID0gZGljdCh1"
    "c2Vyc1tpZHhdKQogICAgICAgIGRsZyA9IFVzZXJFZGl0RGlhbG9nKHNlbGYsIHJlYykKICAgICAgICBpZiBkbGcuZXhlY18oKSA9PSBRdFdpZGdldHMuUURp"
    "YWxvZy5BY2NlcHRlZDoKICAgICAgICAgICAgZGF0YSA9IGRsZy5nZXRfZGF0YSgpCiAgICAgICAgICAgIGlmIGRhdGEgaXMgTm9uZToKICAgICAgICAgICAg"
    "ICAgIHJldHVybgogICAgICAgICAgICB1c2Vyc1tpZHhdID0gZGF0YQogICAgICAgICAgICBzZWxmLmRhdGFbInVzZXJzIl0gPSB1c2VycwogICAgICAgICAg"
    "ICBzYXZlX2RhdGEoc2VsZi5kYXRhKQogICAgICAgICAgICBzZWxmLnJlbG9hZCgpCiAgICAgICAgICAgICMg64uk7IucIOqwmeydgCDtlokg7ISg7YOdCiAg"
    "ICAgICAgICAgIGlmIHNlbGYucm93X21hcDoKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICByb3cgPSBzZWxmLnJvd19tYXAuaW5k"
    "ZXgoaWR4KQogICAgICAgICAgICAgICAgICAgIHNlbGYudGFibGUuc2VsZWN0Um93KHJvdykKICAgICAgICAgICAgICAgIGV4Y2VwdCBWYWx1ZUVycm9yOgog"
    "ICAgICAgICAgICAgICAgICAgIHBhc3MKCiAgICBkZWYgZGVsX3VzZXIoc2VsZik6CiAgICAgICAgaWR4ID0gc2VsZi5jdXJyZW50X2luZGV4KCkKICAgICAg"
    "ICBpZiBpZHggaXMgTm9uZToKICAgICAgICAgICAgUXRXaWRnZXRzLlFNZXNzYWdlQm94LmluZm9ybWF0aW9uKHNlbGYsICLslYzrprwiLCAi7IKt7KCc7ZWg"
    "IOyCrOyaqeyekOulvCDshKDtg53tlZjshLjsmpQuIikKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgdXNlcnMgPSBzZWxmLl91c2VycygpCiAgICAgICAg"
    "cmVjID0gdXNlcnNbaWR4XQogICAgICAgIGlmIFF0V2lkZ2V0cy5RTWVzc2FnZUJveC5xdWVzdGlvbigKICAgICAgICAgICAgc2VsZiwgIu2ZleyduCIsIGYi"
    "7ISg7YOd7ZWcIOyCrOyaqeyekCAne3JlYy5nZXQoJ+yVhOydtOuUlCcsJycpfScg66W8IOyCreygnO2VmOyLnOqyoOyKteuLiOq5jD8iLAogICAgICAgICAg"
    "ICBRdFdpZGdldHMuUU1lc3NhZ2VCb3guWWVzIHwgUXRXaWRnZXRzLlFNZXNzYWdlQm94Lk5vLAogICAgICAgICAgICBRdFdpZGdldHMuUU1lc3NhZ2VCb3gu"
    "Tm8sCiAgICAgICAgKSAhPSBRdFdpZGdldHMuUU1lc3NhZ2VCb3guWWVzOgogICAgICAgICAgICByZXR1cm4KICAgICAgICBkZWwgdXNlcnNbaWR4XQogICAg"
    "ICAgICMg67KI7Zi4IOyerOygleugrAogICAgICAgIGZvciBpLCB1IGluIGVudW1lcmF0ZSh1c2Vycyk6CiAgICAgICAgICAgIHVbIuuyiO2YuCJdID0gaSAr"
    "IDEKICAgICAgICBzZWxmLmRhdGFbInVzZXJzIl0gPSB1c2VycwogICAgICAgIHNhdmVfZGF0YShzZWxmLmRhdGEpCiAgICAgICAgc2VsZi5yZWxvYWQoKQoK"
    "IyAtLS0tLS0tLS0tLS0tLS0tIOuplOyduCDri6TsnbTslrzroZzqt7ggLS0tLS0tLS0tLS0tLS0tLQoKCmNsYXNzIE1haW4oUXRXaWRnZXRzLlFEaWFsb2cp"
    "OgogICAgZGVmIF9faW5pdF9fKHNlbGYsIGRhdGEpOgogICAgICAgIHN1cGVyKCkuX19pbml0X18oKTsgc2VsZi5zZXRXaW5kb3dUaXRsZShmIu2ZmOqyveyE"
    "pOyglSAo7ZSE66GcIO2UjOufrOyKpCDigJMge0FQUF9WRVJ9KSIpOyBzZWxmLnJlc2l6ZSg4MTAsNTYwKQogICAgICAgIHY9UXRXaWRnZXRzLlFWQm94TGF5"
    "b3V0KHNlbGYpOyBzZWxmLnRhYnM9UXRXaWRnZXRzLlFUYWJXaWRnZXQoKTsgdi5hZGRXaWRnZXQoc2VsZi50YWJzLDEpCiAgICAgICAgc2VsZi5wZ193b3Jr"
    "ID0gV29ya01hbmFnZXJQYWdlKGRhdGEsIHNlbGYpOyBzZWxmLnRhYnMuYWRkVGFiKHNlbGYucGdfd29yaywgIuywqOyihSDqtIDrpqwiKQogICAgICAgIHNl"
    "bGYucGdfc3VydmV5ID0gU3VydmV5TWFuYWdlclBhZ2UoZGF0YSwgc2VsZik7IHNlbGYudGFicy5hZGRUYWIoc2VsZi5wZ19zdXJ2ZXksICLsobDsgqwg6rSA"
    "66asIikKICAgICAgICBzZWxmLnBnX3VzZXIgPSBVc2VyTWFuYWdlclBhZ2UoZGF0YSwgc2VsZik7IHNlbGYudGFicy5hZGRUYWIoc2VsZi5wZ191c2VyLCAi"
    "7IKs7Jqp7J6QIOq0gOumrCIpCiAgICAgICAgaGI9UXRXaWRnZXRzLlFIQm94TGF5b3V0KCk7IGhiLmFkZFN0cmV0Y2goMSk7IGJfc2F2ZT1RdFdpZGdldHMu"
    "UVB1c2hCdXR0b24oIuyggOyepSIpOyBiX2Nsb3NlPVF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigi64ur6riwIik7IGhiLmFkZFdpZGdldChiX3NhdmUpOyBoYi5h"
    "ZGRXaWRnZXQoYl9jbG9zZSk7IHYuYWRkTGF5b3V0KGhiKQogICAgICAgIGJfc2F2ZS5jbGlja2VkLmNvbm5lY3QobGFtYmRhICpfOigKICAgICAgICAgICAg"
    "Z2V0YXR0cihzZWxmLnBnX3N1cnZleSwgInBlcnNpc3RfY3VycmVudCIsIGxhbWJkYTogTm9uZSkoKSwKICAgICAgICAgICAgc2F2ZV9kYXRhKGRhdGEpLAog"
    "ICAgICAgICAgICBRdFdpZGdldHMuUU1lc3NhZ2VCb3guaW5mb3JtYXRpb24oc2VsZiwi7KCA7J6lIiwi7KCA7J6l65CY7JeI7Iq164uI64ukLiIpCiAgICAg"
    "ICAgKSkKICAgICAgICBiX2Nsb3NlLmNsaWNrZWQuY29ubmVjdChzZWxmLmNsb3NlKQogICAgICAgIHNlbGYucGdfd29yay5jaGFuZ2VkLmNvbm5lY3QobGFt"
    "YmRhICpfOiBzZWxmLnBnX3N1cnZleS52ZWgucmVmcmVzaF9jb21ibygpKQoKZGVmIG1haW4oKToKICAgIGFwcD1RdFdpZGdldHMuUUFwcGxpY2F0aW9uKHN5"
    "cy5hcmd2KQoKICAgICMgLS0tLS0gR2xvYmFsIDgwJSBzY2FsZSAoZm9udHMsIHBhZGRpbmdzKSAtLS0tLQogICAgc2NhbGUgPSAwLjgKICAgIGZvbnQgPSBh"
    "cHAuZm9udCgpCiAgICBmcyA9IGZvbnQucG9pbnRTaXplRigpIGlmIGhhc2F0dHIoZm9udCwgInBvaW50U2l6ZUYiKSBlbHNlIGZsb2F0KGZvbnQucG9pbnRT"
    "aXplKCkpCiAgICBpZiBmcyA8PSAwOgogICAgICAgIGZzID0gZmxvYXQoZm9udC5wb2ludFNpemUoKSkKICAgIGlmIGZzID4gMDoKICAgICAgICBmb250LnNl"
    "dFBvaW50U2l6ZUYoZnMgKiBzY2FsZSkKICAgICAgICBhcHAuc2V0Rm9udChmb250KQogICAgIyBPcHRpb25hbDogbGlnaHRlbiBwYWRkaW5ncyB0byBtYXRj"
    "aCBzY2FsZSB2aXN1YWxseQogICAgYXBwLnNldFN0eWxlU2hlZXQoZiIiIgogICAgICAgICoge3sgZm9udC1zaXplOiB7bWF4KDcsIGludCgxMCpzY2FsZSkp"
    "fXB0OyB9fQogICAgICAgIFFUYWJCYXI6OnRhYiB7eyBwYWRkaW5nOiB7aW50KDgqc2NhbGUpfXB4IHtpbnQoMTIqc2NhbGUpfXB4OyB9fQogICAgICAgIFFI"
    "ZWFkZXJWaWV3OjpzZWN0aW9uIHt7IHBhZGRpbmc6IHtpbnQoNipzY2FsZSl9cHg7IH19CiAgICAgICAgUVB1c2hCdXR0b24ge3sgcGFkZGluZzoge2ludCg2"
    "KnNjYWxlKX1weCB7aW50KDEwKnNjYWxlKX1weDsgfX0KICAgICAgICBRQWJzdHJhY3RJdGVtVmlldyB7eyBmb250LXNpemU6IHttYXgoNywgaW50KDEwKnNj"
    "YWxlKSl9cHQ7IH19CiAgICAiIiIpCiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgIGRhdGE9bG9hZF9kYXRh"
    "KCkKICAgIHc9TWFpbihkYXRhKTsgdy5zaG93KCkKICAgIHN5cy5leGl0KGFwcC5leGVjXygpKQoKaWYgX19uYW1lX18gPT0gIl9fbWFpbl9fIjoKICAgIG1h"
    "aW4oKQ=="
)

# ==== Third-party ====
from PyQt6 import QtWidgets, QtGui, QtCore

class TightListDelegate(QtWidgets.QStyledItemDelegate):
    """파일 목록(QListWidget) 항목 높이를 강제로 줄이기 위한 delegate."""
    def __init__(self, parent=None, row_height: int = 14):
        super().__init__(parent)
        self._row_height = row_height

    def sizeHint(self, option, index):
        sz = super().sizeHint(option, index)
        try:
            # 너무 작아지지 않게 최소 10px, 기본은 14px 정도로 고정
            h = max(10, min(self._row_height, sz.height()))
            sz.setHeight(h)
        except Exception:
            pass
        return sz


def _setup_vlc_path():
    """Try to configure PATH so that libvlc.dll can be found on as many systems as possible.

    우선순위:
      1) 환경변수 VLC_PATH / VLCPATH
      2) PyInstaller 실행폴더(_MEIPASS) 및 그 하위 vlc/VLC 폴더
      3) 스크립트(.py) 위치 및 하위 vlc/VLC 폴더
      4) 일반 설치 경로: Program Files / Program Files (x86)/VideoLAN/VLC
    """
    import os, sys, ctypes

    candidate_dirs = []

    # 1) 환경변수 우선
    env = os.environ.get("VLC_PATH") or os.environ.get("VLCPATH")
    if env:
        candidate_dirs.append(env)

    # 2) PyInstaller 번들 디렉터리(_MEIPASS)
    if getattr(sys, "frozen", False):
        meipass = getattr(sys, "_MEIPASS", None)
        if meipass:
            candidate_dirs.extend([
                meipass,
                os.path.join(meipass, "vlc"),
                os.path.join(meipass, "VLC"),
            ])

    # 3) 스크립트(.py) 기준 경로
    try:
        base_dir = os.path.dirname(os.path.abspath(__file__))
    except NameError:
        base_dir = os.getcwd()
    candidate_dirs.extend([
        base_dir,
        os.path.join(base_dir, "vlc"),
        os.path.join(base_dir, "VLC"),
    ])

    # 4) 일반 설치 경로 (Windows)
    program_files = os.environ.get("ProgramFiles", r"C:\Program Files")
    program_files_x86 = os.environ.get("ProgramFiles(x86)", r"C:\Program Files (x86)")
    candidate_dirs.extend([
        os.path.join(program_files, "VideoLAN", "VLC"),
        os.path.join(program_files_x86, "VideoLAN", "VLC"),
    ])

    # 중복 제거
    seen = set()
    dirs = []
    for d in candidate_dirs:
        if not d or d in seen:
            continue
        seen.add(d)
        dirs.append(d)

    for d in dirs:
        try:
            if not os.path.isdir(d):
                continue
            lib_path = os.path.join(d, "libvlc.dll")
            if os.path.exists(lib_path):
                # Python 3.8+ 에서는 add_dll_directory 사용
                try:
                    add_dir = getattr(os, "add_dll_directory", None)
                except Exception:
                    add_dir = None
                if add_dir:
                    try:
                        add_dir(d)
                    except Exception:
                        pass
                # PATH에도 추가 (vlc.py 내부 로직 호환용)
                os.environ["PATH"] = d + os.pathsep + os.environ.get("PATH", "")
                try:
                    ctypes.CDLL(lib_path)
                except OSError:
                    # PATH로 로드될 수도 있으므로 실패해도 무시
                    pass
                return
        except Exception:
            continue
    # 여기까지 오면 libvlc.dll을 찾지 못한 상태이지만,
    # 이후 import vlc에서 표준 오류가 발생하며, 사용자가 직접 VLC 경로를 지정해야 한다.
    return

_setup_vlc_path()

import vlc
import pandas as pd

try:
    import openpyxl  # noqa: F401
    _HAS_XLSX = True
except Exception:
    _HAS_XLSX = False


# ==== Embedded MPV (portable) ====
import ctypes

class _MpvLoadError(RuntimeError):
    pass

def _load_libmpv():
    """
    libmpv DLL을 찾고 로드합니다.

    - 개발용(.py) : counter_max.py 가 있는 폴더 또는 하위 mpv/mpv-64 폴더에서 검색
    - 배포용(.exe, PyInstaller) :
        Counter_Max.exe 가 있는 폴더 또는 그 하위 mpv/mpv-64 폴더에서 검색

    추가로 MPV_PATH / MPV_HOME 환경변수로 직접 경로를 지정할 수도 있습니다.
    """
    import os, sys, ctypes

    base_dirs = []

    # 1) 환경변수 우선
    env = os.environ.get("MPV_PATH") or os.environ.get("MPV_HOME")
    if env:
        base_dirs.append(env)

    # 2) PyInstaller 로 빌드된 exe 위치
    if getattr(sys, "frozen", False):
        exe_dir = os.path.dirname(getattr(sys, "executable", "") or "")
        if exe_dir:
            base_dirs.extend([
                exe_dir,
                os.path.join(exe_dir, "mpv"),
                os.path.join(exe_dir, "mpv-64"),
            ])
        # onefile 모드에서 임시 풀리는 _MEIPASS 도 후보에 추가
        meipass = getattr(sys, "_MEIPASS", None)
        if meipass:
            base_dirs.extend([
                meipass,
                os.path.join(meipass, "mpv"),
                os.path.join(meipass, "mpv-64"),
            ])

    # 3) 일반 파이썬 실행 시: 스크립트(.py) 파일 기준
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
    except Exception:
        script_dir = os.getcwd()
    base_dirs.extend([
        script_dir,
        os.path.join(script_dir, "mpv"),
        os.path.join(script_dir, "mpv-64"),
    ])

    # 4) 현재 작업 디렉터리도 마지막 후보로
    cwd = os.getcwd()
    if cwd:
        base_dirs.append(cwd)

    # 중복 제거 (순서 유지)
    seen = set()
    dirs: list[str] = []
    for d in base_dirs:
        if not d:
            continue
        norm = os.path.normpath(d)
        if norm in seen:
            continue
        seen.add(norm)
        dirs.append(norm)

    names = ["libmpv-2.dll", "mpv-2.dll", "libmpv.dll", "mpv.dll"]
    tried = []

    for d in dirs:
        if not os.path.isdir(d):
            continue
        for n in names:
            path = os.path.join(d, n)
            if not os.path.exists(path):
                continue
            tried.append(path)
            try:
                return ctypes.WinDLL(path)
            except Exception:
                # 로드 실패 시 다음 후보 계속 시도
                continue

    # 여기까지 도달하면 libmpv 를 전혀 찾지 못한 상태
    raise _MpvLoadError(
        "libmpv DLL을 찾을 수 없습니다.\n"
        "mpv 포터블(zip)을 받아서 libmpv-2.dll 파일을\n"
        "프로그램 exe가 있는 폴더 또는 exe 옆의 mpv/mpv-64 폴더에 복사해 주세요.\n\n"
        "예) Counter_Max.exe 와 같은 폴더에 libmpv-2.dll 또는 mpv/libmpv-2.dll"
    )


class _SimpleMpv:
    """
    libmpv C API 를 ctypes로 직접 호출하는 간단 래퍼.
    - 설치(pip)가 필요 없고, libmpv-2.dll 파일만 있으면 동작합니다.
    - 여기서는 필요한 기능(loadfile, stop, pause, speed, time-pos, duration, volume)만 최소 구현합니다.
    """
    def __init__(self):
        self.lib = _load_libmpv()
        # 함수 시그니처 설정
        self.lib.mpv_create.restype = ctypes.c_void_p
        self.lib.mpv_initialize.argtypes = [ctypes.c_void_p]
        self.lib.mpv_initialize.restype = ctypes.c_int
        self.lib.mpv_terminate_destroy.argtypes = [ctypes.c_void_p]
        self.lib.mpv_terminate_destroy.restype = None
        self.lib.mpv_set_option_string.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p]
        self.lib.mpv_set_option_string.restype = ctypes.c_int
        self.lib.mpv_command.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_char_p)]
        self.lib.mpv_command.restype = ctypes.c_int
        self.lib.mpv_set_property_string.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p]
        self.lib.mpv_set_property_string.restype = ctypes.c_int
        # 문자열 property 조회용
        self.lib.mpv_get_property_string.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        self.lib.mpv_get_property_string.restype = ctypes.c_void_p
        self.lib.mpv_free.argtypes = [ctypes.c_void_p]
        self.lib.mpv_free.restype = None

        self.handle = self.lib.mpv_create()
        if not self.handle:
            raise RuntimeError("mpv_create 실패")

        # 콘솔 메시지 최소화
        self.lib.mpv_set_option_string(self.handle, b"terminal", b"no")
        self.lib.mpv_set_option_string(self.handle, b"msg-level", b"all=no")

        # 초기화
        if self.lib.mpv_initialize(self.handle) < 0:
            raise RuntimeError("mpv_initialize 실패")

    # -------- 내부 유틸 --------
    def _command(self, args):
        # args: [b"loadfile", b"path", b"replace"]
        c_argv = (ctypes.c_char_p * (len(args)+1))()
        for i, a in enumerate(args):
            c_argv[i] = a
        c_argv[len(args)] = None
        return self.lib.mpv_command(self.handle, c_argv)

    def _set_prop_str(self, name, value):
        if isinstance(name, str):
            name = name.encode("utf-8")
        if isinstance(value, str):
            value = value.encode("utf-8")
        return self.lib.mpv_set_property_string(self.handle, name, value)

    def _get_prop_str(self, name):
        if isinstance(name, str):
            name = name.encode("utf-8")
        ptr = self.lib.mpv_get_property_string(self.handle, name)
        if not ptr:
            return None
        try:
            s = ctypes.cast(ptr, ctypes.c_char_p).value
            if s is None:
                return None
            return s.decode("utf-8")
        finally:
            self.lib.mpv_free(ptr)

    # -------- 공개 메서드 --------
    def set_wid(self, wid: int):
        """렌더링 윈도우 핸들 설정 (Windows 전용)."""
        try:
            self._set_prop_str("wid", str(int(wid)))
        except Exception:
            pass

    def loadfile(self, path: str):
        try:
            self._command([b"loadfile", path.encode("utf-8"), b"replace"])
        except Exception:
            pass

    def stop(self):
        try:
            self._command([b"stop"])
        except Exception:
            pass

    @property
    def pause(self) -> bool:
        v = self._get_prop_str("pause")
        if v is None:
            return False
        return v.lower() in ("yes", "1", "true")

    @pause.setter
    def pause(self, flag: bool):
        self._set_prop_str("pause", "yes" if flag else "no")

    @property
    def speed(self) -> float:
        v = self._get_prop_str("speed")
        try:
            return float(v)
        except Exception:
            return 1.0

    @speed.setter
    def speed(self, sp: float):
        try:
            sp = max(0.1, min(16.0, float(sp)))
        except Exception:
            sp = 1.0
        self._set_prop_str("speed", str(sp))

    @property
    def time_pos(self) -> float:
        v = self._get_prop_str("time-pos")
        try:
            return float(v)
        except Exception:
            return 0.0

    @time_pos.setter
    def time_pos(self, sec: float):
        try:
            if sec < 0:
                sec = 0.0
            self._set_prop_str("time-pos", str(float(sec)))
        except Exception:
            pass

    @property
    def duration(self) -> float:
        v = self._get_prop_str("duration")
        try:
            return float(v)
        except Exception:
            return 0.0

    @property
    def volume(self) -> int:
        v = self._get_prop_str("volume")
        try:
            return int(float(v))
        except Exception:
            return 0

    @volume.setter
    def volume(self, val: int):
        try:
            v = max(0, min(100, int(val)))
        except Exception:
            v = 100
        self._set_prop_str("volume", str(v))

    @property
    def eof_reached(self) -> bool:
        v = self._get_prop_str("eof-reached")
        if v is None:
            return False
        return v.lower() in ("yes", "1", "true")

    def terminate(self):
        try:
            if self.handle:
                self.lib.mpv_terminate_destroy(self.handle)
        except Exception:
            pass
        self.handle = None


class MpvAdapter:
    """
    _SimpleMpv 인스턴스를 기존 VLC mediaplayer 인터페이스 비슷하게 래핑.
    - play/pause/stop/is_playing
    - get_time/set_time/get_length
    - set_position/get_position
    - set_rate/get_rate
    - audio_set_volume/audio_get_volume
    """
    def __init__(self, player: _SimpleMpv|None):
        self._p = player

    # --- 재생 제어 ---
    def play(self):
        if self._p is not None:
            self._p.pause = False

    def pause(self):
        if self._p is not None:
            self._p.pause = True

    def stop(self):
        if self._p is not None:
            self._p.stop()

    def is_playing(self):
        if self._p is None:
            return 0
        return 0 if self._p.pause else 1

    # --- 시간/위치 ---
    def get_time(self) -> int:
        if self._p is None:
            return 0
        return int(max(0.0, self._p.time_pos) * 1000.0)

    def set_time(self, ms: int):
        if self._p is None:
            return
        self._p.time_pos = float(ms) / 1000.0

    def get_length(self) -> int:
        if self._p is None:
            return 0
        return int(max(0.0, self._p.duration) * 1000.0)

    def set_position(self, p: float):
        if self._p is None:
            return
        dur = self._p.duration
        if dur <= 0:
            return
        p = max(0.0, min(1.0, float(p)))
        self._p.time_pos = dur * p

    def get_position(self) -> float:
        if self._p is None:
            return 0.0
        dur = self._p.duration
        if dur <= 0:
            return 0.0
        return max(0.0, min(1.0, float(self._p.time_pos) / float(dur)))

    # --- 배속 ---
    def set_rate(self, r: float):
        if self._p is None:
            return
        self._p.speed = r

    def get_rate(self) -> float:
        if self._p is None:
            return 1.0
        return float(self._p.speed)

    # --- 볼륨 ---
    def audio_set_volume(self, v: int):
        if self._p is None:
            return
        self._p.volume = v

    def audio_get_volume(self) -> int:
        if self._p is None:
            return 0
        return int(self._p.volume)

# ==== App const ====
APP_NAME   = "Traffic Counter Enterprise MAX — v9.2 Fluent Dark"
DB_PATH    = Path(__file__).with_name("traffic_counter.db")
SLOT_SEC   = 15*60  # 15분 슬롯
AUTOSAVE_S = 5      # 5초마다 자동 저장

# ==== ENV hotkeys DB (from env_hotkey97_fixed_displayname) ====
import json as _json
import re as _re

_LAST_ENV_DB_PATH = ''
_LAST_HK_DB_PATH = ''

def detect_data_root_env_compatible() -> str:
    """env_settings와 동일한 규칙 + 파일 존재 검증으로 DATA_ROOT를 추정합니다.

    우선순위:
      1) 환경변수 COUNTERMAX_DATA_ROOT (Survey 데이터 파일이 실제 존재할 때만)
      2) 드라이브/UNC 후보 (Survey 데이터 파일이 실제 존재할 때만)
      3) 실행 폴더(로컬)
    """
    def _looks_like_root(root: str) -> bool:
        if not root or not os.path.isdir(root):
            return False
        candidates = [
            os.path.join(root, "env_data_plus_allinone.json"),
            os.path.join(root, "hotkeys_db.json"),
            os.path.join(root, "survey", "env_data_plus_allinone.json"),
            os.path.join(root, "survey", "hotkeys_db.json"),
            os.path.join(root, "Survey", "env_data_plus_allinone.json"),
            os.path.join(root, "Survey", "hotkeys_db.json"),
        ]
        return any(os.path.isfile(p) for p in candidates)

    env = os.environ.get("COUNTERMAX_DATA_ROOT", "").strip()
    if env and _looks_like_root(env):
        return env

    # 사용자 환경에서 흔히 쓰는 순서로 우선 탐색 (Y -> Z -> K)
    for cand in [
        r"Y:\Survey",
        r"Z:\Survey",
        r"K:\Survey",
        r"\\192.168.35.239\Survey",
        r"\\192.168.35.239@5096\DavWWWRoot\Survey",
    ]:
        try:
            if _looks_like_root(cand):
                return cand
        except Exception:
            pass

    return str(Path(__file__).resolve().parent)

def hotkeys_db_path_candidates() -> list[str]:
    root = detect_data_root_env_compatible()
    cands: list[str] = []

    # 1) DATA_ROOT 자체가 Survey 루트인 경우 (예: Y:\Survey\hotkeys_db.json)
    cands.append(os.path.join(root, "hotkeys_db.json"))

    # 2) DATA_ROOT가 상위 폴더인 경우 (예: Y:\Survey\survey\hotkeys_db.json, Y:\Survey\Survey\hotkeys_db.json)
    cands.append(os.path.join(root, "survey", "hotkeys_db.json"))
    cands.append(os.path.join(root, "Survey", "hotkeys_db.json"))

    # 3) 로컬 실행(스크립트 동일 폴더) 대비
    cands.append(str(Path(__file__).with_name("hotkeys_db.json")))

    # 중복 제거(순서 유지)
    seen=set()
    out=[]
    for p in cands:
        p=os.path.normpath(p)
        if p not in seen:
            seen.add(p); out.append(p)
    return out



def env_db_path_candidates() -> List[str]:
    """Return candidate paths for env_data_plus_allinone.json (tries both root and root/Survey)."""
    env_name = "env_data_plus_allinone.json"
    roots: List[str] = []

    # 1) Environment overrides
    for k in ("SURVEY_ROOT", "DATA_ROOT", "COUNTERMAX_DATA_ROOT"):
        v = os.environ.get(k, "").strip()
        if v:
            roots.append(v)

    # 2) Common drive mappings / folders
    roots.extend([
        r"Y:\Survey",
        r"Z:\Survey",
        r"D:\Survey",
        r"C:\Survey",
        os.path.join(os.path.expanduser("~"), "Survey"),
    ])

    # 3) Working dirs
    try:
        roots.append(str(Path(__file__).resolve().parent))
    except Exception:
        pass
    try:
        roots.append(os.getcwd())
    except Exception:
        pass

    # Build candidates (both <root>/<env> and <root>/Survey/<env>)
    cands: List[str] = []
    seen = set()
    for r in roots:
        if not r:
            continue
        r = os.path.normpath(r)
        for p in (
            os.path.join(r, env_name),
            os.path.join(r, "Survey", env_name),
        ):
            p = os.path.normpath(p)
            if p not in seen:
                seen.add(p)
                cands.append(p)
    return cands


def best_env_db_path() -> Optional[str]:
    """Pick the first existing env db path from candidates."""
    global _LAST_ENV_DB_PATH
    for p in env_db_path_candidates():
        try:
            if os.path.isfile(p):
                _LAST_ENV_DB_PATH = p
                return p
        except Exception:
            continue
    # Fallback: if HK DB is found, try sibling env file in same folder.
    try:
        hk = best_hotkeys_db_path()
        if hk:
            base_dir = os.path.dirname(hk)
            for cand in [
                os.path.join(base_dir, "env_data_plus_allinone.json"),
                os.path.join(base_dir, "env_data_plus_allinone.JSON"),
                os.path.join(base_dir, "env_data_plus_allinone.json".lower()),
            ]:
                if os.path.isfile(cand):
                    _LAST_ENV_DB_PATH = cand
                    return cand
            # One level up (in case hk stored under Survey/)
            parent_dir = os.path.dirname(base_dir)
            cand = os.path.join(parent_dir, "env_data_plus_allinone.json")
            if os.path.isfile(cand):
                _LAST_ENV_DB_PATH = cand
                return cand
    except Exception:
        pass
    return None


def best_hotkeys_db_path() -> Optional[str]:
    """Pick the first existing hotkeys_db.json path from candidates."""
    global _LAST_HK_DB_PATH
    for p in hotkeys_db_path_candidates():
        try:
            if os.path.isfile(p):
                _LAST_HK_DB_PATH = p
                return p
        except Exception:
            continue
    return None
def load_hotkeys_db() -> dict:
    """Load env hotkeys DB.

    우선순위:
      1) hotkeys_db.json (NAS survey 폴더)
      2) env_data_plus_allinone.json (환경설정 메인 DB)에서 surveys만 추출
    """
    # 1) hotkeys_db.json
    for p in hotkeys_db_path_candidates():
        try:
            if os.path.isfile(p):
                with open(p, "r", encoding="utf-8") as f:
                    global _LAST_HK_DB_PATH
                    _LAST_HK_DB_PATH = p
                    return _json.load(f) or {}
        except Exception:
            continue

    # 2) env_data_plus_allinone.json (fallback)
    try:
        root = detect_data_root_env_compatible()
        env_paths = [
            os.path.join(root, "env_data_plus_allinone.json"),
            # DATA_ROOT가 상위일 수도 있어 survey/Projects 구조를 쓰는 경우 대비
            os.path.join(root, "survey", "env_data_plus_allinone.json"),
            str(Path(__file__).with_name("env_data_plus_allinone.json")),
        ]
        for p in env_paths:
            try:
                if os.path.isfile(p):
                    with open(p, "r", encoding="utf-8") as f:
                        data = _json.load(f) or {}
                    # env DB는 {"surveys":[...]} 구조
                    if isinstance(data, dict) and isinstance(data.get("surveys"), list):
                        return {"surveys": data.get("surveys", [])}
            except Exception:
                continue
    except Exception:
        pass

    return {}

# ==== Helpers ====
def load_env_db() -> dict:
    """환경설정 메인 DB(env_data_plus_allinone.json)를 로드합니다.
    - best_env_db_path() 로 경로를 확정(핫키 DB 위치 기반 fallback 포함)
    """
    env_path = None
    try:
        env_path = best_env_db_path()
    except Exception:
        env_path = None

    if not env_path or not os.path.isfile(env_path):
        return {}

    try:
        with open(env_path, "r", encoding="utf-8") as f:
            return json.load(f) or {}
    except Exception:
        # 손상/부분저장 등 대비
        try:
            with open(env_path, "r", encoding="utf-8-sig") as f:
                return json.load(f) or {}
        except Exception:
            return {}


# ==== Site Hotkeys helpers (v51) ====
def build_site_hotkeys_from_cfg(cfg, site_obj=None):
    """현재 cfg.dir_hotkeys 를 site_*.json에 저장 가능한 형태로 변환.
    반환:
      {
        "vehicle_names": [...],
        "by_dir": {"1":[...], "2":[...], ...}
      }
    """
    try:
        # vehicle names: site counters 우선
        veh_names = []
        if isinstance(site_obj, dict):
            for c in (site_obj.get("counters") or []):
                if isinstance(c, dict):
                    nm = str(c.get("name") or c.get("display") or "").strip()
                    if nm:
                        veh_names.append(nm)
        if not veh_names:
            try:
                veh_names = [str(x) for x in (getattr(cfg, "vehicle_types", None) or []) if str(x).strip()]
            except Exception:
                veh_names = []
        if not veh_names:
            # fallback: cfg.vehicle_count()
            try:
                vc = int(getattr(cfg, "vehicle_count", lambda: 6)())
            except Exception:
                vc = 6
            veh_names = [f"차종{idx+1}" for idx in range(vc)]

        # cfg.dir_hotkeys: list-of-lists indexed by didx 0..11
        by_dir = {}
        try:
            dh = getattr(cfg, "dir_hotkeys", None)
        except Exception:
            dh = None
        if not isinstance(dh, list):
            dh = []
        for dirno in range(1, 13):
            didx = dirno - 1
            keys = []
            if 0 <= didx < len(dh) and isinstance(dh[didx], list):
                keys = [str(k) for k in dh[didx]]
            # normalize length to veh_names
            if len(keys) < len(veh_names):
                keys = keys + [""] * (len(veh_names) - len(keys))
            if len(keys) > len(veh_names):
                keys = keys[:len(veh_names)]
            by_dir[str(dirno)] = keys
        return {"vehicle_names": veh_names, "by_dir": by_dir}
    except Exception:
        return {"vehicle_names": [], "by_dir": {}}

def _update_envdb_site_hotkeys_on_disk(info_obj, site_obj, hotkeys_payload):
    """env_data_plus_allinone.json 내부의 해당 과업/지점에 site_hotkeys를 기록(가능한 경우).
    실패해도 예외를 올리지 않습니다.
    """
    try:
        env_path = best_env_db_path()
        if not env_path or not os.path.isfile(env_path):
            return
        try:
            with open(env_path, "r", encoding="utf-8") as f:
                envdb = json.load(f) or {}
        except Exception:
            try:
                with open(env_path, "r", encoding="utf-8-sig") as f:
                    envdb = json.load(f) or {}
            except Exception:
                return

        surveys = envdb.get("surveys") or []
        if not isinstance(surveys, list):
            return

        sn_hint = None
        try:
            if isinstance(info_obj, dict):
                sn_hint = info_obj.get("sn") or info_obj.get("survey_no") or info_obj.get("id")
        except Exception:
            sn_hint = None

        # site match keys
        wno = None
        jb = None
        nm = None
        try:
            if isinstance(site_obj, dict):
                wno = str(site_obj.get("작업번호") or site_obj.get("work_no") or site_obj.get("id") or "").strip()
                jb = str(site_obj.get("지번") or site_obj.get("jibun") or "").strip()
                nm = str(site_obj.get("지점명") or site_obj.get("name") or "").strip()
        except Exception:
            pass

        def _match_site(s):
            if not isinstance(s, dict):
                return False
            sw = str(s.get("작업번호") or s.get("work_no") or s.get("id") or "").strip()
            if wno and sw and wno == sw:
                return True
            sj = str(s.get("지번") or s.get("jibun") or "").strip()
            snm = str(s.get("지점명") or s.get("name") or "").strip()
            if (jb and nm) and (sj and snm) and (jb == sj) and (nm == snm):
                return True
            return False

        # survey match
        target_survey = None
        if sn_hint:
            for s in surveys:
                if isinstance(s, dict) and str(s.get("sn") or s.get("survey_no") or s.get("id") or "").strip() == str(sn_hint).strip():
                    target_survey = s
                    break
        if target_survey is None:
            # fallback: name
            nm_hint = ""
            try:
                nm_hint = str(info_obj.get("name") or info_obj.get("조사명") or "").strip() if isinstance(info_obj, dict) else ""
            except Exception:
                nm_hint = ""
            if nm_hint:
                for s in surveys:
                    if isinstance(s, dict):
                        info = s.get("info") if isinstance(s.get("info"), dict) else {}
                        if str(info.get("name") or s.get("name") or "").strip() == nm_hint:
                            target_survey = s
                            break
        if target_survey is None:
            return

        sites = target_survey.get("sites") or []
        if isinstance(sites, dict):
            sites = list(sites.values())
        if not isinstance(sites, list):
            return

        for s in sites:
            if _match_site(s):
                s["site_hotkeys"] = hotkeys_payload.get("by_dir") or {}
                s["site_hotkeys_vehicle_names"] = hotkeys_payload.get("vehicle_names") or []
                break
        else:
            return

        # write back
        with open(env_path, "w", encoding="utf-8") as f:
            json.dump(envdb, f, ensure_ascii=False, indent=2)
    except Exception:
        return

def sha256(x: str) -> str:
    return hashlib.sha256(x.encode('utf-8')).hexdigest()

def hm(sec:int)->str:
    sec = sec % 86400
    h = sec // 3600
    m = (sec % 3600) // 60
    return f"{h:02d}:{m:02d}"

def slot_label(start_sec:int)->str:
    end_sec = (start_sec + SLOT_SEC) % 86400
    return f"{hm(start_sec)}~{hm(end_sec)}"

def slot_index(start_sec:int)->int:
    return (start_sec // SLOT_SEC) + 1

# ==== DB ====
def db_connect()->sqlite3.Connection:
    conn=sqlite3.connect(DB_PATH)
    conn.execute("PRAGMA foreign_keys=ON;")
    return conn

def db_init():
    conn=db_connect(); c=conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS users(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        role TEXT NOT NULL CHECK(role in ('admin','operator')),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)""")
    c.execute("""CREATE TABLE IF NOT EXISTS logs(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        video_path TEXT, video_ms INTEGER, interval_index INTEGER,
        direction TEXT, vehicle TEXT, delta INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE)""")
    if c.execute("SELECT COUNT(*) FROM users").fetchone()[0]==0:
        c.execute("INSERT INTO users(username,password_hash,role) VALUES(?,?,?)", ("admin", sha256("1234"), "admin"))
        c.execute("INSERT INTO users(username,password_hash,role) VALUES(?,?,?)", ("test01", sha256("01050353316"), "operator"))
    conn.commit(); conn.close()

def user_verify(u,p):
    conn=db_connect(); c=conn.cursor()
    c.execute("SELECT id,username,password_hash,role FROM users WHERE username=?",(u,))
    r=c.fetchone(); conn.close()
    return {"id":r[0],"username":r[1],"role":r[3]} if r and sha256(p)==r[2] else None

def users_all():
    conn=db_connect(); c=conn.cursor()
    c.execute("SELECT id, username, role, datetime(created_at,'localtime') FROM users ORDER BY id")
    rows=c.fetchall(); conn.close(); return rows

def user_add(u,p,role):
    conn=db_connect(); c=conn.cursor()
    c.execute("INSERT INTO users(username,password_hash,role) VALUES(?,?,?)",(u,sha256(p),role))
    conn.commit(); conn.close()

def user_update(i,u,role):
    conn=db_connect(); c=conn.cursor()
    c.execute("UPDATE users SET username=?, role=? WHERE id=?", (u,role,i)); conn.commit(); conn.close()

def user_delete(i):
    conn=db_connect(); c=conn.cursor()
    c.execute("DELETE FROM users WHERE id=?", (i,)); conn.commit(); conn.close()

def user_reset_password(i,p):
    conn=db_connect(); c=conn.cursor()
    c.execute("UPDATE users SET password_hash=? WHERE id=?", (sha256(p),i)); conn.commit(); conn.close()

def log_event(uid, vpath, vms, idx, d, v, delta):
    conn=db_connect(); c=conn.cursor()
    c.execute("""INSERT INTO logs(user_id,video_path,video_ms,interval_index,direction,vehicle,delta)
                 VALUES(?,?,?,?,?,?,?)""",(uid,vpath,vms,idx,d,v,delta))
    conn.commit(); conn.close()

def logs_export_csv(path:str):
    conn=db_connect()
    df=pd.read_sql_query("""SELECT l.id, datetime(l.created_at,'localtime') AS time, u.username, u.role,
                                   l.video_path, l.video_ms, l.interval_index, l.direction, l.vehicle, l.delta
                            FROM logs l JOIN users u ON l.user_id=u.id ORDER BY l.id""", conn)
    conn.close(); df.to_csv(path, index=False, encoding="utf-8-sig")

# ==== Data model ====
@dataclass
class ProjectConfig:
    def vehicle_count(self):
        return len(self.vehicle_types) if hasattr(self, 'vehicle_types') else 6
    directions: List[str]   = field(default_factory=lambda: [f"{i}번방향" for i in range(1,31)])
    enabled_directions: List[bool] = field(default_factory=lambda: [True]*12 + [False]*18)
    def get_enabled_indices(self):
        return [i for i, ok in enumerate(self.enabled_directions) if ok and i < len(self.directions)]

    vehicle_types: List[str]= field(default_factory=lambda: ["승용차","소형버스","대형버스","소형화물","중형화물","대형화물"])
    site_name: str          = "지점명"
    survey_date: str        = ""
    active_windows: List[Tuple[int,int]] = field(default_factory=lambda: [(7*3600, 9*3600), (12*3600, 14*3600), (17*3600, 19*3600)])
    dir_hotkeys: List[List[str]] = field(default_factory=lambda: [ (["1","2","3","4","5","6"] if i % 3 == 0 else ["Q","W","E","R","T","Y"] if i % 3 == 1 else ["A","S","D","F","G","H"]) for i in range(12) ])

class CountTable(QtCore.QObject):
    changed = QtCore.pyqtSignal()
    def __init__(self, dirs, vehs):
        super().__init__(); self.directions=dirs; self.vehicle_types=vehs
        self.table: Dict[int, Dict[Tuple[str,str], int]] = {}
        self.labels: Dict[int, str] = {}
    def ensure_interval(self, idx:int, label:str):
        if idx not in self.table: self.table[idx] = {(d,v):0 for d in self.directions for v in self.vehicle_types}
        self.labels[idx]=label
    def inc(self, idx:int, label:str, d:str, v:str, delta:int=1):
        self.ensure_interval(idx,label)
        k=(d,v); self.table[idx][k]=max(0, self.table[idx].get(k,0)+delta); self.changed.emit()
    def clear_interval(self, idx:int, label:str):
        self.table[idx] = {(d,v):0 for d in self.directions for v in self.vehicle_types}
        self.labels[idx]=label; self.changed.emit()
    def to_long_df(self)->pd.DataFrame:
        rows=[]; 
        for idx,counts in sorted(self.table.items()):
            for (d,v),c in counts.items():
                rows.append({"slot_index":idx, "slot_label":self.labels.get(idx,""), "direction":d, "vehicle":v, "count":c})
        return pd.DataFrame(rows)
    def to_sheet_df_per_direction(self, cfg:ProjectConfig, dirno:int)->pd.DataFrame:
        labels = []
        for s,e in sorted(cfg.active_windows):
            t=s
            while t<e:
                labels.append(f"{hm(t)}~{hm((t+SLOT_SEC)%86400)}")
                t+=SLOT_SEC
        labels = list(dict.fromkeys(labels))
        vehicles = cfg.vehicle_types[:cfg.vehicle_count()]
        out = pd.DataFrame({"시간대": labels})
        df = self.to_long_df()
        if df.empty:
            for v in vehicles: out[v] = 0
            return out
        dname=f"{dirno}번방향"
        df=df[df["direction"]==dname]
        if df.empty:
            for v in vehicles: out[v] = 0
            return out
        pv=df.pivot_table(index="slot_label", columns="vehicle", values="count", aggfunc="sum", fill_value=0)
        pv = pv.reindex(index=out["시간대"], fill_value=0)
        for v in vehicles:
            out[v] = pv[v].to_numpy() if v in pv.columns else 0
        return out

# ==== Player ====

class MpvVideoWidget(QtWidgets.QFrame):
    positionChanged = QtCore.pyqtSignal(float)
    timeChanged = QtCore.pyqtSignal(int)
    mediaEnded = QtCore.pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self._player_core = None
        try:
            self._player_core = _SimpleMpv()
        except _MpvLoadError as e:
            # libmpv DLL 자체를 찾지 못한 경우: 친절한 안내 후 더미 플레이어로 진행
            QtWidgets.QMessageBox.critical(
                self,
                "mpv 구성 파일 없음",
                str(e)
            )
            self._player_core = None
        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self,
                "mpv 초기화 오류",
                f"mpv 초기화에 실패했습니다.\\n{e}"
            )
            self._player_core = None

        self.mediaplayer = MpvAdapter(self._player_core)

        self.timer = QtCore.QTimer(self)
        self.timer.setInterval(40)  # 25fps 기준
        self.timer.timeout.connect(self.update_ui)

        self.setFrameShape(QtWidgets.QFrame.Shape.StyledPanel)
        self._eof_emitted = False
        self._last_is_playing = False  # legacy flag (not used in new EOF detection)
        self._last_pos = 0.0          # 마지막으로 관측한 재생 위치(0.0~1.0)

    def showEvent(self, event: QtGui.QShowEvent) -> None:
        super().showEvent(event)
        # 위젯이 실제 화면에 배치된 후 윈도우 핸들을 mpv에 연결
        try:
            if self._player_core is not None:
                wid = int(self.winId())
                self._player_core.set_wid(wid)
        except Exception:
            pass

    # ---- 기존 VlcVideoWidget 과 동일하게 보이는 퍼블릭 메서드 ----
    def set_media(self, filepath: str):
        if self._player_core is None:
            return
        try:
            self._player_core.loadfile(filepath)
        except Exception:
            pass

    def play(self):
        try:
            self.mediaplayer.play()
            self.timer.start()
        except Exception:
            pass

    def pause(self):
        try:
            self.mediaplayer.pause()
        except Exception:
            pass

    def stop(self):
        try:
            self.mediaplayer.stop()
        finally:
            self.timer.stop()

    def is_playing(self):
        try:
            return self.mediaplayer.is_playing()
        except Exception:
            return 0

    def get_time_ms(self) -> int:
        try:
            return self.mediaplayer.get_time()
        except Exception:
            return 0

    def set_time_ms(self, ms: int):
        try:
            self.mediaplayer.set_time(ms)
        except Exception:
            pass

    def length_ms(self) -> int:
        try:
            return self.mediaplayer.get_length()
        except Exception:
            return 0

    def set_position(self, p: float):
        try:
            self.mediaplayer.set_position(p)
        except Exception:
            pass

    def get_position(self) -> float:
        try:
            return self.mediaplayer.get_position()
        except Exception:
            return 0.0

    def set_rate(self, r: float):
        try:
            self.mediaplayer.set_rate(r)
        except Exception:
            pass

    def get_rate(self) -> float:
        try:
            return self.mediaplayer.get_rate()
        except Exception:
            return 1.0

    def audio_set_volume(self, v: int):
        try:
            self.mediaplayer.audio_set_volume(v)
        except Exception:
            pass

    def update_ui(self):
        """플레이어 상태 폴링 + EOF(재생 종료) 감지.

        - 1차: mpv의 eof-reached property 사용
        - 2차: 남은 시간이 아주 짧을 때(프레임/시간 기반) EOF로 간주
        """
        # 위치/시간 갱신
        pos = None
        cur_time_ms = 0
        length_ms = 0
        try:
            pos = self.get_position()
            self.positionChanged.emit(pos)
        except Exception:
            pass
        try:
            cur_time_ms = self.get_time_ms()
            self.timeChanged.emit(cur_time_ms)
        except Exception:
            pass
        try:
            length_ms = self.length_ms()
        except Exception:
            length_ms = 0

        # EOF 감지
        try:
            core = self._player_core

            # 남은 시간(ms) 계산 (mpv가 보고하는 duration/time-pos 기반)
            try:
                remain_ms = 0
                if length_ms > 0:
                    remain_ms = max(0, int(length_ms) - int(cur_time_ms))
            except Exception:
                remain_ms = 0

            # 1) mpv의 eof-reached 값 우선 사용
            core_eof = bool(getattr(core, "eof_reached", False)) if core is not None else False
            if core_eof and not self._eof_emitted:
                self._eof_emitted = True
                self.mediaEnded.emit()
            else:
                # 2) 시간/프레임 기반 Fallback:
                #    - 길이가 0이 아니고
                #    - 남은 시간이 0.8초 이내일 때 한 번만 EOF로 간주
                if length_ms > 0 and remain_ms <= 800 and not self._eof_emitted:
                    self._eof_emitted = True
                    self.mediaEnded.emit()

                # 앞부분으로 충분히 이동한 경우 EOF 플래그 리셋
                try:
                    if length_ms > 0:
                        # 현재 위치 비율이 0.95 미만이면 새 재생으로 간주하고 리셋
                        cur_pos = float(pos if pos is not None else 0.0)
                        if cur_pos < 0.95:
                            self._eof_emitted = False
                except Exception:
                    pass
        except Exception:
            pass


# ==== Dialogs ====


class VehicleTypeSettingsDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, cfg:ProjectConfig=None):
        super().__init__(parent); self.setWindowTitle("차종 구분 설정 (1~12종)"); self.cfg=cfg
        self.resize(560, 520)
        v=QtWidgets.QVBoxLayout(self)
        top=QtWidgets.QHBoxLayout()
        top.addWidget(QtWidgets.QLabel("차종 수:"))
        self.countCombo=QtWidgets.QComboBox()
        for i in range(1,13): self.countCombo.addItem(str(i), i)
        self.countCombo.setCurrentIndex(max(0, min(11, cfg.vehicle_count()-1)))
        top.addWidget(self.countCombo); top.addStretch(1)
        self.btnPreset10 = QtWidgets.QPushButton("10종 예시 불러오기")
        self.btnPreset12 = QtWidgets.QPushButton("12종 예시 불러오기")
        top.addWidget(self.btnPreset10); top.addWidget(self.btnPreset12)
        v.addLayout(top)
        self.table=QtWidgets.QTableWidget(0,2); self.table.setHorizontalHeaderLabels(["종번호","명칭"])
        self.table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
        v.addWidget(self.table,1)
        btns=QtWidgets.QHBoxLayout()
        self.btnAdd=QtWidgets.QPushButton("행 추가"); self.btnDel=QtWidgets.QPushButton("행 삭제")
        btns.addWidget(self.btnAdd); btns.addWidget(self.btnDel); btns.addStretch(1)
        v.addLayout(btns)
        bb=QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.StandardButton.Ok|QtWidgets.QDialogButtonBox.StandardButton.Cancel)
        v.addWidget(bb)
        self.btnAdd.clicked.connect(self.on_add); self.btnDel.clicked.connect(self.on_del)
        self.countCombo.currentIndexChanged.connect(self.on_count_change)
        self.btnPreset10.clicked.connect(self.load_preset10); self.btnPreset12.clicked.connect(self.load_preset12)
        bb.accepted.connect(self.apply); bb.rejected.connect(self.reject)
        self.load_from_cfg()

    def load_from_cfg(self):
        items = list(self.cfg.vehicle_types)
        self.table.setRowCount(0)
        for i, name in enumerate(items, start=1):
            self._add_row(i, name)

    def on_count_change(self, _):
        n = int(self.countCombo.currentData())
        cur = self.table.rowCount()
        if n > 12: n = 12
        if n < 1: n = 1
        if n > cur:
            for i in range(cur+1, n+1):
                self._add_row(i, f"{i}종")
        elif n < cur:
            for _ in range(cur-n):
                self.table.removeRow(self.table.rowCount()-1)

    def _add_row(self, idx, name):
        r = self.table.rowCount()
        self.table.insertRow(r)
        item_idx = QtWidgets.QTableWidgetItem(str(idx)); item_idx.setFlags(item_idx.flags() & ~QtCore.Qt.ItemFlag.ItemIsEditable)
        self.table.setItem(r, 0, item_idx)
        self.table.setItem(r, 1, QtWidgets.QTableWidgetItem(name))

    def on_add(self):
        if self.table.rowCount() >= 12:
            QtWidgets.QMessageBox.information(self,"안내","최대 12종까지 가능합니다."); return
        self._add_row(self.table.rowCount()+1, f"{self.table.rowCount()+1}종")
        self.countCombo.setCurrentIndex(self.table.rowCount()-1)

    def on_del(self):
        if self.table.rowCount() <= 1:
            QtWidgets.QMessageBox.information(self,"안내","최소 1종은 필요합니다."); return
        self.table.removeRow(self.table.rowCount()-1)
        self.countCombo.setCurrentIndex(self.table.rowCount()-1)

    def load_preset10(self):
        names = ["승용","승합","택시","버스중형","버스대형","소형화물","중형화물","대형화물","트레일러","이륜"]
        self.table.setRowCount(0)
        for i, n in enumerate(names, start=1): self._add_row(i, n)
        self.countCombo.setCurrentIndex(9)

    def load_preset12(self):
        names = ["승용","버스","소형트럭","중형트럭","1단위3축","1단위4축","1단위5축","4축세미","4축 풀","5축세미","5축 풀","6축세미"]
        self.table.setRowCount(0)
        for i, n in enumerate(names, start=1): self._add_row(i, n)
        self.countCombo.setCurrentIndex(11)

    def apply(self):
        n = self.table.rowCount()
        names = []
        for r in range(n):
            name = self.table.item(r,1).text().strip() if self.table.item(r,1) else f"{r+1}종"
            names.append(name or f"{r+1}종")
        self.cfg.vehicle_types = names
        self.accept()

class DirectionSettingsDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, cfg:ProjectConfig=None):
        super().__init__(parent); self.setWindowTitle("방향 표시 설정 (최대 30)"); self.cfg=cfg
        # Force visible checkbox indicators across themes
        self.setStyleSheet("""
        QCheckBox::indicator { width:16px; height:16px; }
        QCheckBox::indicator:unchecked { image: none; border:1px solid #666; background:#fff; }
        QCheckBox::indicator:checked   { image: none; border:1px solid #2b7cff; background:#2b7cff; }
        """)

        self.resize(560, 520)
        v=QtWidgets.QVBoxLayout(self)
        info = QtWidgets.QLabel("표시할 방향을 체크하세요. 체크 해제된 방향은 계수창에서 숨겨집니다.")
        v.addWidget(info)
        grid=QtWidgets.QGridLayout(); v.addLayout(grid)
        self.checks=[]
        for i in range(30):
            name = cfg.directions[i] if i < len(cfg.directions) else f"{i+1}번방향"
            chk = QtWidgets.QCheckBox(name)
            chk.setTristate(False)
            chk.setEnabled(True)
            if i < len(cfg.enabled_directions):
                chk.setChecked(cfg.enabled_directions[i])
            else:
                chk.setChecked(False)
            self.checks.append(chk)
            grid.addWidget(chk, i//3, i%3)
        bb=QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.StandardButton.Ok|QtWidgets.QDialogButtonBox.StandardButton.Cancel)
        v.addWidget(bb)
        bb.accepted.connect(self.apply); bb.rejected.connect(self.reject)
    def apply(self):
        # normalize to length 30
        flags=[c.isChecked() for c in self.checks]
        # Keep at least one enabled
        if not any(flags):
            QtWidgets.QMessageBox.warning(self,"오류","최소 1개 방향을 선택해야 합니다.")
            return
        self.cfg.enabled_directions = flags
        self.accept()

class HotkeySettingsDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, cfg=None):
        super().__init__(parent); self.setWindowTitle("단축키 설정 (방향별)"); self.cfg=cfg
        v=QtWidgets.QVBoxLayout(self)
        self.dirCombo=QtWidgets.QComboBox(); self.dirCombo.addItems(cfg.directions[:30]); v.addWidget(self.dirCombo)
        form=QtWidgets.QFormLayout(); v.addLayout(form)
        # helper must be defined BEFORE use
        self.safe_key = lambda c, d, i: (c.dir_hotkeys[d][i] if d < len(c.dir_hotkeys) and i < len(c.dir_hotkeys[d]) else "")
        vc = cfg.vehicle_count()
        self.edits=[QtWidgets.QLineEdit(self.safe_key(cfg, 0, i)) for i in range(vc)]
        for i,e in enumerate(self.edits):
            e.setMaxLength(10)
            label = cfg.vehicle_types[i] if i < len(cfg.vehicle_types) else f"{i+1}종"
            form.addRow(f"{label} 키", e)
        hl=QtWidgets.QHBoxLayout(); self.btnApply=QtWidgets.QPushButton("현재 방향에 적용"); self.btnCopyAll=QtWidgets.QPushButton("모든 방향에 동일 적용"); hl.addWidget(self.btnApply); hl.addWidget(self.btnCopyAll); v.addLayout(hl)
        bb=QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.StandardButton.Close); v.addWidget(bb)
        self.dirCombo.currentIndexChanged.connect(self.on_dir_change); self.btnApply.clicked.connect(self.apply_current); self.btnCopyAll.clicked.connect(self.apply_all); bb.rejected.connect(self.reject); bb.accepted.connect(self.accept)
        self.on_dir_change(0)
    def on_dir_change(self, idx:int):
        vc = self.cfg.vehicle_count()
        keys = self.cfg.dir_hotkeys[idx] if idx < len(self.cfg.dir_hotkeys) else []
        # normalize keys length to vc
        keys = (keys + [""]*vc)[:vc]
        for i,e in enumerate(self.edits):
            e.setText(keys[i] if i < len(keys) else "")
    def apply_current(self):
        """Apply current direction edits into cfg.dir_hotkeys."""
        idx = int(self.dirCombo.currentIndex())
        keys = []
        for e in self.edits:
            k = (e.text() or "").strip().upper()
            # allow empty -> keep empty
            keys.append(k)
        # ensure length matches vehicle rows
        if idx < 0:
            return
        # expand cfg.dir_hotkeys if needed
        if not hasattr(self.cfg, "dir_hotkeys") or self.cfg.dir_hotkeys is None:
            self.cfg.dir_hotkeys = []
        while len(self.cfg.dir_hotkeys) <= idx:
            self.cfg.dir_hotkeys.append([""] * len(keys))
        self.cfg.dir_hotkeys[idx] = keys
        QtWidgets.QMessageBox.information(self, "안내", "적용되었습니다.")

    def accept(self):
        # When closing with OK, ensure the current direction edits are applied.
        try:
            self.apply_current()
        except Exception:
            pass
        super().accept()

    def apply_all(self):
        keys=[e.text().strip() for e in self.edits]
        vc = self.cfg.vehicle_count()
        max_dirs = min(30, len(self.cfg.directions))
        for i in range(max_dirs):
            row = keys[:vc]
            if i < len(self.cfg.dir_hotkeys):
                # normalize existing row length
                self.cfg.dir_hotkeys[i] = (row + [""]*vc)[:vc]
            else:
                self.cfg.dir_hotkeys.append((row + [""]*vc)[:vc])
        QtWidgets.QMessageBox.information(self,"안내","모든 방향에 동일 키로 적용되었습니다.")

class CountWindowDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, cfg:ProjectConfig=None):
        super().__init__(parent)
        self.setWindowTitle("카운팅 구간 설정")
        self.cfg = cfg
        # target size similar to screenshot
        self.resize(640, 560)

        v = QtWidgets.QVBoxLayout(self)

        # top row: time edits + buttons
        row = QtWidgets.QHBoxLayout()
        lbl_start = QtWidgets.QLabel("시작")
        self.start = QtWidgets.QTimeEdit(QtCore.QTime(0,0))
        self.start.setDisplayFormat("HH:mm")
        self.start.setFixedHeight(28); self.start.setFixedWidth(80)

        lbl_wave = QtWidgets.QLabel("~")

        self.end = QtWidgets.QTimeEdit(QtCore.QTime(0,0))
        self.end.setDisplayFormat("HH:mm")
        self.end.setFixedHeight(28); self.end.setFixedWidth(80)

        self.addBtn   = QtWidgets.QPushButton("등록(추가)")
        self.editBtn  = QtWidgets.QPushButton("수정")
        self.delBtn   = QtWidgets.QPushButton("삭제")
        self.clearBtn = QtWidgets.QPushButton("초기화")
        for b in (self.addBtn, self.editBtn, self.delBtn, self.clearBtn):
            b.setFixedHeight(28); b.setMinimumWidth(80)

        for w in (lbl_start, self.start, lbl_wave, self.end,
                  self.addBtn, self.editBtn, self.delBtn, self.clearBtn):
            row.addWidget(w)
        row.addStretch(1)
        v.addLayout(row)

        # top list: fixed ~100px
        self.list = QtWidgets.QListWidget()
        self.list.setFixedHeight(100)
        _fl = self.list.font(); _fl.setPointSize(10); self.list.setFont(_fl)
        v.addWidget(self.list, 0)

        # bottom preview table: fill remaining space
        self.preview = QtWidgets.QTableWidget(0, 3)
        self.preview.setHorizontalHeaderLabels(["번호","시작","종료"])
        self.preview.setSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding,
                                   QtWidgets.QSizePolicy.Policy.Expanding)
        self.preview.setMinimumHeight(320)
        self.preview.setAlternatingRowColors(True)
        self.preview.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.preview.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.preview.verticalHeader().setVisible(False)
        _ft = self.preview.font(); _ft.setPointSize(10); self.preview.setFont(_ft)
        h = self.preview.horizontalHeader()
        h.setStretchLastSection(True)
        h.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeMode.ResizeToContents)
        h.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeMode.Stretch)
        h.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeMode.Stretch)
        v.addWidget(self.preview, 1)

        # ok/cancel
        bb = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.StandardButton.Ok |
            QtWidgets.QDialogButtonBox.StandardButton.Cancel
        )
        v.addWidget(bb)
        bb.accepted.connect(self.apply)
        bb.rejected.connect(self.reject)

        for s,e in self.cfg.active_windows:
            self.list.addItem(f"{hm(s)}~{hm(e%86400)}")

        # signals
        self.addBtn.clicked.connect(self.add_range)
        self.editBtn.clicked.connect(self.on_edit)
        self.delBtn.clicked.connect(self.on_delete)
        self.clearBtn.clicked.connect(self.on_clear)

        self.refresh_preview()

    def on_clear(self):
        self.list.clear()
        self.refresh_preview()

    def add_range(self):
        s=self.start.time(); e=self.end.time()
        ssec=s.hour()*3600+s.minute()*60; esec=e.hour()*3600+e.minute()*60
        if esec==ssec:
            QtWidgets.QMessageBox.warning(self,"오류","시작과 종료가 같습니다."); return
        if esec<ssec: esec+=24*3600
        self.list.addItem(f"{hm(ssec%86400)}~{hm(esec%86400)}"); self.refresh_preview()

    def on_edit(self):
        items=self.list.selectedItems()
        if not items: return
        w=items[0].text()
        a,b=w.split("~")
        t=lambda s: [int(x) for x in s.split(":")]
        s=QtCore.QTime(*t(a)); e=QtCore.QTime(*t(b))
        self.start.setTime(s); self.end.setTime(e)

    def on_delete(self):
        r=self.list.currentRow()
        if r>=0: self.list.takeItem(r); self.refresh_preview()

    def refresh_preview(self):
        SLOT_SEC = 15*60
        def to_sec(s):
            h,m=map(int,s.split(":"))
            return h*3600+m*60
        ranges=[]
        for i in range(self.list.count()):
            a,b=self.list.item(i).text().split("~")
            sa=to_sec(a); sb=to_sec(b)
            if sb<=sa: sb+=24*3600
            ranges.append((sa,sb))
        slots=[]; i=1
        for s,e in ranges:
            t=s
            while t<e:
                slots.append((i, hm(t%86400), hm((t+SLOT_SEC)%86400)))
                t+=SLOT_SEC; i+=1
        self.preview.setRowCount(len(slots))
        for r,(no,a,b) in enumerate(slots):
            self.preview.setItem(r,0,QtWidgets.QTableWidgetItem(str(no)))
            self.preview.setItem(r,1,QtWidgets.QTableWidgetItem(a))
            self.preview.setItem(r,2,QtWidgets.QTableWidgetItem(b))
        self.ranges = ranges

    def apply(self):
        self.cfg.active_windows = getattr(self, "ranges", []) or self.cfg.active_windows
        self.accept()
class HelpDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent); self.setWindowTitle("도움말"); self.resize(520, 620)
        v=QtWidgets.QVBoxLayout(self)
        text=QtWidgets.QPlainTextEdit(); text.setReadOnly(True)
        text.setPlainText(
            "플레이어\n"
            " Space: 일시정지/재생\n"
            " Ctrl+Space: 정지\n"
            " ←/→: 5초 이동\n"
            " ↑/↓: 볼륨 up/down\n"
            " PageUp/PageDown: 이전/다음 영상\n"
            "\n입력창\n"
            " Tab/Shift+Tab: 방향탭 내 이동\n"
            " Ctrl+Tab/Ctrl+Shift+Tab: 방향그룹 이동\n"
            "\n기타\n"
            " F1: 도움말\n"
            " F2: 폴더 열기\n"
            " F11: 시트 보기\n"
        )
        v.addWidget(text)
        bb=QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.StandardButton.Close); v.addWidget(bb)
        bb.rejected.connect(self.reject); bb.accepted.connect(self.accept)


class SheetDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, counts=None, cfg=None):
        super().__init__(parent); self.setWindowTitle("시트 보기"); self.resize(1200, 760)
        self.counts = counts
        self.cfg = cfg

        v=QtWidgets.QVBoxLayout(self)

        # 상단 조사 요약 정보 영역
        info_group = QtWidgets.QGroupBox("입력 조사 요약정보")
        info_layout = QtWidgets.QGridLayout(info_group)
        self.edSurveyName = QtWidgets.QLineEdit(); self.edSurveyName.setReadOnly(True)
        self.edPointName = QtWidgets.QLineEdit(); self.edPointName.setReadOnly(True)
        self.edSurveyDate = QtWidgets.QLineEdit(); self.edSurveyDate.setReadOnly(True)
        self.edDocInfo = QtWidgets.QLineEdit(); self.edDocInfo.setReadOnly(True)
        self.edWorker = QtWidgets.QLineEdit(); self.edWorker.setReadOnly(True)
        info_layout.addWidget(QtWidgets.QLabel("조사명"), 0, 0)
        info_layout.addWidget(self.edSurveyName, 0, 1)
        info_layout.addWidget(QtWidgets.QLabel("조사지점"), 0, 2)
        info_layout.addWidget(self.edPointName, 0, 3)
        info_layout.addWidget(QtWidgets.QLabel("조사일자"), 1, 0)
        info_layout.addWidget(self.edSurveyDate, 1, 1)
        info_layout.addWidget(QtWidgets.QLabel("문서정보"), 1, 2)
        info_layout.addWidget(self.edDocInfo, 1, 3)
        info_layout.addWidget(QtWidgets.QLabel("작업자"), 2, 0)
        info_layout.addWidget(self.edWorker, 2, 1, 1, 3)
        v.addWidget(info_group)

        # 중앙: 방향별 시트 탭
        tabs=QtWidgets.QTabWidget()
        v.addWidget(tabs, 1)
        self.tables = {}
        enabled = [i+1 for i, ok in enumerate(cfg.enabled_directions) if ok and i < len(cfg.directions)]
        if not enabled:
            enabled = [1]
        for dirno in enabled:
            tab=QtWidgets.QWidget(); lay=QtWidgets.QVBoxLayout(tab)
            table=QtWidgets.QTableWidget(); lay.addWidget(table)
            df=counts.to_sheet_df_per_direction(cfg, dirno)
            table.setColumnCount(len(df.columns)); table.setRowCount(len(df))
            table.setHorizontalHeaderLabels(list(df.columns))
            for r in range(len(df)):
                for c,col in enumerate(df.columns):
                    table.setItem(r,c,QtWidgets.QTableWidgetItem(str(df.iloc[r,c])))
            table.horizontalHeader().setStretchLastSection(True)
            table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
            # Right-align numeric cells
            for r in range(len(df)):
                for c, col in enumerate(df.columns):
                    item = table.item(r, c)
                    if item is None:
                        continue
                    txt = item.text().strip()
                    try:
                        float(txt.replace(',', ''))
                        item.setTextAlignment(QtCore.Qt.AlignmentFlag.AlignRight | QtCore.Qt.AlignmentFlag.AlignVCenter)
                    except Exception:
                        pass
            self.tables[dirno] = table
            tabs.addTab(tab, f"{dirno}번")

        # 하단: 엑셀저장(통합출력), 등록, 닫기
        btn_row = QtWidgets.QHBoxLayout()
        self.btnExcelAll = QtWidgets.QPushButton("엑셀저장(통합출력)")
        btn_row.addWidget(self.btnExcelAll)
        btn_row.addStretch(1)
        self.btnRegister = QtWidgets.QPushButton("등록")
        self.btnClose = QtWidgets.QPushButton("닫기")
        btn_row.addWidget(self.btnRegister)
        btn_row.addWidget(self.btnClose)
        v.addLayout(btn_row)

        # 시그널 연결
        try:
            self.btnExcelAll.clicked.connect(self.on_click_excel_all)
            self.btnClose.clicked.connect(self.reject)
        except Exception:
            pass


    def showEvent(self, event: QtGui.QShowEvent) -> None:
        try:
            base_w = self.parent().width() if self.parent() and hasattr(self.parent(), 'width') else None
        except Exception:
            base_w = None
        if not base_w:
            screen = QtGui.QGuiApplication.primaryScreen()
            avail = screen.availableGeometry() if screen else QtCore.QRect(0,0,1600,900)
            base_w = avail.width()
        target_w = max(800, int(base_w * 0.5))
        # apply half-width while preserving current height
        self.resize(target_w, self.height())
        super().showEvent(event)



# ---- Click-to-seek Slider ----

    def on_click_excel_all(self):
        """시트보기 창 하단의 엑셀저장(통합출력) 버튼: 메인 창의 save_xlsx 재사용."""
        try:
            parent = self.parent()
            if parent is not None and hasattr(parent, "save_xlsx"):
                parent.save_xlsx()
            else:
                QtWidgets.QMessageBox.warning(self, "오류", "엑셀 저장 기능을 사용할 수 없습니다.")
        except Exception:
            QtWidgets.QMessageBox.warning(self, "오류", "엑셀 저장 중 문제가 발생했습니다.")

    def refresh(self):
        # 재계산하여 각 방향 탭의 표를 갱신
        try:
            for dirno, table in self.tables.items():
                df = self.counts.to_sheet_df_per_direction(self.cfg, dirno)
                table.setColumnCount(len(df.columns)); table.setRowCount(len(df))
                table.setHorizontalHeaderLabels(list(df.columns))
                for r in range(len(df)):
                    for c, col in enumerate(df.columns):
                        table.setItem(r, c, QtWidgets.QTableWidgetItem(str(df.iloc[r, c])))
                table.horizontalHeader().setStretchLastSection(True)
                table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.ResizeMode.Stretch)
                # Right-align numeric cells
                for r in range(len(df)):
                    for c, col in enumerate(df.columns):
                        item = table.item(r, c)
                        if item is None:
                            continue
                        txt = item.text().strip()
                        try:
                            float(txt.replace(',', ''))
                            item.setTextAlignment(QtCore.Qt.AlignmentFlag.AlignRight | QtCore.Qt.AlignmentFlag.AlignVCenter)
                        except Exception:
                            pass
        except Exception as e:
            pass

class SeekSlider(QtWidgets.QSlider):
    """수평 슬라이더에서 클릭한 위치로 즉시 이동하는 슬라이더"""
    clickedTo = QtCore.pyqtSignal(int)

    def mousePressEvent(self, event: QtGui.QMouseEvent):
        try:
            if self.orientation() == QtCore.Qt.Orientation.Horizontal and self.width() > 0:
                x = event.position().x() if hasattr(event, "position") else event.x()
                ratio = max(0.0, min(1.0, x / self.width()))
                val = int(round(self.minimum() + ratio * (self.maximum() - self.minimum())))
                self.setValue(val)
                self.clickedTo.emit(val)
        except Exception:
            pass
        super().mousePressEvent(event)

    # --- v11: marker support (start & pause points as ▼) ---
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._marker_start = None
        self._marker_pause = None

    def setMarkers(self, start_pos: float|None, pause_pos: float|None):
        """start_pos, pause_pos: 0.0~1.0 (None이면 비표시)"""
        self._marker_start = start_pos
        self._marker_pause = pause_pos
        self.update()

    def paintEvent(self, e: QtGui.QPaintEvent):
        super().paintEvent(e)
        try:
            p = QtGui.QPainter(self)
            p.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing, True)
            rect = self.rect(); y = rect.center().y()
            def draw_triangle(x, y_mid, fill: QtGui.QColor, outline: QtGui.QColor):
                size = 12
                path = QtGui.QPainterPath()
                path.moveTo(x, y_mid - size//2)
                path.lineTo(x - size//2, y_mid + size//2)
                path.lineTo(x + size//2, y_mid + size//2)
                path.closeSubpath()
                # shadow
                p.setPen(QtGui.QPen(QtGui.QColor(0,0,0,120), 2))
                p.setBrush(QtGui.QColor(0,0,0,80))
                p.translate(0,1); p.drawPath(path); p.translate(0,-1)
                # body
                p.setPen(QtGui.QPen(outline, 2))
                p.setBrush(fill)
                p.drawPath(path)
            
            def draw_triangle_up(x, y_mid, fill: QtGui.QColor, outline: QtGui.QColor):
                size = 12
                path = QtGui.QPainterPath()
                path.moveTo(x, y_mid - size//2)          # ▲
                path.lineTo(x - size//2, y_mid + size//2)
                path.lineTo(x + size//2, y_mid + size//2)
                path.closeSubpath()
                p.setPen(QtGui.QPen(QtGui.QColor(0,0,0,120), 2)); p.setBrush(QtGui.QColor(0,0,0,80))
                p.translate(0,1); p.drawPath(path); p.translate(0,-1)
                p.setPen(QtGui.QPen(outline, 2)); p.setBrush(fill); p.drawPath(path)

            def draw_triangle_down(x, y_mid, fill: QtGui.QColor, outline: QtGui.QColor):
                size = 12
                path = QtGui.QPainterPath()
                path.moveTo(x, y_mid + size//2)          # ▼
                path.lineTo(x - size//2, y_mid - size//2)
                path.lineTo(x + size//2, y_mid - size//2)
                path.closeSubpath()
                p.setPen(QtGui.QPen(QtGui.QColor(0,0,0,120), 2)); p.setBrush(QtGui.QColor(0,0,0,80))
                p.translate(0,1); p.drawPath(path); p.translate(0,-1)
                p.setPen(QtGui.QPen(outline, 2)); p.setBrush(fill); p.drawPath(path)

            start_frac = getattr(self, "_marker_start", None)
            pause_frac = getattr(self, "_marker_pause", None)
            if start_frac is not None and 0.0 <= start_frac <= 1.0:
                x = rect.left() + int(start_frac * rect.width())
                draw_triangle_up(x, y, QtGui.QColor(230,60,60,230), QtGui.QColor(70,0,0,230))  # RED ▲
            if pause_frac is not None and 0.0 <= pause_frac <= 1.0:
                x = rect.left() + int(pause_frac * rect.width())
                draw_triangle_down(x, y, QtGui.QColor(60,90,230,230), QtGui.QColor(0,0,90,230))  # BLUE ▼
            p.end()
        except Exception: pass

# ==== Main Window ====
class MainWindow(QtWidgets.QMainWindow):
    # --- ENV 연동: 환경설정 창 열기(필수) ---
    def _open_env_settings_window_fallback(self):
        """환경설정 UI를 별도 창으로 실행합니다(단일파일(all-in-one) 포함).
        - 동일 폴더에 env_*.py가 있으면 그 파일을 우선 실행
        - 없으면 내장된 ENV 코드를 _env_hotkey_embedded.py로 생성 후 실행
        """
        import os, subprocess, sys
        base_dir = os.path.dirname(os.path.abspath(__file__))

        # 1) 같은 폴더의 env 파일 우선
        candidates = []
        try:
            for fn in os.listdir(base_dir):
                if fn.lower().startswith("env_") and fn.lower().endswith(".py"):
                    candidates.append(os.path.join(base_dir, fn))
        except Exception:
            candidates = []

        if candidates:
            env_path = sorted(candidates)[-1]
            try:
                subprocess.Popen([sys.executable, env_path], cwd=base_dir)
                return
            except Exception as e:
                self._msg_info("환경설정 실행 실패", str(e))
                return

        # 2) 내장 ENV 코드를 파일로 생성 후 실행
        try:
            embedded_path = os.path.join(base_dir, "_env_hotkey_embedded.py")
            if not os.path.exists(embedded_path) or os.path.getsize(embedded_path) < 1024:
                src = getattr(self, "_EMBEDDED_ENV_SOURCE", "")
                if not src:
                    raise RuntimeError("내장 ENV 소스(_EMBEDDED_ENV_SOURCE)가 없습니다.")
                with open(embedded_path, "w", encoding="utf-8") as f:
                    f.write(src)
            subprocess.Popen([sys.executable, embedded_path], cwd=base_dir)
        except Exception as e:
            self._msg_info("환경설정 실행 실패", str(e))

    def open_env_settings_window(self):
        """외부에서 연결되는 공개 메서드(버튼 연결용)."""
        return self._open_env_settings_window_fallback()
    # --- ENV 연동: 상단 과업/지점 콤보 변경 처리(필수) ---
    def _on_env_project_changed(self, _idx: int = 0):
        """과업 콤보 변경 시: env_data_plus_allinone.json 기반으로 지점 콤보를 채웁니다."""
        try:
            sidx = self.projectCombo.currentData()
            if sidx is None:
                sidx = 0
            try:
                sidx = int(sidx)
            except Exception:
                sidx = 0

            surveys = getattr(self, "_env_surveys_cache", None)
            if not isinstance(surveys, list):
                surveys = (getattr(self, "hkdb", None) or {}).get("surveys", []) or []
            if not (0 <= sidx < len(surveys)):
                sidx = 0

            survey = surveys[sidx] if surveys else {}
            sites = (survey.get("sites") or (survey.get("site_data") or {}).get("sites") or []) if isinstance(survey, dict) else []
            if isinstance(sites, dict):
                sites = list(sites.values())

            # fill site combo
            self.siteCombo.blockSignals(True)
            self.siteCombo.clear()
            self._env_sites_cache = sites

            for tidx, st in enumerate(sites):
                if not isinstance(st, dict):
                    st = {}
                label = self._format_site_label(st)
                self.siteCombo.addItem(label, tidx)

            self.siteCombo.blockSignals(False)

            # auto select first
            if self.siteCombo.count() > 0:
                self.siteCombo.setCurrentIndex(0)
                try:
                    self._on_env_site_changed(0)
                except Exception:
                    pass
        except Exception:
            try:
                self.siteCombo.blockSignals(False)
            except Exception:
                pass

    def _on_env_site_changed(self, _idx: int = 0):
        """지점 콤보 변경 시: 상단 텍스트(과업/지점)를 갱신합니다."""
        try:
            surveys = getattr(self, "_env_surveys_cache", None)
            if not isinstance(surveys, list):
                surveys = (getattr(self, "hkdb", None) or {}).get("surveys", []) or []
            sidx = self.projectCombo.currentData()
            try:
                sidx = int(sidx) if sidx is not None else 0
            except Exception:
                sidx = 0
            survey = surveys[sidx] if surveys and 0 <= sidx < len(surveys) else {}
            proj_name = ""
            if isinstance(survey, dict):
                proj_name = (survey.get("info") or {}).get("name") or survey.get("project") or survey.get("name") or ""
            tidx = self.siteCombo.currentData()
            try:
                tidx = int(tidx) if tidx is not None else 0
            except Exception:
                tidx = 0
            sites = getattr(self, "_env_sites_cache", None)
            if not isinstance(sites, list):
                sites = (survey.get("sites") or []) if isinstance(survey, dict) else []
            site = sites[tidx] if sites and 0 <= tidx < len(sites) else {}
            label = self._format_site_label(site if isinstance(site, dict) else {})
            # update top line edits if exist
            if hasattr(self, "projectEdit"):
                self.projectEdit.setText(str(proj_name))
            if hasattr(self, "siteEdit"):
                # 지번_지점명
                self.siteEdit.setText(str(label))
        except Exception:
            pass

    def open_env_hotkeys_db(self):
        # 최신 ENV/HK 경로를 먼저 탐지/로드하여 툴팁과 연동이 즉시 정확해지도록 합니다.
        try:
            load_env_db()
        except Exception:
            pass
        try:
            load_hotkeys_db()
        except Exception:
            pass
        """상단 과업/지점 콤보를 환경설정 DB 기준으로 갱신합니다.
        - 과업/지점 목록: env_data_plus_allinone.json (정본)
        - 단축키/추가 설정: hotkeys_db.json (있으면 보조)
        또한, 요청하신 구조로 Survey\\Sites 아래에 과업/지점별 JSON을 생성(또는 갱신)합니다.
        """
        try:
            root = detect_data_root_env_compatible()
        except Exception:
            root = ""

        # 1) env 정본 로드
        self.envdb = load_env_db() or {}
        # 2) hotkeys(보조) 로드
        self.hkdb = load_hotkeys_db() or {}
        # 로드된 실제 경로(디버그용)
        try:
            self._env_db_path = globals().get('_LAST_ENV_DB_PATH','')
            self._hk_db_path  = globals().get('_LAST_HK_DB_PATH','')
        except Exception:
            self._env_db_path = ''
            self._hk_db_path  = ''
        try:
            env_p = (best_env_db_path() or '')
            hk_p  = (best_hotkeys_db_path() or '')
            self._env_db_path = env_p
            self._hk_db_path  = hk_p
            env_tag = env_p + ("" if (env_p and os.path.exists(env_p)) else " (not found)")
            hk_tag  = hk_p  + ("" if (hk_p and os.path.exists(hk_p)) else " (not found)")
            tip = f"ENV: {env_tag}\nHK: {hk_tag}"
            if hasattr(self,'btnRefreshTop') and self.btnRefreshTop:
                self.btnRefreshTop.setToolTip(tip)
        except Exception:
            pass

        surveys = (self.envdb.get("surveys") or [])
        if not surveys:
            # env가 없으면 최소한 hkdb라도
            surveys = (self.hkdb.get("surveys") or [])

        if not surveys:
            QtWidgets.QMessageBox.information(
                self,
                "환경설정 불러오기",
                "환경설정 데이터를 찾지 못했습니다.\n\n"
                "1) 환경설정 프로그램에서 저장을 눌러 env_data_plus_allinone.json이 생성되는지 확인\n"
                "2) COUNTERMAX_DATA_ROOT 환경변수 또는 K:\\Survey / Z:\\Survey / Y:\\Survey 경로 확인"
            )
            return

        # 콤보 갱신 (env 우선)
        self._populate_env_project_site_combos()

        # 3) Survey\\Sites 아래 과업/지점별 JSON 생성(요청사항)
        try:
            if root and os.path.isdir(root):
                base_sites = os.path.join(root, "Sites")
                os.makedirs(base_sites, exist_ok=True)

                for s in (self.envdb.get("surveys") or []):
                    if not isinstance(s, dict):
                        continue
                    info = s.get("info") if isinstance(s.get("info"), dict) else {}
                    sn = str(info.get("sn") or info.get("name") or "SURVEY").strip()
                    sn_safe = _re.sub(r'[^0-9A-Za-z가-힣_\-]+', "_", sn)
                    survey_dir = os.path.join(base_sites, sn_safe)
                    os.makedirs(survey_dir, exist_ok=True)

                    for site in (s.get("sites") or []):
                        if not isinstance(site, dict):
                            continue
                        workno = str(site.get("작업번호") or site.get("work_no") or site.get("id") or "").strip()
                        if not workno:
                            # 지번+지점명으로라도 파일명 생성
                            jibun = str(site.get("지번") or site.get("jibun") or "").strip()
                            sname = str(site.get("지점명") or site.get("name") or "").strip()
                            workno = f"{jibun}_{sname}".strip("_") or "site"

                        workno_safe = _re.sub(r'[^0-9A-Za-z가-힣_\-]+', "_", workno)

                        # (A) 지점 기본/방향/카운터 설정 저장
                        site_payload = {
                            "survey_info": info,
                            "site": site,
                        }
                        site_path = os.path.join(survey_dir, f"site_{workno_safe}.json")
                        # (B) 단축키/차종 설정을 site_*.json 안에 포함(지점별 단축키를 계수프로그램에서 최우선 반영하기 위함)
                        # 우선순위:
                        #  1) envdb(site dict)에 이미 포함된 값(groups/dir_hotkeys/group_dir_hotkeys/vehicle_types/hotkeys)
                        #  2) hotkeys_db.json(hkdb)에서 해당 지점 override를 찾아 병합
                        try:
                            hkdb = getattr(self, "hkdb", None) or {}
                            envdb = getattr(self, "envdb", None) or {}
                            # survey/sn 단서(있으면 더 정확히 찾기)
                            sn_hint = None
                            try:
                                sn_hint = (info.get("sn") if isinstance(info, dict) else None) or (s.get("sn") if isinstance(s, dict) else None)
                            except Exception:
                                sn_hint = None

                            def _iter_dicts(o):
                                if isinstance(o, dict):
                                    yield o
                                    for v in o.values():
                                        yield from _iter_dicts(v)
                                elif isinstance(o, list):
                                    for v in o:
                                        yield from _iter_dicts(v)

                            def _find_site_override(hkdb_obj: dict, site_obj: dict):
                                # work_no 우선, 없으면 지번+지점명
                                target_wno = str(site_obj.get("작업번호") or site_obj.get("work_no") or site_obj.get("id") or "").strip()
                                target_jibun = str(site_obj.get("지번") or site_obj.get("jibun") or "").strip()
                                target_nm = str(site_obj.get("지점명") or site_obj.get("name") or "").strip()

                                for d in _iter_dicts(hkdb_obj):
                                    if not isinstance(d, dict):
                                        continue
                                    has_any = any(k in d for k in ("dir_hotkeys","group_dir_hotkeys","vehicle_types","hotkeys","counters","groups","입력그룹","차종"))
                                    if not has_any:
                                        continue

                                    # sn 힌트가 있으면 sn도 맞춰보기(있을 때만)
                                    if sn_hint:
                                        sn_val = d.get("sn") or d.get("SN") or d.get("survey_no") or d.get("survey") or d.get("과업번호")
                                        if sn_val and str(sn_val) != str(sn_hint):
                                            continue

                                    wno = str(d.get("작업번호") or d.get("work_no") or d.get("id") or "").strip()
                                    if target_wno and wno and wno == target_wno:
                                        return d

                                    jb = str(d.get("지번") or d.get("jibun") or "").strip()
                                    nm = str(d.get("지점명") or d.get("name") or "").strip()
                                    if target_jibun and target_nm and jb and nm and (jb == target_jibun) and (nm == target_nm):
                                        return d
                                return None

                            def _pull_fields(d: dict) -> dict:
                                out = {}
                                if not isinstance(d, dict):
                                    return out

                                # 1) 직접키
                                for k in ("groups","dir_hotkeys","group_dir_hotkeys","vehicle_types"):
                                    if k in d and isinstance(d.get(k), (list, dict)):
                                        out[k] = d.get(k)

                                # 2) hotkeys 내부(버전별 상이)에서 추출
                                hk = d.get("hotkeys")
                                if isinstance(hk, dict):
                                    out["hotkeys"] = hk
                                    if isinstance(hk.get("dir_hotkeys"), dict):
                                        out["dir_hotkeys"] = hk.get("dir_hotkeys")
                                    if isinstance(hk.get("group_dir_hotkeys"), dict):
                                        out["group_dir_hotkeys"] = hk.get("group_dir_hotkeys")
                                    if isinstance(hk.get("vehicle_types"), list):
                                        out["vehicle_types"] = hk.get("vehicle_types")

                                return out

                            ov = _find_site_override(hkdb, site) or _find_site_override(envdb, site)
                            fields = _pull_fields(ov) if isinstance(ov, dict) else {}

                            # site dict에 병합(기존 값이 있으면 유지)
                            for k, v in fields.items():
                                if not isinstance(v, (list, dict)):
                                    continue
                                # hotkeys 관련 키는 override가 있으면 덮어쓰기(환경설정이 정답)
                                if k in ("dir_hotkeys","group_dir_hotkeys","vehicle_types","hotkeys"):
                                    site[k] = v
                                else:
                                    # 기타는 없을 때만 채우기
                                    if k not in site:
                                        site[k] = v
                        except Exception:
                            pass
                        # (A+B) 최종 site_*.json 저장 (단축키/차종 병합 후)
                        try:
                            site_payload = {"survey_info": info, "site": site}
                            # (v51) 현재 cfg 기준 단축키를 site_*.json 및 env_data_plus_allinone.json에 함께 기록
                            try:
                                hk_payload = build_site_hotkeys_from_cfg(getattr(self, "cfg", None), site)
                                if isinstance(site, dict):
                                    site["site_hotkeys"] = hk_payload.get("by_dir") or {}
                                    site["site_hotkeys_vehicle_names"] = hk_payload.get("vehicle_names") or []
                                # envdb에도 같은 내용을 기록(있으면)
                                try:
                                    _update_envdb_site_hotkeys_on_disk(info, site, hk_payload)
                                except Exception:
                                    pass
                            except Exception:
                                pass
                            with open(site_path, "w", encoding="utf-8") as f:
                                _json.dump(site_payload, f, ensure_ascii=False, indent=2)
                        except Exception:
                            pass
        except Exception:
            # 생성 실패해도 콤보/계수는 계속 가능
            pass

        # (PATCH) 환경설정/사이트 JSON 생성 후: 현재 cfg 기준으로 단축키 재설치 + 하단 UI 즉시 갱신
        try:
            self.install_hotkeys(reinstall=True)
        except Exception:
            pass

    def _format_site_label(self, site: dict) -> str:
        """지점 표기: 지번_지점명 (한국어 키/영문 키 모두 대응)"""
        try:
            if not isinstance(site, dict):
                site = {}
            # Korean-first
            jibun = (site.get("지번") or site.get("jibun") or site.get("jibeon") or site.get("address") or site.get("addr") or "")
            name = (site.get("지점명") or site.get("name") or site.get("site_name") or site.get("title") or "")
            jibun = str(jibun).strip()
            name = str(name).strip()
            if jibun and name:
                return f"{jibun}_{name}"
            return (jibun or name or "지점").strip()
        except Exception:
            return "지점"

    def _populate_env_project_site_combos(self):
        """env_data_plus_allinone.json(우선)로 과업/지점 콤보를 채우고, hotkeys_db.json은 단축키용으로만 사용합니다."""
        envdb = getattr(self, "envdb", None) or {}
        hkdb  = getattr(self, "hkdb", None) or {}

        surveys = envdb.get("surveys", []) or []

        # dict 형태 방어
        if isinstance(surveys, dict):
            surveys = [{"project": k, **(v if isinstance(v, dict) else {})} for k, v in surveys.items()]
        self._env_surveys_cache = surveys

        self.projectCombo.blockSignals(True)
        self.siteCombo.blockSignals(True)
        self.projectCombo.clear()
        self.siteCombo.clear()

        for sidx, s in enumerate(surveys):
            if not isinstance(s, dict):
                continue
            info = s.get("info") if isinstance(s.get("info"), dict) else {}
            proj = info.get("name") or s.get("project") or s.get("name") or s.get("title") or ""
            proj = str(proj).strip()
            if proj:
                self.projectCombo.addItem(proj, int(sidx))

        self.projectCombo.blockSignals(False)
        self.siteCombo.blockSignals(False)

        if self.projectCombo.count() > 0:
            # 첫 항목 선택 → 지점 콤보 자동 채움
            self.projectCombo.setCurrentIndex(0)
            try:
                self._on_env_project_changed(0)
            except Exception:
                pass
    def _on_env_project_changed(self, _idx: int = 0):
        """과업 콤보 변경 시: env_data_plus_allinone.json 기반으로 지점 콤보를 채웁니다."""
        try:
            sidx = self.projectCombo.currentData()
            if sidx is None:
                sidx = 0
            try:
                sidx = int(sidx)
            except Exception:
                sidx = 0

            surveys = getattr(self, "_env_surveys_cache", None)
            if not isinstance(surveys, list):
                surveys = (getattr(self, "hkdb", None) or {}).get("surveys", []) or []
            if not (0 <= sidx < len(surveys)):
                sidx = 0

            survey = surveys[sidx] if surveys else {}
            sites = (survey.get("sites") or (survey.get("site_data") or {}).get("sites") or []) if isinstance(survey, dict) else []
            if isinstance(sites, dict):
                sites = list(sites.values())

            # fill site combo
            self.siteCombo.blockSignals(True)
            self.siteCombo.clear()
            self._env_sites_cache = sites

            for tidx, st in enumerate(sites):
                if not isinstance(st, dict):
                    st = {}
                label = self._format_site_label(st)
                self.siteCombo.addItem(label, tidx)

            self.siteCombo.blockSignals(False)

            # auto select first
            if self.siteCombo.count() > 0:
                self.siteCombo.setCurrentIndex(0)
                try:
                    self._on_env_site_changed(0)
                except Exception:
                    pass
        except Exception:
            try:
                self.siteCombo.blockSignals(False)
            except Exception:
                pass

    def _on_env_site_changed(self, _idx: int = 0):
        """지점 콤보 변경 시: 상단 텍스트(과업/지점)를 갱신합니다."""
        try:
            surveys = getattr(self, "_env_surveys_cache", None)
            if not isinstance(surveys, list):
                surveys = (getattr(self, "hkdb", None) or {}).get("surveys", []) or []
            sidx = self.projectCombo.currentData()
            try:
                sidx = int(sidx) if sidx is not None else 0
            except Exception:
                sidx = 0
            survey = surveys[sidx] if surveys and 0 <= sidx < len(surveys) else {}
            proj_name = ""
            if isinstance(survey, dict):
                proj_name = (survey.get("info") or {}).get("name") or survey.get("project") or survey.get("name") or ""
            tidx = self.siteCombo.currentData()
            try:
                tidx = int(tidx) if tidx is not None else 0
            except Exception:
                tidx = 0
            sites = getattr(self, "_env_sites_cache", None)
            if not isinstance(sites, list):
                sites = (survey.get("sites") or []) if isinstance(survey, dict) else []
            site = sites[tidx] if sites and 0 <= tidx < len(sites) else {}
            label = self._format_site_label(site if isinstance(site, dict) else {})
            # update top line edits if exist
            if hasattr(self, "projectEdit"):
                self.projectEdit.setText(str(proj_name))
            if hasattr(self, "siteEdit"):
                # 지번_지점명
                self.siteEdit.setText(str(label))
        except Exception:
            pass

    def _update_time_label(self, ms: int):
        """
        VLC timeChanged 콜백에서 호출되는 공용 헬퍼
        - 현재/남은 시간 라벨 동기화
        - 재생 슬라이더 위치 동기화 (배속/점프에도 부드럽게 따라감)
        """
        try:
            cur_ms = max(0, int(ms))
        except Exception:
            cur_ms = 0
        try:
            total_ms = max(0, int(self.video.length_ms()))
        except Exception:
            total_ms = 0

        remain_ms = max(0, total_ms - cur_ms)
        remain_sec = remain_ms // 1000  # 화면에 보이는 남은 시간(초) 기준

        # === 자동 다음파일 넘어가기 (표시 남은시간이 0초이고, 실제로도 0.8초 이내일 때만) ===
        try:
            if remain_sec == 0 and remain_ms <= 800 and hasattr(self, "next_video"):
                self.next_video()
                return
        except Exception:
            pass

        # 시간 라벨
        try:
            self.update_time_labels(cur_ms, remain_ms)
        except Exception:
            pass

        # 슬라이더 (0~1000 구간)
        try:
            if hasattr(self, "slider") and total_ms > 0:
                frac = max(0.0, min(1.0, cur_ms / float(total_ms)))
                val = int(round(frac * (self.slider.maximum() - self.slider.minimum()))) + self.slider.minimum()
                # 드래그 중에는 강제 이동하지 않도록 (필요 시 SeekSlider에 _dragging 플래그 사용)
                if not getattr(self.slider, "_dragging", False):
                    self.slider.blockSignals(True)
                    self.slider.setValue(val)
                    self.slider.blockSignals(False)
        except Exception:
            pass


    def _apply_toggle_style(self, btn, checked: bool):
        try:
            if checked:
                btn.setStyleSheet("QToolButton{background:#e7f7ea; border:1px solid #3aa357; border-radius:6px;}")
            else:
                btn.setStyleSheet("QToolButton{background:none;}")
        except Exception:
            pass


    # ===== v11: AutoPause / Breakpoint helpers (Option A) =====
    auto_pause_enabled: bool = False
    auto_pause_interval_ms: int = 0
    break_start_ms: int|None = None
    break_origin_index: int|None = None
    _carry_remain_ms: int = 0
    _carry_sched_file: int|None = None
    _origin_closed: bool = False
    _awaiting_resume: bool = False
    _carry_next_pending: bool = False

    def _now_ms(self) -> int:
        try: return max(0, int(self.video.get_time_ms()))
        except Exception: return 0

    def _len_ms(self) -> int:
        """현재 파일 총 길이(ms)
        - mpv에서 바로 얻지 못하면 video_lengths 테이블을 활용해 보정"""
        try:
            L = int(self.video.length_ms())
            if L and L > 0:
                return max(0, L)
        except Exception:
            pass
        # mpv 길이가 0으로 나오는 경우: 미리 계산된 video_lengths 사용
        try:
            idx = self.current_file_index()
            if hasattr(self, "video_lengths") and 0 <= idx < len(self.video_lengths):
                sec = float(self.video_lengths[idx] or 0.0)
                if sec > 0:
                    return int(sec * 1000)
        except Exception:
            pass
        return 0

    def _remaining_in_current_file_ms(self) -> int:
        """현재 파일에서 '현재 위치 이후' 남은 재생 길이(ms)"""
        try:
            L = max(0, int(self._len_ms() or 0))
            t = max(0, int(self._now_ms() or 0))
            return max(0, L - t)
        except Exception:
            return 0

    def _auto_pause_should_stop_here(self, cur_ms: int) -> bool:
        """
        브레이크 이후 N분 자동멈춤 지점 도달 여부를 판단하고,
        목표점 근처에서는 자동으로 속도를 줄이고 0.1초 이내로 정밀 정지하도록 보정한다.
        """
        try:
            # 기본 가드: 자동멈춤이 꺼져 있거나 설정이 없으면 항상 False
            if not getattr(self, "auto_pause_enabled", False):
                return False
            interval_ms = int(getattr(self, "auto_pause_interval_ms", 0) or 0)
            if interval_ms <= 0:
                return False
            if self.break_origin_index is None or self.break_start_ms is None:
                return False
            if not hasattr(self, "video_lengths") or not self.video_lengths:
                return False

            cur_idx = self.current_file_index()
            if cur_idx < 0:
                return False

            origin = int(self.break_origin_index)
            if origin < 0 or origin >= len(self.video_lengths):
                return False

            # --- 1) 이 자동멈춤 지점이 속한 파일과, 그 파일 내 로컬 ms 위치 계산 ---
            target = interval_ms  # 브레이크 이후 N분(ms)
            origin_len_ms = int(self.video_lengths[origin] * 1000)
            origin_break_ms = int(self.break_start_ms)

            # origin 파일 안에서 남은 길이
            remain_origin_ms = max(0, origin_len_ms - origin_break_ms)

            local_target_ms = None  # 현재 파일 기준 타겟 위치(ms)

            if target <= remain_origin_ms:
                # 같은 파일 안에 자동 멈춤 지점이 존재
                if cur_idx == origin:
                    local_target_ms = origin_break_ms + target
            else:
                # 다음 파일들로 carry
                rem = target - remain_origin_ms
                idx = origin + 1
                while rem > 0 and idx < len(self.video_lengths):
                    seg_ms = int(self.video_lengths[idx] * 1000)
                    if rem <= seg_ms:
                        if cur_idx == idx:
                            local_target_ms = rem
                        break
                    rem -= seg_ms
                    idx += 1

            if local_target_ms is None:
                # 현재 파일에는 아직 자동멈춤 지점이 없음
                return False

            # --- 2) 목표점 근접 시 자동 속도 감소(brake) ---
            try:
                cur_ms_safe = max(0, int(cur_ms))
            except Exception:
                cur_ms_safe = 0

            gap = int(local_target_ms) - cur_ms_safe

            # 배속 브레이크 상태 관리용 내부 속성
            base_rate = getattr(self, "_auto_pause_base_rate", None)
            slowing = getattr(self, "_auto_pause_slowing", False)

            try:
                current_rate = float(self.video.get_rate())
            except Exception:
                current_rate = 1.0

            # base_rate 초기 저장
            if not slowing or base_rate is None:
                base_rate = current_rate or 1.0
                self._auto_pause_base_rate = base_rate

            # gap이 너무 멀리 있거나 이미 지나간 경우는 브레이크 해제
            if gap <= 0 or gap > 6000:
                if slowing:
                    try:
                        self.video.set_rate(base_rate)
                    except Exception:
                        pass
                self._auto_pause_slowing = False
            else:
                # 0 ~ 6초 안으로 접근한 경우: 자연스럽게 감속
                self._auto_pause_slowing = True
                if gap <= 1000:
                    target_rate = min(base_rate, 0.5)    # 1초 이내: 0.5x
                elif gap <= 3000:
                    target_rate = min(base_rate, 0.8)    # 1~3초: 0.8x
                else:
                    target_rate = min(base_rate, 1.0)    # 3~6초: 1.0x 이하
                target_rate = max(0.25, min(target_rate, 4.0))
                if abs(current_rate - target_rate) > 1e-3:
                    try:
                        self.video.set_rate(target_rate)
                    except Exception:
                        pass

            # --- 3) 0.1초 이내 정밀 정지용 보정 ---
            # diff > 0  : 목표를 이미 지난 상태
            # diff <= 0 : 아직 목표 전
            diff = cur_ms_safe - int(local_target_ms)

            # 1) 아직 많이 남았으면 멈추지 않음
            if diff < -150:  # 150ms 이상 남아 있으면 계속 재생
                return False

            # 2) 목표 ±0.1~0.15초 안에 들어오면 강제로 정확히 맞춰 놓고 정지
            if -150 <= diff <= 150:
                try:
                    self.video.set_time_ms(int(local_target_ms))
                except Exception:
                    pass
                # 다음 재생을 위해 배속 원복
                try:
                    base_rate = getattr(self, "_auto_pause_base_rate", 1.0) or 1.0
                    self.video.set_rate(base_rate)
                except Exception:
                    pass
                self._auto_pause_slowing = False
                return True

            # 3) 혹시 0.15초 이상 지나서 +2초 이하로 overshoot 된 경우에도
            #    살짝 되감아서 정확히 맞추고 정지
            if 150 < diff <= 2000:
                try:
                    self.video.set_time_ms(int(local_target_ms))
                except Exception:
                    pass
                try:
                    base_rate = getattr(self, "_auto_pause_base_rate", 1.0) or 1.0
                    self.video.set_rate(base_rate)
                except Exception:
                    pass
                self._auto_pause_slowing = False
                return True

            # 2초 이상 지나버린 경우에는 이번 tick에서는 멈추지 않음
            return False
        except Exception:
            # 어떤 오류가 나더라도 재생이 끊기지는 않도록 보호
            return False

    def _carry_supervisor_tick(self):
        """
        v11 carry supervisor (단순 버전)
        - 현재 구현에서는 on_time_changed()에서 실제 자동멈춤을 처리하므로
          여기서는 향후 확장용으로만 남겨 두고, 특별한 동작은 하지 않는다.
        """
        return


    def _auto_pause_should_stop_here(self, ms: int) -> bool:
        """
        브레이크 지점에서부터 N분이 지난 정확한 시점에
        - 배속 때문에 재생 슬라이더가 건너뛰더라도
        - 파란 마커와 '같은 위치'에서 정확히 정지하도록 계산한다.
        """
        # 자동 멈춤 비활성/설정 없음/브레이크 없음이면 동작 안 함
        if not (getattr(self, "auto_pause_enabled", False)
                and getattr(self, "auto_pause_interval_ms", 0)
                and self.break_origin_index is not None
                and self.break_start_ms is not None):
            return False

        if not hasattr(self, "video_lengths") or not self.video_lengths:
            return False

        try:
            origin = int(self.break_origin_index)
            cur_file = int(self.current_file_index())
            target = int(self.auto_pause_interval_ms or 0)  # 브레이크 이후 N분(ms)
            if target <= 0 or cur_file < 0:
                return False
        except Exception:
            return False

        # --- 1) 이번 tick 기준 "누적 경과(ms)" 계산 ---
        elapsed = 0
        try:
            # origin 파일 및 그 이후 파일 기준 누적
            if cur_file < origin:
                return False

            # origin ~ cur_file-1 까지 누적
            for idx in range(origin, cur_file):
                if 0 <= idx < len(self.video_lengths):
                    if idx == origin:
                        # origin 파일에서는 브레이크 시점 이후만 누적
                        origin_len_ms = int(self.video_lengths[origin] * 1000)
                        origin_break_ms = int(self.break_start_ms or 0)
                        remain_origin_ms = max(0, origin_len_ms - origin_break_ms)
                        elapsed += remain_origin_ms
                    else:
                        elapsed += int(self.video_lengths[idx] * 1000)

            # 현재 파일에서의 경과 ms
            if cur_file == origin:
                origin_break_ms = int(self.break_start_ms or 0)
                now_local = max(0, ms - origin_break_ms)
                elapsed = max(0, now_local)
            else:
                elapsed += max(0, int(ms))
        except Exception:
            return False

        # 이전 tick에서의 누적값
        prev_elapsed = getattr(self, "_auto_pause_prev_elapsed", None)
        setattr(self, "_auto_pause_prev_elapsed", elapsed)

        # 경계 통과 여부만 체크 (배속으로 건너뛰더라도 한 번만 잡는다)
        if prev_elapsed is None:
            crossed = (elapsed >= target)
        else:
            crossed = (prev_elapsed < target <= elapsed)

        if not crossed:
            return False

        # --- 2) target ms를 "파일/로컬 ms"로 환산해서 정확한 위치로 seek 후 pause ---
        remaining = target
        try:
            # origin 파일 기준으로 target 위치 찾기
            if 0 <= origin < len(self.video_lengths):
                origin_len_ms = int(self.video_lengths[origin] * 1000)
                origin_break_ms = int(self.break_start_ms or 0)
            else:
                return False

            remain_origin_ms = max(0, origin_len_ms - origin_break_ms)
            if remaining <= remain_origin_ms:
                # origin 파일 안에서 끝
                target_file_idx = origin
                local_ms = origin_break_ms + remaining
            else:
                # 다음 파일들로 carry
                remaining -= remain_origin_ms
                target_file_idx = origin + 1
                local_ms = 0
                while remaining > 0 and target_file_idx < len(self.video_lengths):
                    seg_ms = int(self.video_lengths[target_file_idx] * 1000)
                    if remaining <= seg_ms:
                        local_ms = remaining
                        break
                    remaining -= seg_ms
                    target_file_idx += 1
        except Exception:
            return False

        # 실제로 현재 재생 중인 파일이면: 그 위치로 이동 후 True 반환
        if target_file_idx == cur_file:
            try:
                self.video.set_time_ms(int(local_ms))
            except Exception:
                pass
            return True

        # 다른 파일에 있는 목표지점이면: 여기서는 정지하지 않고,
        # 다음 파일로 넘어갔을 때 위 로직이 다시 동작하면서 정지하게 둔다.
        return False

    def _fmt_ms(self, ms:int) -> str:
        s = max(0, int(round(ms/1000))); h, r = divmod(s, 3600); m, s = divmod(r, 60)
        return f"{h:02d}:{m:02d}:{s:02d}"

    def current_file_index(self) -> int:
        try: return max(0, int(self.fileList.currentRow()))
        except Exception: return 0

    def _update_markers_for_current_file(self):
        """
        현재 파일에 표시할 빨간(시작)·파란(자동멈춤) 마커 위치를 계산.
        - 파란 마커는 "브레이크 시점 + N분" 위치를 절대값으로 계산하여 고정.
        - 여러 파일에 걸쳐 있는 경우, 해당 지점이 속한 파일에서만 표시.
        """
        L = self._len_ms()
        start_frac = None
        pause_frac = None

        if L > 0:
            cur = self.current_file_index()

            # --- 빨간 마커(브레이크 시점) ---
            if self.break_start_ms is not None and self.break_origin_index is not None:
                if cur == self.break_origin_index and 0 <= self.break_start_ms <= L:
                    start_frac = self.break_start_ms / float(L)

            # --- 파란 마커(자동 멈춤 지점) ---
            if (
                getattr(self, "auto_pause_enabled", False)
                and getattr(self, "auto_pause_interval_ms", 0)
                and self.break_origin_index is not None
                and self.break_start_ms is not None
                and hasattr(self, "video_lengths") and self.video_lengths
            ):
                try:
                    origin = int(self.break_origin_index)
                    target = int(self.auto_pause_interval_ms or 0)  # 브레이크 이후 N분(ms)
                    if target > 0 and 0 <= origin < len(self.video_lengths):
                        # 1) origin 파일에 대한 길이(ms)
                        origin_len_ms = int(self.video_lengths[origin] * 1000)
                        origin_break_ms = int(self.break_start_ms)

                        # 브레이크 이후 N분 지점까지 필요한 전체 ms
                        remain_origin_ms = max(0, origin_len_ms - origin_break_ms)

                        if target <= remain_origin_ms:
                            # 같은 파일 안에 자동 멈춤 지점이 존재
                            if cur == origin:
                                pause_ms_local = origin_break_ms + target
                                if 0 <= pause_ms_local <= L:
                                    pause_frac = pause_ms_local / float(L)
                        else:
                            # 다음 파일들로 carry
                            rem = target - remain_origin_ms
                            idx = origin + 1
                            while rem > 0 and idx < len(self.video_lengths):
                                seg_ms = int(self.video_lengths[idx] * 1000)
                                if rem <= seg_ms:
                                    if cur == idx and L > 0:
                                        pause_frac = rem / float(L)
                                    break
                                rem -= seg_ms
                                idx += 1
                except Exception:
                    pass

        try:
            self.slider.setMarkers(start_frac, pause_frac)
        except Exception:
            pass


    def _recalc_carry_on_origin(self):
        """(stub) legacy carry 계산은 사용하지 않음"""
        return



    def on_click_breakpoint(self):
        """브레이크 버튼 클릭 시 동작.

        - 브레이크 버튼이 해제될 때: 모든 브레이크/자동멈춤 기준 정보만 초기화
        - 브레이크 버튼이 눌릴 때:
            * 현재 파일/시간을 브레이크 시작지점으로만 기록
            * 자동멈춤 버튼(btnAutoPause)의 체크 상태는 건드리지 않는다
              (사용자가 직접 시간멈춤을 켜야만 자동멈춤이 동작)
        """
        # 1) 브레이크 버튼을 끈 경우: 기준값/마커만 초기화
        try:
            if hasattr(self, "btnBreakSet") and not self.btnBreakSet.isChecked():
                self.break_start_ms = None
                self.break_origin_index = None
                self._origin_closed = False
                self._awaiting_resume = False
                self._update_markers_for_current_file()
                self._update_break_info()
                return
        except Exception:
            pass

        # 2) 브레이크 버튼을 켠 경우: 현재 파일/시간을 브레이크 기준으로만 기록
        self.break_origin_index = self.current_file_index()
        try:
            self.break_start_ms = self.video.get_time_ms()
        except Exception:
            self.break_start_ms = 0
        self._origin_closed = False
        self._awaiting_resume = False

        # 자동멈춤 버튼이 이미 켜져 있는 경우에만,
        # 현재 콤보박스 값으로 interval 을 다시 계산해 준다.
        try:
            if hasattr(self, "btnAutoPause") and self.btnAutoPause.isChecked():
                try:
                    minutes = int(
                        self.autoPauseCombo.currentData()
                        or self.autoPauseCombo.currentText().replace("분", "")
                        or 0
                    )
                except Exception:
                    minutes = 0
                self.auto_pause_interval_ms = max(0, minutes) * 60_000
                self.auto_pause_enabled = bool(minutes > 0)
        except Exception:
            pass

        # 마커/안내 라벨 갱신
        self._recalc_carry_on_origin()
        self._update_markers_for_current_file()
        self._update_break_info()


    
    def _carry_pause_now(self, file_index:int):
        try:
            if self.current_file_index() != file_index:
                return
            self.video.pause()
        except Exception:
            pass
        # once we actually paused at the scheduled point, clear carry so it does not fire again
        self._carry_remain_ms = 0
        self._carry_sched_file = None
        self._awaiting_resume = True  # wait for manual resume
        self._update_markers_for_current_file()
        self._update_break_info()

    def _apply_carry_across_files(self):
        """Deprecated carry function: no-op (auto-pause handled in on_time_changed)."""
        try:
            self._update_markers_for_current_file()
            self._update_break_info()
        except Exception:
            pass
        return


    def _update_break_info(self):
        """브레이크 정보는 표시하지 않음"""
        lb = getattr(self, 'lbBreakInfo', None)
        if lb is None:
            return
        try:
            lb.clear()
        except Exception:
            pass


    def _carry_supervisor_tick(self):
        """(stub) legacy carry 타이머는 사용하지 않음"""
        return


    def _make_group_page(self, a:int, b:int, c:int) -> QtWidgets.QWidget:
        """Create a 3-column (1:1:1) fixed grid page for a direction group.
        Compress-left: only active directions are placed from the left columns; remaining columns are placeholders.
        """
        page = QtWidgets.QWidget()
        grid = QtWidgets.QGridLayout(page)
        sc = getattr(self, 'panel_scale', 0.70)
        m = max(1, int(6 * sc))
        s = max(1, int(6 * sc))
        grid.setContentsMargins(m, m, m, m)
        grid.setHorizontalSpacing(s)
        grid.setVerticalSpacing(s)
        enabled = set(self.get_enabled_indices())
        triplet = (a, b, c)
        active = [d for d in triplet if (d in enabled) and (d < len(self.cfg.directions))]
        for col in range(3):
            grid.setColumnStretch(col, 1)
            if col < len(active):
                didx = active[col]
                try:
                    grid.addWidget(self.build_dir_panel(didx), 0, col)
                except Exception:
                    ph = QtWidgets.QWidget()
                    ph.setSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding,
                                     QtWidgets.QSizePolicy.Policy.MinimumExpanding)
                    grid.addWidget(ph, 0, col)
            else:
                ph = QtWidgets.QWidget()
                ph.setSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding,
                                 QtWidgets.QSizePolicy.Policy.MinimumExpanding)
                grid.addWidget(ph, 0, col)
        return page



    

    class _HeaderlessTabWidget(QtWidgets.QTabWidget):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self._bar = QtWidgets.QTabBar(parent=self)
            self._bar.setVisible(False)
            self._bar.setFixedHeight(0)
            self._bar.setExpanding(False)
            super().setTabBar(self._bar)
            self._apply_no_header_style()

        def setTabBar(self, bar: QtWidgets.QTabBar) -> None:
            super().setTabBar(self._bar)
            self._apply_no_header_style()

        def _apply_no_header_style(self):
            self.setStyleSheet(
                "QTabBar { height:0px; margin:0; padding:0; }QTabBar::tab { height:0px; width:0px; margin:0; padding:0; border:0; }"
            )


    class _NullTabBar(QtWidgets.QTabBar):
        def addTab(self, *args, **kwargs): return -1
        def setCurrentIndex(self, *args, **kwargs): pass
        def count(self): return 0



    def _sync_group_tabs(self):
        """Mirror QTabWidget's tabs into the compact QTabBar placed next to slotCombo."""
        try:
            # Clear existing tabs
            while self.groupTabs.count():
                self.groupTabs.removeTab(0)
        except Exception:
            return
        try:
            for i in range(self.tab.count()):
                self.groupTabs.addTab(self.tab.tabText(i))
            self.groupTabs.setCurrentIndex(self.tab.currentIndex())
        except Exception:
            pass
        # Wire signals (guard duplicates)
        try:
            self.groupTabs.currentChanged.disconnect()
        except Exception:
            pass
        try:
            self.tab.currentChanged.disconnect(self.groupTabs.setCurrentIndex)
        except Exception:
            pass
        self.groupTabs.currentChanged.connect(self.tab.setCurrentIndex, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.tab.currentChanged.connect(self.groupTabs.setCurrentIndex, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)

    def open_direction_settings(self):
        """방향 설정 다이얼로그 후, 활성 방향만 포함하는 탭을 다시 구성."""
        # 1~30 방향을 3개씩 그룹 (1-3, 4-6, ...)
        groups = [(i, i+1, i+2) for i in range(0, 30, 3)]

        dlg = DirectionSettingsDialog(self, cfg=self.cfg)
        if dlg.exec() != QtWidgets.QDialog.DialogCode.Accepted:
            return

        # 기존 탭 제거
        try:
            self.tab.setParent(None)
        except Exception:
            pass

        # 패널 캐시 초기화
        self.panel_btns = {}
        self.panel_lbls = {}
        self.shortcut_lbls = {}

        # 새 헤더 없는 탭 위젯 생성
        self.tab = self._HeaderlessTabWidget()

        max_dirs = min(30, len(self.cfg.directions))
        enabled = set(self.get_enabled_indices())

        # 탭별 활성 방향 인덱스 매핑 초기화
        self.group_tab_mapping = []

        # 그룹별로, 활성 방향이 하나라도 있는 경우에만 탭 생성
        for a, b, c in groups:
            enabled_in_group = [d for d in (a, b, c) if d in enabled and d < max_dirs]
            if not enabled_in_group:
                continue
            page = self._make_group_page(a, b, c)
            lbl = " - ".join(str(i + 1) for i in enabled_in_group)
            self.tab.addTab(page, lbl)
            # 이 탭에 속한 실제 방향 인덱스 기억
            self.group_tab_mapping.append(list(enabled_in_group))

        # 레이아웃에 다시 붙이기
        try:
            self.left_layout.addWidget(self.tab)
        except Exception:
            try:
                self.centralWidget().layout().addWidget(self.tab)
            except Exception:
                pass

        # groupTabs 동기화
        try:
            self._sync_group_tabs()
        except Exception:
            pass

        # 활성 방향을 첫 번째 활성 방향으로 재설정
        self.active_dir_index = self.first_enabled()
        self.refresh_all_quick_counts()
        self.update_active_highlight()

        # 오른쪽 버튼들의 중복 연결 해제 후 다시 연결
        try:
            self.btnSheet.clicked.disconnect()
        except Exception:
            pass
        try:
            self.btnExcel.clicked.disconnect()
        except Exception:
            pass
        try:
            self.btnReset.clicked.disconnect()
        except Exception:
            pass

        self.btnExcel.clicked.connect(
            self.save_xlsx,
            getattr(QtCore.Qt, "ConnectionType", QtCore.Qt).UniqueConnection,
        )
        self.btnSheet.clicked.connect(
            self.open_sheet,
            getattr(QtCore.Qt, "ConnectionType", QtCore.Qt).UniqueConnection,
        )
        self.btnReset.clicked.connect(
            self.clear_current_counts,
            getattr(QtCore.Qt, "ConnectionType", QtCore.Qt).UniqueConnection,
        )

        # 테마 재적용
        self.apply_fluent_dark()

    def _apply_initial_constraints(self):
        """초기 실행 시 분할기 크기 제약을 한 번 적용합니다."""
        try:
            self._enforce_splitter_constraints()
        except Exception:
            pass

    
    def _enforce_splitter_constraints(self):
        """폴더 목록창/영상 재생창의 가로 크기 제약을 유지합니다.

        - 오른쪽 폴더 목록창은 최대 폭(self._right_fixed)을 넘지 않도록 제한
        - 왼쪽 영상 재생창은 최소 폭(self._left_min)보다 더 작아지지 않도록 제한
        - 폴더창이 충분히 작아지면(예: 40px 미만) 완전히 접힌 상태로 처리
        """
        try:
            splitter = getattr(self, "splitter", None)
            if splitter is None:
                return
            sizes = splitter.sizes()
            if len(sizes) < 2:
                return

            total = max(0, sum(sizes))
            cur_left, cur_right = sizes[0], sizes[1]

            right_max = getattr(self, "_right_fixed", 260)
            left_min = getattr(self, "_left_min", 800)

            # 폴더창이 충분히 작아졌다면 완전히 접힌 상태로 취급
            if 0 < cur_right < 40:
                cur_right = 0
                cur_left = total

            # 폴더창이 완전히 접힌 상태라면, 왼쪽이 전체를 사용
            if cur_right == 0:
                splitter.blockSignals(True)
                splitter.setSizes([total, 0])
                splitter.blockSignals(False)
                self._right_last = 0
                return

            # 오른쪽 폭은 0 이상, right_max 이하로 제한
            if cur_right > right_max:
                cur_right = right_max
            new_right = max(0, min(cur_right, right_max))

            # 왼쪽은 최소 left_min 보장
            new_left = total - new_right
            if left_min and new_left < left_min:
                new_left = left_min
                new_right = max(0, total - new_left)

                # 다시 한 번 오른쪽 상한 적용
                if new_right > right_max:
                    new_right = right_max
                    new_left = max(left_min, total - new_right)

            # 음수 방지
            if new_left < 0:
                new_left = 0
            if new_right < 0:
                new_right = 0

            splitter.blockSignals(True)
            splitter.setSizes([new_left, new_right])
            splitter.blockSignals(False)

            self._right_last = new_right
        except Exception:
            pass

    def _schedule_splitter_fix(self):
        """분할바 이동 시 제약 적용을 한 프레임 뒤에 한 번만 실행하도록 예약합니다."""
        try:
            if getattr(self, "_splitter_fix_scheduled", False):
                return
            self._splitter_fix_scheduled = True
            QtCore.QTimer.singleShot(0, self._apply_splitter_fix_once)
        except Exception:
            pass

    def _apply_splitter_fix_once(self):
        """예약된 분할바 제약을 실제로 한 번만 적용합니다."""
        try:
            self._splitter_fix_scheduled = False
        except Exception:
            pass
        try:
            self._enforce_splitter_constraints()
        except Exception:
            pass

    
    def on_splitter_moved(self, pos:int, index:int):
        """분할바를 드래그할 때 폴더목록창/영상재생창의 가로폭을 즉시 제약합니다.

        - 오른쪽 폴더창은 self._right_fixed 보다 넓어지지 않음
        - 왼쪽 영상창은 self._left_min 보다 작아지지 않음
        - 폴더창이 충분히 작아지면(40px 미만) 완전히 접힘(0)
        """
        try:
            splitter = getattr(self, "splitter", None)
            if splitter is None:
                return
            sizes = splitter.sizes()
            if len(sizes) < 2:
                return

            total = max(0, sum(sizes))
            left, right = sizes[0], sizes[1]

            right_lock = getattr(self, "_right_fixed", right)
            left_min = getattr(self, "_left_min", 0)

            # 폴더창이 충분히 작아지면 완전히 접기
            if 0 < right < 40:
                right = 0
                left = total

            # 폴더창을 넓히려는 경우: 최대 폭을 넘지 못하게 잠금
            if right > right_lock:
                right = right_lock
                left = total - right

            # 영상창 최소 폭 보장
            if left_min and left < left_min:
                left = left_min
                right = max(0, total - left)
                if right > right_lock:
                    right = right_lock
                    left = max(left_min, total - right)

            if left < 0:
                left = 0
            if right < 0:
                right = 0

            splitter.blockSignals(True)
            splitter.setSizes([left, right])
            splitter.blockSignals(False)
        except Exception:
            pass

# === YouTube-style control icons (light theme friendly) ===
    def _yt_color(self): return QtGui.QColor("#222222")
    def make_play_icon(self, size=28):
        pm = QtGui.QPixmap(size, size); pm.fill(QtCore.Qt.GlobalColor.transparent)
        p = QtGui.QPainter(pm); p.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)
        p.setPen(QtCore.Qt.PenStyle.NoPen); p.setBrush(self._yt_color())
        m = int(size*0.18)
        path = QtGui.QPainterPath(); path.moveTo(m,m); path.lineTo(size-m, size//2); path.lineTo(m, size-m); path.closeSubpath()
        p.drawPath(path); p.end(); return QtGui.QIcon(pm)
    def make_pause_icon(self, size=28):
        pm=QtGui.QPixmap(size,size); pm.fill(QtCore.Qt.GlobalColor.transparent)
        p=QtGui.QPainter(pm); p.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)
        p.setPen(QtCore.Qt.PenStyle.NoPen); p.setBrush(self._yt_color())
        bw=int(size*0.22); g=int(size*0.12); x=int((size-(2*bw+g))/2)
        p.drawRoundedRect(x, int(size*0.18), bw, int(size*0.64), 3,3)
        p.drawRoundedRect(x+bw+g, int(size*0.18), bw, int(size*0.64), 3,3)
        p.end(); return QtGui.QIcon(pm)
    def make_prev_icon(self, size=26):
        pm=QtGui.QPixmap(size,size); pm.fill(QtCore.Qt.GlobalColor.transparent)
        p=QtGui.QPainter(pm); p.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)
        p.setPen(QtCore.Qt.PenStyle.NoPen); p.setBrush(self._yt_color())
        m=int(size*0.18)
        # two triangles + left bar
        path=QtGui.QPainterPath()
        path.moveTo(size-m, m); path.lineTo(int(size*0.48), size//2); path.lineTo(size-m, size-m); path.closeSubpath()
        path.moveTo(int(size*0.52), m); path.lineTo(m, size//2); path.lineTo(int(size*0.52), size-m); path.closeSubpath()
        p.drawPath(path)
        p.fillRect(int(size*0.10), int(size*0.18), int(size*0.10), int(size*0.64), self._yt_color())
        p.end(); return QtGui.QIcon(pm)
    def make_next_icon(self, size=26):
        pm=QtGui.QPixmap(size,size); pm.fill(QtCore.Qt.GlobalColor.transparent)
        p=QtGui.QPainter(pm); p.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)
        p.setPen(QtCore.Qt.PenStyle.NoPen); p.setBrush(self._yt_color())
        m=int(size*0.18)
        path=QtGui.QPainterPath()
        path.moveTo(m, m); path.lineTo(int(size*0.52), size//2); path.lineTo(m, size-m); path.closeSubpath()
        path.moveTo(int(size*0.48), m); path.lineTo(size-m, size//2); path.lineTo(int(size*0.48), size-m); path.closeSubpath()
        p.drawPath(path)
        p.fillRect(int(size*0.80), int(size*0.18), int(size*0.10), int(size*0.64), self._yt_color())
        p.end(); return QtGui.QIcon(pm)
    
    def make_autonext_icon(self, size=22, active=False):
        pm = QtGui.QPixmap(size, size); pm.fill(QtCore.Qt.GlobalColor.transparent)
        p = QtGui.QPainter(pm); p.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)
        p.setPen(QtGui.QPen(QtGui.QColor(70,120,200), 2))
        p.setBrush(QtCore.Qt.BrushStyle.NoBrush)
        rect = QtCore.QRectF(size*0.18, size*0.18, size*0.64, size*0.64)
        start_angle = 40 * 16; span_angle = 250 * 16
        p.drawArc(rect, start_angle, span_angle)
        path = QtGui.QPainterPath()
        tipx = rect.right(); tipy = rect.center().y()
        path.moveTo(tipx - size*0.10, tipy - size*0.10)
        path.lineTo(tipx + size*0.02, tipy)
        path.lineTo(tipx - size*0.10, tipy + size*0.10)
        p.setBrush(QtGui.QBrush(QtGui.QColor(70,120,200)))
        p.drawPath(path)
        if active:
            p.setPen(QtGui.QPen(QtGui.QColor(70,160,90), 2))
            p.setBrush(QtCore.Qt.BrushStyle.NoBrush)
            p.drawRoundedRect(int(size*0.06), int(size*0.06), int(size*0.88), int(size*0.88), 5, 5)
        p.end(); return QtGui.QIcon(pm)
    def make_stop_icon(self, size=24):
        pm=QtGui.QPixmap(size,size); pm.fill(QtCore.Qt.GlobalColor.transparent)
        p=QtGui.QPainter(pm); p.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing)
        p.setPen(QtCore.Qt.PenStyle.NoPen); p.setBrush(self._yt_color())
        m=int(size*0.22)
        p.drawRoundedRect(m, m, size-2*m, size-2*m, 4,4)
        p.end(); return QtGui.QIcon(pm)

    def rescale_vehicle_buttons_for(self, didx:int):

        panel = getattr(self, 'panels', {}).get(didx) if hasattr(self, 'panels') else None

        btns = getattr(self, 'dir_buttons', {}).get(didx, []) if hasattr(self, 'dir_buttons') else []

        if not panel or not btns:

            return

        sc = getattr(self, "panel_scale", 0.70)

        vc = self.cfg.vehicle_count() if hasattr(self, 'cfg') else 6

        w  = max(1, panel.width())

        # scaled layout calculations

        cols = max(3, min(12, int((w // 140) / sc)))  # more columns when scaled

        gap  = max(2, int(8 * sc))

        bw   = max(48, int((w - (cols + 1) * gap) / cols))

        base_pt = 12 if vc <= 10 else (11 if vc <= 12 else 10)

        font_pt = max(7, int(round(base_pt * sc)))

        btn_h   = max(16, int(round(28 * sc)))

        for b in btns:

            b.setMinimumWidth(bw)

            b.setFixedHeight(btn_h)

            f = b.font()

            f.setPointSize(font_pt)

            b.setFont(f)


    def rescale_all_vehicle_buttons(self):
        if not hasattr(self, 'dir_buttons'): return
        for didx in list(self.dir_buttons.keys()):
            self.rescale_vehicle_buttons_for(didx)

    def assign_vehicle_hotkeys_default(self, count:int):
        keys10 = list('1234567890')
        keys12 = list('1234567890-=')
        keys = keys10 if count==10 else (keys12 if count==12 else [])
        if not keys:
            return
        # Ensure dir_hotkeys structure
        if not hasattr(self.cfg, 'dir_hotkeys') or not self.cfg.dir_hotkeys:
            self.cfg.dir_hotkeys = [[] for _ in range(30)]
        for d in range(min(30, len(self.cfg.directions))):
            lst = list(keys)
            self.cfg.dir_hotkeys[d] = lst
        # Refresh any open panels
        try:
            self.refresh_all_quick_counts()
        except Exception:
            pass

    
    def apply_fluent_dark(self):
        """화면 스타일(일반 / 다크)에 따라 전체 스타일을 적용합니다."""
        mode = getattr(self, "theme_mode", "light")
        if mode not in ("light", "dark"):
            mode = "light"

        # 다크 모드 팔레트: 남색이 아닌 다크 그레이 계열
        if mode == "dark":
            base = "#212121"
            panel = "#303030"
            hover = "#3a3a3a"
            text = "#f5f5f5"
            muted = "#9e9e9e"
            border = "#3c3c3c"
            header_bg = "#303030"
            table_bg = "#303030"
            table_sel = "#3b82f6"
            input_bg = "#181818"
        else:
            # 라이트 모드 팔레트
            base = "#ffffff"
            panel = "#f6f8fb"
            hover = "#e7ebf3"
            text = "#111827"
            muted = "#6b7280"
            border = "#cfd4dc"
            header_bg = "#f3f4f6"
            table_bg = "#ffffff"
            table_sel = "#e6f0ff"
            input_bg = "#ffffff"

        base_pt = self.F(10.5)
        self.setStyleSheet(f"""
            QWidget {{
                background:{base};
                color:{text};
                font-family:"Segoe UI","Pretendard";
                font-size:{base_pt}pt;
            }}
            QGroupBox {{
                border:1px solid {border};
                border-radius:10px;
                margin-top:{self.S(10)}px;
                padding:{self.S(8)}px;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left:{self.S(12)}px;
                padding:0 {self.S(6)}px;
            }}
            QPushButton {{
                background:{panel};
                border:1px solid {border};
                border-radius:10px;
                padding:{self.S(6)}px {self.S(10)}px;
            }}
            QPushButton:hover {{
                background:{hover};
            }}
            QPushButton:pressed {{
                background:{hover};
                border-color:{table_sel};
            }}
            QComboBox, QLineEdit, QDateEdit {{
                background:{input_bg};
                border:1px solid {border};
                border-radius:8px;
                padding:{self.S(4)}px {self.S(8)}px;
                color:{text};
            }}
            QListWidget, QListView, QTreeView {{
                background:{panel};
                border:1px solid {border};
                border-radius:8px;
                color:{text};
            }}
            QTableWidget, QTableView {{
                background:{table_bg};
                gridline-color:{border};
                selection-background-color:{table_sel};
                color:{text};
            }}
            QHeaderView::section {{
                background:{header_bg};
                color:{text};
                border:1px solid {border};
                padding:{self.S(4)}px;
            }}
            QTabBar::tab {{
                background:{panel};
                border:1px solid {border};
                padding:{self.S(6)}px {self.S(12)}px;
                border-top-left-radius:8px;
                border-top-right-radius:8px;
            }}
            QTabBar::tab:selected {{
                background:{hover};
                color:{text};
            }}
        """)
        
        # 개별 위젯(특히 우측 폴더 목록)의 텍스트 색을 모드에 맞게 조정
        try:
            file_list = getattr(self, "fileList", None)
            if file_list is not None:
                common = (
                    f"QListWidget::item{{min-height:{self.S(5)}px;"
                    f" padding:{self.S(0.5)}px {self.S(1.5)}px;}}"
                )
                if mode == "dark":
                    # 다크 모드: 텍스트는 흰색, 배경은 버튼과 동일한 패널 색상
                    file_list_style = (
                        common
                        + f"QListWidget{{font-size:{self.F(9)}pt;"
                        " padding-top:0px; padding-bottom:0px;"
                        " color:#f5f5f5; background:#303030;}}"
                        " QListWidget::item{ color:#f5f5f5; }"
                    )
                else:
                    # 라이트 모드: 기본 검정 텍스트, 배경은 전역 스타일에 따름
                    file_list_style = (
                        common
                        + f"QListWidget{{font-size:{self.F(9)}pt;"
                        " padding-top:0px; padding-bottom:0px;"
                        " color:#000000;}}"
                        " QListWidget::item{ color:#000000; }"
                    )
                file_list.setStyleSheet(file_list_style)

                # 팔레트에도 텍스트 색을 강제로 지정하여 OS/스타일 영향 최소화
                pal_file = file_list.palette()
                if mode == "dark":
                    pal_file.setColor(QtGui.QPalette.ColorRole.Text, QtGui.QColor("#f5f5f5"))
                else:
                    pal_file.setColor(QtGui.QPalette.ColorRole.Text, QtGui.QColor("#000000"))
                file_list.setPalette(pal_file)
        except Exception:
            pass


        pal = self.palette()
        try:
            pal.setColor(self.backgroundRole(), QtGui.QColor(base))
            self.setPalette(pal)
        except Exception:
            pass

    def set_theme_mode(self, mode: str):
        """라이트/다크 모드 전환 핸들러."""
        if mode not in ("light", "dark"):
            mode = "light"
        self.theme_mode = mode
        # 실제 스타일 재적용
        self.apply_fluent_dark()
        # 토글 UI 동기화
        self._update_theme_toggle_ui()

    def _update_theme_toggle_ui(self):
        """상단 우측 토글 버튼 스타일을 현재 상태에 맞게 갱신."""
        try:
            btn = getattr(self, "btnThemeMode", None)
            if btn is None:
                return

            is_dark = (self.theme_mode == "dark")
            btn.setChecked(is_dark)

            if is_dark:
                bg = "#1e1e1e"
                fg = "#f5f5f5"
                border = "#22c55e"
                text_label = "다크 모드"
            else:
                bg = "#ffffff"
                fg = "#111827"
                border = "#9ca3af"
                text_label = "라이트 모드"

            btn.setStyleSheet(f"""
                QToolButton {{
                    border:{2 if is_dark else 1}px solid {border};
                    border-radius:{self.S(8)}px;
                    padding:{self.S(2)}px {self.S(8)}px;
                    background:{bg};
                    color:{fg};
                }}
            """)
            btn.setText(text_label)
        except Exception:
            pass

    def _build_theme_toggle(self) -> QtWidgets.QWidget:
        """라이트/다크 모드 토글 버튼 위젯을 생성해서 반환합니다.

        이 위젯은 보통 메뉴바의 우측 상단 코너에 배치됩니다.
        """
        try:
            container = QtWidgets.QFrame()
            box = QtWidgets.QHBoxLayout(container)
            # 메뉴바 오른쪽 모서리에서 약간 안쪽으로 들어오도록 여백 조정
            # (left, top, right, bottom)
            box.setContentsMargins(self.S(0), self.S(2), self.S(14), self.S(0))
            box.setSpacing(self.S(2))

            self.btnThemeMode = QtWidgets.QToolButton()
            self.btnThemeMode.setCheckable(True)
            self.btnThemeMode.setToolButtonStyle(
                QtCore.Qt.ToolButtonStyle.ToolButtonTextOnly
            )
            self.btnThemeMode.setFixedWidth(self.S(110))
            self.btnThemeMode.setFixedHeight(self.S(28))

            # 시그널 연결: 체크되면 다크, 해제되면 라이트
            self.btnThemeMode.toggled.connect(
                lambda checked: self.set_theme_mode("dark" if checked else "light")
            )

            box.addWidget(self.btnThemeMode)

            # 초기 텍스트/색상 반영
            self._update_theme_toggle_ui()
            return container
        except Exception:
            # 실패 시에도 레이아웃에 추가 가능한 빈 위젯을 반환
            return QtWidgets.QWidget()


    def get_enabled_indices(self):
        try:
            return [i for i, ok in enumerate(self.cfg.enabled_directions) if ok and i < len(self.cfg.directions)]
        except Exception:
            return list(range(min(12, len(self.cfg.directions))))
    def first_enabled(self):
        lst = self.get_enabled_indices()
        return lst[0] if lst else 0
    def __init__(self, user:dict):
        super().__init__(); self.user=user
        self._carry_next_pending = False  # for safe auto-next transitions
        # === Global UI scaling helpers ===
        self.ui_scale = getattr(self, "ui_scale", 0.85)  # 85% scale (adjust 0.75~0.95 as needed)
        self.panel_scale = 0.70  # panel scale: 70%
        self.S = lambda px: max(1, int(round(px * self.ui_scale)))   # size scaler
        self.F = lambda pt: max(6, int(round(pt * self.ui_scale)))   # font scaler

        # 화면 스타일 (일반 / 다크)
        self.theme_mode = "light"  # 기본값: 라이트 모드
        self._theme_group = None  # 라디오 토글 버튼 그룹 참조

        self.setWindowTitle(f"{APP_NAME} - {user['username']} ({user['role']})")
        self.cfg=ProjectConfig();
        # normalize hotkeys for up to 30 directions
        if not hasattr(self.cfg, "dir_hotkeys") or len(self.cfg.dir_hotkeys) < 30:
            base = getattr(self.cfg, "dir_hotkeys", [[str(i+1) for i in range(6)]])
            needed = 30 - len(base)
            self.cfg.dir_hotkeys = base + [base[0][:] for _ in range(max(0, needed))]
        self.counts=CountTable(self.cfg.directions, self.cfg.vehicle_types)
        self.current_file: Optional[str]=None; self.current_folder: Optional[Path]=None
        self.current_slot_start:int = self.cfg.active_windows[0][0] if self.cfg.active_windows else 0
        self.active_dir_index:int=0

        central=QtWidgets.QWidget()
        self.setCentralWidget(central)
        root=QtWidgets.QVBoxLayout(central)
        # 상단은 전체 화면을 비우고, 라이트/다크 토글은 우측 패널 최상단에 배치합니다.
        left=QtWidgets.QVBoxLayout()
        self.left_layout = left  # store left layout reference

        # === Top Bar: [⟳][과업 콤보][지점 콤보] … [⚙][🌗] ===
        topbar = QtWidgets.QHBoxLayout()
        topbar.setContentsMargins(self.S(6), self.S(6), self.S(6), 0)
        topbar.setSpacing(self.S(8))

        self.btnRefreshTop = QtWidgets.QToolButton()
        self.btnRefreshTop.setText("⟳")
        self.btnRefreshTop.setToolTip("환경설정 새로고침")
        self.btnRefreshTop.setFixedSize(self.S(28), self.S(28))

        self.projectCombo = QtWidgets.QComboBox()
        self.projectCombo.setEditable(False)
        self.projectCombo.setPlaceholderText("과업")
        self.projectCombo.setFixedWidth(self.S(320))

        self.siteCombo = QtWidgets.QComboBox()
        self.siteCombo.setEditable(False)
        self.siteCombo.setPlaceholderText("지점")
        self.siteCombo.setFixedWidth(self.S(220))

        self.btnEnvSettings = QtWidgets.QToolButton()
        self.btnEnvSettings.setText("⚙")
        self.btnEnvSettings.setToolTip("환경설정 열기")
        self.btnEnvSettings.setFixedSize(self.S(28), self.S(28))

        # 테마 토글(🌗) 위젯 생성
        theme_widget = None
        try:
            theme_widget = self._build_theme_toggle()
        except Exception:
            theme_widget = None

        topbar.addWidget(self.btnRefreshTop)
        topbar.addWidget(self.projectCombo)
        topbar.addWidget(self.siteCombo)
        topbar.addStretch(1)
        topbar.addWidget(self.btnEnvSettings)
        if theme_widget is not None:
            topbar.addWidget(theme_widget)

        root.addLayout(topbar)

        # 시그널 연결
        self.btnRefreshTop.clicked.connect(self.open_env_hotkeys_db)
        self.projectCombo.currentIndexChanged.connect(self._on_env_project_changed)
        self.siteCombo.currentIndexChanged.connect(self._on_env_site_changed)
        # 안전장치: 메서드가 누락된 경우 대비(과거 버전/병합 오류 방지)
        if not hasattr(self, 'open_env_settings_window'):
            self.open_env_settings_window = self._open_env_settings_window_fallback

        self.btnEnvSettings.clicked.connect(self.open_env_settings_window)

        # 시작 시 자동 로드(가능하면)
        # (속도 개선) 시작 시 NAS 탐색/로드는 시간이 걸릴 수 있어 자동 로드를 끕니다.
        # 필요 시 상단 [⟳] 버튼 또는 [⚙] 버튼에서 불러오세요.
        # QtCore.QTimer.singleShot(50, self.open_env_hotkeys_db)
        # -- force 8pt font for top-left controls --
        try:
            widgets=(self.projectCombo, self.siteCombo, self.dateEdit, self.btnStart, self.btnStop)
            for w in widgets:
                f = QtGui.QFont(self.font()); f.setPointSize(8); w.setFont(f)
        except Exception:
            pass
        # Legacy header removed (keep attributes for compatibility)
        self.headerTask = QtWidgets.QLabel("-")
        self.headerSite = QtWidgets.QLabel("-")
        # (layout intentionally not added)

        self.video=MpvVideoWidget(); self.video.setMinimumHeight(560)
        left.addWidget(self.video, stretch=14)
        self.video.mediaEnded.connect(self.on_media_ended); self.video.timeChanged.connect(self.on_time_changed)

        # 라벨 강제 갱신 타이머: VLC가 length를 늦게 제공하는 경우 대비
        try:
            if not hasattr(self, "_labelTick"):
                self._labelTick = QtCore.QTimer(self)
                self._labelTick.setInterval(250)
                def _label_tick():
                    try:
                        cur = self.video.get_time_ms()
                        L = self.video.length_ms()
                        # 일부 코덱에서 length가 0으로 오래 남으면, position 기반 추정도 가능
                        if not L or L <= 0:
                            pos = self.video.get_position()
                            # pos만으로는 총길이를 알 수 없으므로, 0일 때는 현재시간만 표시
                            self.playTimeLbl.setText(f"{self.ms_to_hms(cur)} / 00:00:00")
                        else:
                            self.update_time_labels(cur, max(0, L-cur))
                    except Exception:
                        pass
                self._labelTick.timeout.connect(_label_tick)
                self._labelTick.start()
        except Exception:
            pass


        # Create a plain QSlider (horizontal) without custom styles
        # --- 유튜브 테마(빨간색) 클릭 이동 슬라이더 + 한 줄 구성 ---
        self.slider = SeekSlider(QtCore.Qt.Orientation.Horizontal)
        self.slider.setRange(0, 1000)
        self.slider.setSingleStep(1)
        self.slider.setPageStep(10)
        self.slider.setStyleSheet("""
QSlider::groove:horizontal { height:6px; background:#dddddd; border-radius:3px; }
QSlider::sub-page:horizontal { background:#ff0000; height:6px; border-radius:3px; }
QSlider::add-page:horizontal { background:#dddddd; height:6px; border-radius:3px; }
QSlider::handle:horizontal { width:12px; height:12px; margin:-4px 0; border-radius:6px;
    background:#ffffff; border:1px solid #bbbbbb; }
""")

        # 배속/재생시간 라벨

        
        # 배속/재생시간 라벨 (seekRow에서 사용)
        self.rateLbl = QtWidgets.QLabel("배속: 1.00x")
        self.playTimeLbl = QtWidgets.QLabel("00:00:00 / 00:00:00")
        try:
            f_pt = self.F(8)
            fnt = self.playTimeLbl.font(); fnt.setPointSize(f_pt); self.playTimeLbl.setFont(fnt)
            self.playTimeLbl.setFixedWidth(self.S(120))
        except Exception:
            pass
        self.playTimeLbl.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        try:
            self.playTimeLbl.mousePressEvent = self.on_time_label_clicked
        except Exception:
            pass
        self.timeMode = 0
# [배속/재생시간] [슬라이더] 가로 한 줄
        seekRow = QtWidgets.QHBoxLayout()
        seekRow.addWidget(self.rateLbl)
        seekRow.addSpacing(8)
        seekRow.addWidget(self.playTimeLbl)
        seekRow.addSpacing(12)
        seekRow.addWidget(self.slider, 1)

        # === Volume controls: slider + mute button ===
        self.volSlider = QtWidgets.QSlider(QtCore.Qt.Orientation.Horizontal)
        self.volSlider.setRange(0, 200)
        try:
            cur_vol = int(self.video.mediaplayer.audio_get_volume())
        except Exception:
            cur_vol = 100
        if cur_vol <= 0:
            cur_vol = 100
        self.volSlider.setValue(max(0, min(200, cur_vol)))
        try:
            self.volSlider.setFixedWidth(self.S(80))
        except Exception:
            pass
        self.volSlider.setToolTip("음량 조절")
        # 내부 상태 초기화
        self._is_muted = False
        self._last_volume_before_mute = self.volSlider.value()
        self.volSlider.valueChanged.connect(self.on_volume_changed)

        seekRow.addSpacing(8)

        # 음소거 버튼 (아이콘 텍스트)
        self.muteBtn = QtWidgets.QToolButton()
        self.muteBtn.setToolTip("음소거 / 음소거 해제")
        try:
            self.muteBtn.setFixedWidth(self.S(32))
        except Exception:
            pass
        self.muteBtn.clicked.connect(self.toggle_mute)
        seekRow.addWidget(self.volSlider)
        seekRow.addWidget(self.muteBtn)

        # 초기 아이콘 상태 반영
        try:
            self.update_volume_icon(self.volSlider.value())
        except Exception:
            pass

        left.addLayout(seekRow)
        # Controls row (clean: no 자동정지/책갈피/구간 버튼)
        under=QtWidgets.QHBoxLayout()
        self.playTimeLbl.setFixedWidth(self.S(120))
        self.playTimeLbl.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
        self.playTimeLbl.mousePressEvent = self.on_time_label_clicked
        self.timeMode=0
        self.chkAutonext=QtWidgets.QCheckBox("자동 다음 재생"); self.chkAutonext.hide()
        # -- AutoNext sync: 버튼 <-> 체크박스 --
        def _sync_from_btn(checked: bool):
            try:
                if self.chkAutonext.isChecked() != checked:
                    self.chkAutonext.setChecked(checked)
                # update icon visual (active glow when checked)
                if getattr(self, "autoNextBtn", None):
                    self.autoNextBtn.setIcon(self.make_autonext_icon(20, checked))
            except Exception:
                pass

        def _sync_from_chk(checked: bool):
            try:
                if getattr(self, "autoNextBtn", None):
                    self.autoNextBtn.setChecked(checked)
                    self.autoNextBtn.setIcon(self.make_autonext_icon(20, checked))
            except Exception:
                pass
    

        try:
            from PyQt6.QtGui import QShortcut, QKeySequence
            self._autoNextShortcut = QShortcut(QKeySequence('Ctrl+Alt+A'), self)
            self._autoNextShortcut.setContext(QtCore.Qt.ShortcutContext.ApplicationShortcut)
            def _toggle_autonext():
                if getattr(self, 'autoNextBtn', None):
                    self.autoNextBtn.toggle()
            self._autoNextShortcut.activated.connect(_toggle_autonext)
        except Exception:
            pass

                
        # Sync AutoNext icon button with checkbox
        try:
            self.autoNextBtn.setChecked(False)
        except Exception:
            pass
        def _sync_from_btn(checked: bool):
            try:
                if self.chkAutonext.isChecked()!=checked:
                    self.chkAutonext.setChecked(checked)
                self.autoNextBtn.setIcon(self.make_autonext_icon(20, checked))
            except Exception:
                pass
        def _sync_from_chk(checked: bool):
            try:
                if getattr(self, "autoNextBtn", None):
                    self.autoNextBtn.setChecked(checked)
                    self.autoNextBtn.setIcon(self.make_autonext_icon(20, checked))
            except Exception:
                pass
        if getattr(self, "autoNextBtn", None):
            self.autoNextBtn.toggled.connect(_sync_from_btn, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.chkAutonext.toggled.connect(_sync_from_chk, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.slotCombo=QtWidgets.QComboBox(); self.slotCombo.setFixedWidth(100)
        
        # Enforce larger, readable slot combo
        self.slotCombo.setFixedHeight(28)
        try:
            f=QtGui.QFont(self.slotCombo.font()); f.setPointSize(12); self.slotCombo.setFont(f)
        except Exception: pass
        
        self.rebuild_slot_combo(select_start=self.current_slot_start); self.slotCombo.currentIndexChanged.connect(self.on_slot_combo_changed)
        under.addWidget(self.slotCombo); under.addSpacing(10)
        # 방향 그룹 탭을 조사시간(슬롯) 선택 콤보박스 오른쪽에 배치
        try:
            self.groupTabs = QtWidgets.QTabBar()
            self.groupTabs.setExpanding(False)
            self.groupTabs.setMovable(False)
            self.groupTabs.setDrawBase(False)
            under.addWidget(self.groupTabs)
            self._sync_group_tabs()
            # 탭과 메인 탭 간 동기화
            self.groupTabs.currentChanged.connect(self.tab.setCurrentIndex, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
            self.tab.currentChanged.connect(self.groupTabs.setCurrentIndex, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
            try:
                self.groupTabs.setStyleSheet("QTabBar::tab { font-size:10pt; padding:2px 8px; }")
            except Exception:
                pass
        except Exception:
            pass
        under.addStretch(1)

        # --- v11 UI: AutoPause (⏸) / BP (⦿) / Info ---
        self.btnAutoPause = QtWidgets.QToolButton(self); self.btnAutoPause.setToolTip("자동멈춤")
        self.btnAutoPause.setCheckable(True)
        # 자동멈춤 버튼: 체크 상태일 때만 빨간 테두리 표시
        try:
            self.btnAutoPause.setStyleSheet("QToolButton:checked { border:2px solid red; border-radius:4px; }")
        except Exception:
            pass
        self.autoPauseCombo = QtWidgets.QComboBox(self); self.autoPauseCombo.setToolTip("자동멈춤 간격(분)")
        for _m in range(1,61): self.autoPauseCombo.addItem(f"{_m}분", _m)
        try: self.autoPauseCombo.setFixedWidth(self.S(78))
        except Exception: self.autoPauseCombo.setFixedWidth(78)
        self.btnBreakSet = QtWidgets.QToolButton(self); self.btnBreakSet.setToolTip("브레이크포인트")
        self.btnBreakSet.setCheckable(True)
        try:
            self.btnBreakSet.setStyleSheet("QToolButton:checked { border:2px solid #46a060; border-radius:4px; }")
        except Exception:
            pass
        self.lbBreakInfo = None
        # connect toggles and breakpoint click (wired later after helper definitions)
# icons: red clock (pause), green flag (BP)
        try:
            pm = QtGui.QPixmap(22,22); pm.fill(QtCore.Qt.GlobalColor.transparent)
            p = QtGui.QPainter(pm); p.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing, True)
            pen = QtGui.QPen(QtGui.QColor(200,50,50)); pen.setWidth(2); p.setPen(pen)
            p.drawEllipse(3,3,16,16); p.drawLine(11,11,11,5); p.drawLine(11,11,17,11); p.end()
            self.btnAutoPause.setIcon(QtGui.QIcon(pm)); self.btnAutoPause.setIconSize(QtCore.QSize(18,18))
        except Exception: pass
        try:
            pm = QtGui.QPixmap(22,22); pm.fill(QtCore.Qt.GlobalColor.transparent)
            p = QtGui.QPainter(pm); p.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing, True)
            pen = QtGui.QPen(QtGui.QColor(60,140,60)); pen.setWidth(2); p.setPen(pen)
            p.drawLine(4, 3, 4, 19); path = QtGui.QPainterPath(); path.moveTo(4,4); path.lineTo(18,6); path.lineTo(4,10); path.closeSubpath()
            p.fillPath(path, QtGui.QBrush(QtGui.QColor(140,200,120))); p.drawPath(path); p.end()
            self.btnBreakSet.setIcon(QtGui.QIcon(pm)); self.btnBreakSet.setIconSize(QtCore.QSize(18,18))
        except Exception: pass
        try:
            for b in (self.btnAutoPause, self.btnBreakSet): b.setFixedSize(30,28)
        except Exception: pass

        # ensure autoNextBtn exists before placing in 'under' row
        if not hasattr(self, 'autoNextBtn'):
            self.autoNextBtn = QtWidgets.QPushButton()
            self.autoNextBtn.setCheckable(True)
            try:
                self.autoNextBtn.setIcon(self.make_autonext_icon(20, False))
                self.autoNextBtn.setIconSize(QtCore.QSize(18,18))
                self.autoNextBtn.setFixedSize(30,28)
            except Exception:
                pass
            self.autoNextBtn.setToolTip('자동넘김: 동영상 종료 시 다음 파일 자동 재생')

            try:
                self.autoNextBtn.setStyleSheet("QPushButton { border:none; } QPushButton:checked { border:2px solid #2b7cff; border-radius:4px; }")
            except Exception:
                pass
            under.addWidget(self.autoNextBtn); under.addSpacing(6);  under.addWidget(self.btnAutoPause); under.addWidget(self.autoPauseCombo)
        under.addSpacing(6);  under.addWidget(self.btnBreakSet)
#         under.addSpacing(10); under.addWidget(self.lbBreakInfo)
        # wiring for toggle behavior
        try:
            self.autoNextBtn.toggled.disconnect()
        except Exception:
            pass
        try:
            self.chkAutonext.toggled.disconnect()
        except Exception:
            pass
        self.autoNextBtn.toggled.connect(_sync_from_btn, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.chkAutonext.toggled.connect(_sync_from_chk, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        # initial sync once
        _sync_from_chk(self.chkAutonext.isChecked())
    
        # v11 signals/hooks
        def _on_auto_pause_toggled(on: bool):
            self.auto_pause_enabled = bool(on)
            if on:
                mins = int(self.autoPauseCombo.currentData() or 1)
                self.auto_pause_interval_ms = max(1, mins) * 60 * 1000
            else:
                # 자동멈춤 비활성화: 타이머/잔여시간/스케줄 초기화
                self.auto_pause_interval_ms = 0
                self._carry_remain_ms = 0
                self._carry_sched_file = None
            # 버튼의 체크 상태에 따른 테두리 표시/제거는
            # QToolButton:checked 스타일시트에서 자동 처리된다.
            self._recalc_carry_on_origin()
            self._update_markers_for_current_file()
            self._update_break_info()

        def _on_auto_pause_interval_changed(_=None):
            if self.btnAutoPause.isChecked():
                mins = int(self.autoPauseCombo.currentData() or 1)
                self.auto_pause_interval_ms = max(1, mins) * 60 * 1000
                self._recalc_carry_on_origin()
            self._update_markers_for_current_file(); self._update_break_info()

        def _on_break_set():
            """브레이크포인트 버튼 클릭 시 동작
            - ON: 실제 브레이크 위치는 '다음 Space(재생/일시정지)'가 눌린 시점에서 확정
            - OFF: 모든 브레이크/자동멈춤 상태 초기화
            """
            try:
                checked = bool(self.btnBreakSet.isChecked())
            except Exception:
                checked = False

            if not checked:
                # 토글 OFF → 상태 초기화
                self.break_start_ms = None
                self.break_origin_index = None
                self._origin_closed = False
                self._awaiting_resume = False
                self._carry_remain_ms = 0
                self._carry_sched_file = None
                try:
                    self._update_markers_for_current_file()
                    self._update_break_info()
                except Exception:
                    pass
                return

            # 토글 ON → '다음 Space'에서 실제 시작 위치를 잡도록 팔만 들고 있는 상태
            self.break_start_ms = None
            self.break_origin_index = None
            self._origin_closed = False
            self._awaiting_resume = False
            try:
                self._auto_pause_prev_elapsed = 0
            except Exception:
                pass
            # N분 전체를 남은 시간으로 초기화 (실제 시작 위치는 추후 Space에서 확정)
            try:
                self._carry_remain_ms = int(getattr(self, "auto_pause_interval_ms", 0) or 0)
            except Exception:
                self._carry_remain_ms = 0
            self._carry_sched_file = None
            try:
                self._update_markers_for_current_file()
                self._update_break_info()
            except Exception:
                pass

        self.btnAutoPause.toggled.connect(_on_auto_pause_toggled)
        self.autoPauseCombo.currentIndexChanged.connect(_on_auto_pause_interval_changed)
        self.btnBreakSet.clicked.connect(self.on_click_breakpoint)

        # periodic tick
        try:
            if not hasattr(self, "_auto_pause_tick"):
                self._auto_pause_tick = QtCore.QTimer(self); self._auto_pause_tick.setInterval(200)
                self._auto_pause_tick.timeout.connect(lambda: (self._recalc_carry_on_origin(), self._update_markers_for_current_file(), self._carry_supervisor_tick()))
                self._auto_pause_tick.start()
        except Exception: pass

        # video hooks
        try:
            self.video.timeChanged.connect(lambda _ms: (self._recalc_carry_on_origin(), self._update_markers_for_current_file()))
        except Exception: pass

        # at media end: compute initial carry (origin) then apply across files
        def _media_end_carry_handler_v11():
            if not (self.auto_pause_enabled and self.auto_pause_interval_ms): return
            cur_idx = self.current_file_index(); L = self._len_ms()
            if self.break_origin_index is not None and cur_idx == self.break_origin_index and self.break_start_ms is not None:
                self._origin_closed = True
                start = int(self.break_start_ms or 0)
                self._carry_remain_ms = max(0, int(self.auto_pause_interval_ms) - max(0, L - start))
            rem = int(self._carry_remain_ms or 0)
            if rem <= 0:
                return
            # On every file end AFTER origin, deduct the file length from the remaining carry,
            # but only if we haven't already done so (origin handled separately at start above).
            if self.break_origin_index is not None and cur_idx > self.break_origin_index:
                L_end = self._len_ms()
                if L_end > 0:
                    self._carry_remain_ms = max(0, rem - L_end)
        try:
            self.video.mediaEnded.connect(_media_end_carry_handler_v11)
        except Exception: pass


# Player bar
        ctr=QtWidgets.QHBoxLayout()
        style=self.style()
        self.playBtn=QtWidgets.QPushButton(); self.playBtn.setIcon(self.make_play_icon(28))
        self.stopBtn=QtWidgets.QPushButton(); self.stopBtn.setIcon(self.make_stop_icon(24))
        self.prevBtn=QtWidgets.QPushButton(); self.prevBtn.setIcon(self.make_prev_icon(26))
        self.nextBtn=QtWidgets.QPushButton(); self.nextBtn.setIcon(self.make_next_icon(26))
        # AutoNext toggle icon button
        self.autoNextBtn = QtWidgets.QPushButton()
        self.autoNextBtn.setCheckable(True)
        self.autoNextBtn.setIcon(self.make_autonext_icon(20, False))
        self.autoNextBtn.setIconSize(QtCore.QSize(18,18))
        self.autoNextBtn.setFixedSize(30,28)
        self.autoNextBtn.setToolTip("다음영상 자동넘김: 재생 종료 시 다음 파일 자동 재생 (토글)")
    
        self.playBtn.setIconSize(QtCore.QSize(18,18)); self.stopBtn.setIconSize(QtCore.QSize(14,14));
        self.prevBtn.setIconSize(QtCore.QSize(16,16)); self.nextBtn.setIconSize(QtCore.QSize(16,16));
        for b in (self.playBtn,self.stopBtn,self.prevBtn,self.nextBtn):
            b.setFlat(False)
            b.setStyleSheet(
                "QPushButton{background:#ffffff; border:1px solid #d0d7e2; border-radius:10px; padding:4px 8px;}"
                "QPushButton:hover{background:#f2f4f8;}"
                "QPushButton:pressed{background:#e6ecf5;}"
                "QPushButton:focus{outline:0; border:1px solid #9bb7ff;}"
            )
            try:
                b.setFixedWidth(self.S(36))
                b.setFixedHeight(self.S(24))
                bf=b.font(); bf.setPointSize(self.F(8)); b.setFont(bf)
            except Exception:
                pass
        self.btn4x=QtWidgets.QPushButton("4x"); self.btn4x.setToolTip("배속 4.0");
        self.btn4x.setFixedHeight(24)
        self.btn4x.setFixedWidth(42)
        f4 = self.btn4x.font(); f4.setPointSize(self.F(8)); self.btn4x.setFont(f4)
        for w in (self.playBtn,self.stopBtn,self.prevBtn,self.nextBtn,self.btn4x): ctr.addWidget(w)
        ctr.addSpacing(12)
        self.nowFileLbl = QtWidgets.QLabel("파일: -")
        self.nowFileLbl.setSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Preferred)
        ctr.addWidget(self.nowFileLbl, 1)

        ctr.addStretch(1)
        left.addLayout(ctr)
        left.addLayout(under)
                # --- Compact control buttons width ---
        try:
            for b in (self.playBtn, self.stopBtn, self.prevBtn, self.nextBtn):
                b.setFixedWidth(42)
        except Exception:
            pass

        self.playBtn.clicked.connect(self.play_pause); self.stopBtn.clicked.connect(self.video.stop)
        self.prevBtn.clicked.connect(self.play_prev_file); self.nextBtn.clicked.connect(self.play_next_file); self.btn4x.clicked.connect(lambda: self.set_rate(4.0))
        # Right action stack wiring (guarded)
        (self.btnVeh.clicked.connect(self.open_vehicle_types) if hasattr(self, "btnVeh") and hasattr(self, "open_vehicle_types") else None)
        (self.btnDir.clicked.connect(self.open_direction_settings) if hasattr(self, "btnDir") and hasattr(self, "open_direction_settings") else None)
        (self.btnHot.clicked.connect(self.open_hotkey_settings) if hasattr(self, "btnHot") else None)


        # Tabs & right list
        self.tab = self._HeaderlessTabWidget()
        left.addWidget(self.tab)
        try:
            # tabs: ensure readable text and avoid clipping
            self.tab.setStyleSheet(self.tab.styleSheet() + " QTabBar::tab { font-size:8pt; padding:1px 6px; min-height:16px; }   QTabWidget::pane { top: -1px; } ")
            self.tab.setStyleSheet(self.tab.styleSheet() + """\n  QTabBar::tab { padding:0px 6px; margin:0 2px; }\n  QTabWidget::pane { top:-1px; }\n""")
            try:
                self.groupTabs.setStyleSheet("QTabBar::tab { padding:0px 6px; margin:0 2px; }")
            except Exception:
                pass
            try:
                self.groupTabs.setStyleSheet("QTabBar::tab { font-size:8pt; padding:1px 6px; }")
            except Exception:
                pass  # lift pane to avoid covering the bar
            if self.tab.tabBar():
                self.tab.tabBar().setFixedHeight(self.S(16))
                self.tab.tabBar().raise_()
        except Exception:
            pass
        self.panel_btns={}; self.panel_lbls={}; self.shortcut_lbls={}
        # 탭별 활성 방향 인덱스 매핑 초기화
        self.group_tab_mapping = []
        groups=[(i,i+1,i+2,f"{i+1}-{i+2}-{i+3}") for i in range(0,30,3)]
        for a,b,c,t in groups:
            # create tab only if any enabled direction in this group
            enabled_in_group = [d for d in (a,b,c) if d in self.get_enabled_indices() and d < len(self.cfg.directions)]
            if not enabled_in_group:
                continue
            page = self._make_group_page(a, b, c)
            lbl = " - ".join(str(i+1) for i in enabled_in_group)
            self.tab.addTab(page, lbl)
            # 이 탭에서 사용할 실제 방향 인덱스 목록 저장
            self.group_tab_mapping.append(list(enabled_in_group))

        self._sync_group_tabs()

        right=QtWidgets.QVBoxLayout()

        # (다크 모드 버튼은 메뉴바 우측 상단 코너에 배치합니다.)

        # 폴더 열기 / 정렬 콤보는 우측 패널 상단에 배치
        bar = QtWidgets.QHBoxLayout()
        self.openFolderBtn = QtWidgets.QPushButton("폴더 (F2)")
        self.sortCombo = QtWidgets.QComboBox()
        self.sortCombo.addItems(["이름 오름차순 (A→Z)", "이름 내림차순 (Z→A)"])
        bar.addWidget(self.openFolderBtn)
        bar.addWidget(self.sortCombo)
        right.addLayout(bar)

        # 폴더 목록 리스트
        self.fileList = QtWidgets.QListWidget()
        self.fileList.setItemDelegate(TightListDelegate(self.fileList, row_height=20))
        self.fileList.setMinimumWidth(70)
        right.addWidget(self.fileList, stretch=1)

        self.fileList.setUniformItemSizes(True)
        self.fileList.setSpacing(self.S(0.5))

        # 항목 높이/패딩/폰트 크기만 지정하고, 글자 색상은 전역 테마에 따르도록 둔다.
        base_style = self.fileList.styleSheet() or ""
        base_style += f" QListWidget::item{{ min-height:{self.S(5)}px; padding:{self.S(0.5)}px {self.S(1.5)}px; }}"
        base_style += f" QListWidget{{ font-size:{self.F(9)}pt; padding-top:0px; padding-bottom:0px; }}"
        self.fileList.setStyleSheet(base_style)

        group=QtWidgets.QGroupBox("작업/설정"); gl=QtWidgets.QVBoxLayout(group)
        self.btnExcel=QtWidgets.QPushButton("저장(진행내역)"); gl.addWidget(self.btnExcel)
        self.btnSheet=QtWidgets.QPushButton("시트보기"); gl.addWidget(self.btnSheet)
        self.btnReset=QtWidgets.QPushButton("초기화 (활성 방향)"); gl.addWidget(self.btnReset)
        gl.addStretch(1)
        right.addWidget(group)

        # splitter inserted here# -- QSplitter between video(left) and file list(right) --
        leftW = QtWidgets.QWidget(); leftW.setLayout(left)
        rightW = QtWidgets.QWidget(); rightW.setLayout(right)
        self.rightW = rightW
        self.leftW = leftW
        self.rightW.installEventFilter(self)
        self.splitter = QtWidgets.QSplitter(QtCore.Qt.Orientation.Horizontal)
        self.splitter.addWidget(leftW); self.splitter.addWidget(rightW)
        self.splitter.setCollapsible(0, False)
        self.splitter.setCollapsible(1, True)
        self.splitter.setStretchFactor(0, 5)
        self.splitter.setStretchFactor(1, 1)
        # initial sizes roughly 5:1
        self.splitter.setSizes([1750, 300])
        root.addWidget(self.splitter, 1)
        # remember initial sizes and apply constraints after show
        try:
            _sz = self.splitter.sizes()
            self._left_min = max(200, _sz[0])  # lock video(min-left) at current
            self._right_fixed = max(160, _sz[1])  # lock folder pane width at current
            self._right_last = self._right_fixed
            # Apply widget-level guards
            try:
                self.leftW.setMinimumWidth(self._left_min)
                self.rightW.setMaximumWidth(self._right_fixed)
            except Exception:
                pass
        except Exception:
            self._left_min = 600; self._right_last = 240
        QtCore.QTimer.singleShot(0, lambda: getattr(self, '_apply_initial_constraints', lambda: None)())
        # auto-hide right pane if dragged thin
        self.splitter.splitterMoved.connect(self.on_splitter_moved)
        QtCore.QTimer.singleShot(0, lambda: getattr(self, '_enforce_splitter_constraints', lambda: None)())
        # (메뉴바 제거: 파일/도움말/관리/설정은 상단 바 버튼으로 대체)
        try:
            self.menuBar().hide()
        except Exception:
            pass

        self.openFolderBtn.clicked.connect(self.choose_folder); self.sortCombo.currentIndexChanged.connect(self.refresh_file_list); self.fileList.itemDoubleClicked.connect(self.play_selected_item)
        self._seeking = False
        def _on_video_position(p: float):
            if not self._seeking:
                try:
                    self.slider.setValue(int(p * 1000))
                except Exception:
                    pass
        self.video.positionChanged.connect(_on_video_position)

        def _apply_slider(val: int):
            pos = max(0.0, min(1.0, val / 1000.0))
            try:
                self.video.set_position(pos)
            except Exception:
                pass
        def _on_slider_pressed():
            self._seeking = True
        def _on_slider_moved(v: int):
            _apply_slider(v)
        def _on_slider_released():
            self._seeking = False
            _apply_slider(self.slider.value())

        self.slider.sliderPressed.connect(_on_slider_pressed)
        self.slider.sliderMoved.connect(_on_slider_moved)
        self.slider.sliderReleased.connect(_on_slider_released)
        self.slider.clickedTo.connect(_apply_slider)
        self.tick=QtCore.QTimer(self); self.tick.setInterval(500); self.tick.timeout.connect(self.on_tick); self.tick.start(); self.autosave_timer=0.0

        self.hkdb = load_hotkeys_db()
        self.hot_shortcuts: List[QtGui.QShortcut] = []
        try:
            self.apply_env_defaults_if_available()
        except Exception:
            pass
        self.install_hotkeys()
        self.active_dir_index = self.first_enabled()
        self.update_time_labels(0,0); self.rateLbl.setText(getattr(self,'rateLbl').text() if hasattr(self,'rateLbl') else '배속: 1.00x'); self.refresh_all_quick_counts(); self.update_active_highlight()
        # 상태 복원은 초기 실행 시 한 번만 수행 (load_last_state_on_start에서 처리)
        # wire right actions exactly once (UniqueConnection to prevent duplicates)
        try:
            self.btnSheet.clicked.disconnect()
        except Exception:
            pass
        try:
            self.btnExcel.clicked.disconnect()
        except Exception:
            pass
        try:
            self.btnReset.clicked.disconnect()
        except Exception:
            pass
        self.btnExcel.clicked.connect(self.save_progress, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.btnSheet.clicked.connect(self.open_sheet, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.btnReset.clicked.connect(self.clear_current_counts, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        # Right actions wiring (final)
        self.apply_fluent_dark()
        # v9.2 right actions

    # panels
    def build_dir_panel(self, didx:int)->QtWidgets.QGroupBox:
        if didx in (9,10,11):
            dlog(f"build_dir_panel didx={didx+1} title={self.cfg.directions[didx]} hotkeys={self.cfg.dir_hotkeys[didx]}")
        title=self.cfg.directions[didx]
        gb=QtWidgets.QGroupBox(title); gb.setProperty("dirIndex", didx)
        v=QtWidgets.QVBoxLayout(gb); grid=QtWidgets.QGridLayout(); v.addLayout(grid)
        # 그룹박스 제목과 내용 사이 여백/간격 축소
        v.setContentsMargins(4, 4, 4, 4)
        v.setSpacing(2)

        self.panel_btns[didx]=[]; self.panel_lbls[didx]=[]; self.shortcut_lbls[didx]=[]
        vc = self.cfg.vehicle_count()
        for i,veh in enumerate(self.cfg.vehicle_types[:vc]):
            nameLbl=QtWidgets.QLabel(veh); nameLbl.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter); nameLbl.setMinimumHeight(18)
            cntLbl=QtWidgets.QLabel("0"); cntLbl.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter); cntLbl.setMinimumHeight(18); cntLbl.setStyleSheet("font-weight:600;")
            keyLbl=QtWidgets.QLabel(self.cfg.dir_hotkeys[didx][i]); keyLbl.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter); keyLbl.setMinimumHeight(18); keyLbl.setStyleSheet("color:#111; background:#eef2f8; border:1px solid #cfd4dc; border-radius:6px; padding:2px 6px; font-weight:600;")
            btn=QtWidgets.QToolButton(); btn.setText(veh); btn.setToolButtonStyle(QtCore.Qt.ToolButtonStyle.ToolButtonTextOnly)


            # === 70% scale & count emphasis ===

            sc = getattr(self, "panel_scale", 0.70)

            _base_lbl_h = 18

            _base_btn_h = 28

            _base_font_pt = 10

            _base_cnt_pt  = 11


            lbl_h = max(10, int(_base_lbl_h * sc))

            btn_h = max(16, int(_base_btn_h * sc))

            pt    = max(7,  int(round(_base_font_pt * sc)))

            cntpt = max(pt, int(round(_base_cnt_pt  * sc * 1.15)))  # emphasize count label


            # fonts

            _f_base = nameLbl.font(); _f_base.setPointSize(pt)

            _f_cnt  = QtGui.QFont(_f_base); _f_cnt.setPointSize(cntpt); _f_cnt.setBold(True)


            nameLbl.setMinimumHeight(lbl_h); nameLbl.setFont(_f_base)

            cntLbl.setMinimumHeight(lbl_h);  cntLbl.setFont(_f_cnt)

            cntLbl.setStyleSheet(

                "font-weight:800; color:#111; background:#fff7cc;"

                "border:1px solid #e6c558; border-radius:6px; padding:1px 4px;"

            )

            keyLbl.setMinimumHeight(lbl_h);  keyLbl.setFont(_f_base)

            _pad_x =  max(2, int(6 * sc)); _pad_y =  max(1, int(2 * sc))

            keyLbl.setStyleSheet(

                f"color:#111; background:#eef2f8; border:1px solid #cfd4dc;"

                f"border-radius:6px; padding:{_pad_y}px {_pad_x}px; font-weight:600;"

            )

            btn.setFixedHeight(btn_h)

            _bf = btn.font(); _bf.setPointSize(pt); btn.setFont(_bf)
            btn.clicked.connect(lambda _,ii=i,dd=didx: self.quick_add(dd, ii))
            frame=QtWidgets.QFrame(); fl=QtWidgets.QVBoxLayout(frame); fl.setContentsMargins(2,2,2,2); fl.setSpacing(2)
            _pad_i = max(1, int(2 * getattr(self, 'panel_scale', 0.70)))
            fl.setContentsMargins(_pad_i, _pad_i, _pad_i, _pad_i)
            fl.setSpacing(_pad_i)
            fl.addWidget(nameLbl); fl.addWidget(cntLbl); fl.addWidget(keyLbl)
            grid.addWidget(frame, 0, i, 1, 1)
            self.panel_btns[didx].append(btn); self.panel_lbls[didx].append(cntLbl); self.shortcut_lbls[didx].append(keyLbl)
        gb.mousePressEvent = lambda e, dd=didx: self.set_active_dir(dd) or QtWidgets.QGroupBox.mousePressEvent(gb, e)
        return gb

    def update_active_highlight(self):
        for didx in range(12):
            w = next((g for g in self.findChildren(QtWidgets.QGroupBox) if g.property("dirIndex")==didx), None)
            if not w: continue
            if didx==self.active_dir_index:
                w.setStyleSheet("QGroupBox{border:2px solid #2b7cff; padding-top:16px; font-weight:600;}")
            else:
                w.setStyleSheet("QGroupBox{border:1px solid #666; padding-top:16px;}")

    def refresh_quick_counts_for(self, didx:int):
        if didx not in self.panel_lbls:
            return
        idx=self.interval_index(); label=self.current_label(); d=self.cfg.directions[didx]
        self.counts.ensure_interval(idx,label)
        vc = self.cfg.vehicle_count()
        for i,veh in enumerate(self.cfg.vehicle_types[:vc]):
            n=self.counts.table[idx].get((d,veh),0)
            if i < len(self.panel_lbls[didx]):
                self.panel_lbls[didx][i].setText(str(n))

    def refresh_all_quick_counts(self):
        for didx in self.get_enabled_indices():
            if didx in self.panel_lbls: self.refresh_quick_counts_for(didx)

    def quick_add(self, didx:int, veh_index:int, delta:int=+1):
        d=self.cfg.directions[didx]; v=self.cfg.vehicle_types[veh_index]
        idx=self.interval_index(); label=self.current_label()
        self.counts.inc(idx,label,d,v,delta); log_event(self.user["id"], self.current_file or "", self.video.get_time_ms(), idx, d, v, delta)
        self.refresh_quick_counts_for(didx)

    # clear / sheet / windows
    def clear_current_counts(self):
        # 리셋: 현재 선택된 방향(활성 방향)만 초기화 — 현재 시간대 한정
        idx = self.interval_index(); label = self.current_label()
        self.counts.ensure_interval(idx, label)
        d = self.cfg.directions[self.active_dir_index]
        for v in self.cfg.vehicle_types[:6]:
            self.counts.table[idx][(d, v)] = 0
        self.counts.changed.emit()
        self.refresh_quick_counts_for(self.active_dir_index)

    def open_sheet(self):
        try:
            self.sheet_dlg.close()
        except Exception:
            pass
        self.sheet_dlg = SheetDialog(self, counts=self.counts, cfg=self.cfg)
        try:
            self.counts.changed.disconnect(self.sheet_dlg.refresh)
        except Exception:
            pass
        self.counts.changed.connect(self.sheet_dlg.refresh, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.sheet_dlg.exec()

    def open_window_dialog(self):
        dlg=CountWindowDialog(self, cfg=self.cfg)
        if dlg.exec()==QtWidgets.QDialog.DialogCode.Accepted:
            cur=self.current_slot_start
            self.rebuild_slot_combo(select_start=cur)

    # admin/options
    def set_vehicle_count_like(self, count:int):
        try:
            self.cfg.set_vehicle_count(count)
        except Exception:
            if hasattr(self.cfg, 'vehicle_types'):
                self.cfg.vehicle_types = self.cfg.vehicle_types[:count]
        # site별 단축키가 활성화되어 있으면 기본(숫자/Q/A) 덮어쓰기를 하지 않음

        if not getattr(self, '_site_hotkeys_active', False):

            self.assign_vehicle_hotkeys_default(count)

    def open_vehicle_types(self):
        _orig_open=True  # marker
        old_names = list(self.cfg.vehicle_types)
        old_counts = self.counts
        dlg = VehicleTypeSettingsDialog(self, cfg=self.cfg)
        if dlg.exec()==QtWidgets.QDialog.DialogCode.Accepted:
            # migrate counts by vehicle name where possible
            new_counts = CountTable(self.cfg.directions, self.cfg.vehicle_types)
            # copy overlapping slots
            for idx, counts in old_counts.table.items():
                label = old_counts.labels.get(idx, "")
                new_counts.ensure_interval(idx, label)
                for (d, v), c in counts.items():
                    if v in self.cfg.vehicle_types and d in self.cfg.directions:
                        new_counts.table[idx][(d, v)] = c
            self.counts = new_counts
            # normalize hotkeys length per direction
            vc = self.cfg.vehicle_count()
            for i in range(len(self.cfg.dir_hotkeys)):
                row = self.cfg.dir_hotkeys[i] if i < len(self.cfg.dir_hotkeys) else []
                row = (row + [""]*vc)[:vc]
                self.cfg.dir_hotkeys[i] = row
            # rebuild panels
            self.rebuild_panels_after_change()
        
    def rebuild_panels_after_change(self):
        # Remove and rebuild tab widget safely
        self.tab.setParent(None)
        self.panel_btns = {}
        self.panel_lbls = {}
        self.shortcut_lbls = {}
        self.tab = self._HeaderlessTabWidget()
        groups=[(i,i+1,i+2,f"{i+1}-{i+2}-{i+3}") for i in range(0,30,3)]
        for a,b,c,t in groups:
            enabled_in_group = [d for d in (a,b,c) if d in self.get_enabled_indices() and d < len(self.cfg.directions)]
            if not enabled_in_group:
                continue
            page = self._make_group_page(a, b, c)
            lbl = " - ".join(str(i+1) for i in enabled_in_group)
            self.tab.addTab(page, lbl)
        # insert back
        self.left_layout.addWidget(self.tab)
        self._sync_group_tabs()
        self.active_dir_index = self.first_enabled()
        self.refresh_all_quick_counts(); self.update_active_highlight()
        # 상태 복원은 초기 실행 시 한 번만 수행 (load_last_state_on_start에서 처리)
        # wire right actions exactly once (UniqueConnection to prevent duplicates)
        try:
            self.btnSheet.clicked.disconnect()
        except Exception:
            pass
        try:
            self.btnExcel.clicked.disconnect()
        except Exception:
            pass
        try:
            self.btnReset.clicked.disconnect()
        except Exception:
            pass
        self.btnExcel.clicked.connect(self.save_progress, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.btnSheet.clicked.connect(self.open_sheet, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.btnReset.clicked.connect(self.clear_current_counts, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.apply_fluent_dark()
        # v9.2 right actions

    
    def open_hotkey_settings(self):
        # Hotkey settings for "입력그룹 단축키" (site-level)
        # This dialog uses Apply buttons (not OK). So we persist immediately when Apply is pressed.
        def _on_changed():
            try:
                self._persist_current_site_hotkeys_step1()
            except Exception as e:
                print("[WARN] persist_site_hotkeys failed:", e)
            try:
                self.install_hotkeys(reinstall=True)
            except Exception:
                pass

        try:
            setattr(self.cfg, "on_hotkeys_changed", _on_changed)
        except Exception:
            pass

        dlg = HotkeySettingsDialog(self, cfg=self.cfg)
        dlg.exec()

        # After closing, re-install (in case user applied but callback failed)
        try:
            self.install_hotkeys(reinstall=True)
        except Exception:
            pass

    def _persist_current_site_hotkeys_step1(self):
        """[v53-step1] Persist current cfg.dir_hotkeys for the currently selected site.
        Writes to:
          - site_{workno}.json (under Survey/Sites/**)
          - env_data_plus_allinone.json (best_env_db_path())
        This is the 'STEP 1: SAVE' part of the hotkeys pipeline.
        """
        try:
            survey = getattr(self, "_env_selected_survey", None)
            site = getattr(self, "_env_selected_site", None)
            if not isinstance(site, dict):
                return

            # Extract identifiers
            workno = str(site.get("작업번호") or site.get("work_no") or site.get("id") or site.get("workno") or "").strip()
            if not workno:
                # fallback using jibun + name
                jibun = str(site.get("지번") or site.get("jibun") or "").strip()
                sname = str(site.get("지점명") or site.get("name") or "").strip()
                workno = f"{jibun}_{sname}".strip("_") or "site"

            import re as _re
            workno_safe = _re.sub(r'[^0-9A-Za-z가-힣_\-]+', "_", workno)

            info = {}
            try:
                info = (survey.get("info") or {}) if isinstance(survey, dict) else {}
            except Exception:
                info = {}
            survey_name = str(info.get("name") or (survey.get("project") if isinstance(survey, dict) else "") or (survey.get("name") if isinstance(survey, dict) else "") or "SURVEY").strip()
            sn_safe = _re.sub(r'[^0-9A-Za-z가-힣_\-]+', "_", survey_name) or "SURVEY"

            # Build payload from cfg
            payload = build_site_hotkeys_from_cfg(self.cfg, site_obj=site) or {}
            by_dir = payload.get("by_dir") or {}
            veh_names = payload.get("vehicle_names") or []

            # Locate Survey root
            try:
                env_path = best_env_db_path()
                survey_root = os.path.dirname(env_path) if env_path else ""
            except Exception:
                env_path = None
                survey_root = ""

            # Try to load existing site json
            site_json, site_path = _mw_load_site_json_v26(survey_root, workno_safe)

            # If not found, create path under Survey/Sites/<survey_name_safe>/
            if not site_path:
                try:
                    sites_root = os.path.join(survey_root, "Sites")
                    os.makedirs(sites_root, exist_ok=True)
                    survey_dir = os.path.join(sites_root, sn_safe)
                    os.makedirs(survey_dir, exist_ok=True)
                    site_path = os.path.join(survey_dir, f"site_{workno_safe}.json")
                    site_json = {"survey_info": info, "site": site}
                except Exception:
                    site_path = None

            # Write into site json
            if isinstance(site_json, dict) and site_path:
                try:
                    site_json["site_hotkeys"] = by_dir
                    site_json["site_hotkeys_vehicle_names"] = veh_names
                    # also keep a simple alias for clarity
                    site_json["dir_hotkeys"] = by_dir
                    with open(site_path, "w", encoding="utf-8") as f:
                        json.dump(site_json, f, ensure_ascii=False, indent=2)
                    print(f"[HOTKEY-SAVE] site json updated: {site_path}")
                except Exception as e:
                    print("[HOTKEY-SAVE] site json update failed:", e)

            # Update envdb on disk (best effort)
            try:
                _update_envdb_site_hotkeys_on_disk(info_obj=info, site_obj=site, hotkeys_payload=payload)
                print("[HOTKEY-SAVE] envdb updated (best effort)")
            except Exception as e:
                print("[HOTKEY-SAVE] envdb update failed:", e)

        except Exception as e:
            try:
                print("[HOTKEY-SAVE] unexpected error:", e)
            except Exception:
                pass

    def open_user_manager(self):
        if self.user.get('role')!='admin':
            QtWidgets.QMessageBox.information(self,"안내","관리자만 접근 가능합니다."); return
        dlg = UserManagerDialog(self); dlg.exec()

    def export_logs(self):
        if self.user.get('role')!='admin':
            QtWidgets.QMessageBox.information(self,"안내","관리자만 접근 가능합니다."); return
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"로그 CSV 내보내기","counter_logs.csv","CSV (*.csv)")
        if path: logs_export_csv(path); QtWidgets.QMessageBox.information(self,"완료", f"저장: {path}")

    # file/folder
    def choose_folder(self):
        path=QtWidgets.QFileDialog.getExistingDirectory(self,"동영상 폴더 선택","")
        if not path: return
        self.current_folder=Path(path); self.refresh_file_list(); self.update_header_from_folder()

    def refresh_file_list(self):
        """폴더 내 mp4 리스트를 불러오고, 각 파일 길이를 [mm:ss]로 표시"""
        self.fileList.clear()
        if not self.current_folder:
            return

        files = list(self.current_folder.glob("*.mp4"))
        files.sort(key=lambda p: p.name.lower(), reverse=self.sortCombo.currentIndex() == 1)

        self.video_lengths = []  # 영상 길이(초) 목록

        for p in files:
            # VLC로 길이 읽기 (ms 단위, 동기 파싱 시도)
            length_sec = 0.0
            try:
                inst = getattr(self.video, "instance", None)
                if inst is None:
                    inst = vlc.Instance()
                media = inst.media_new(str(p))
                try:
                    # 가능한 경우 동기 파싱을 먼저 시도
                    media.parse()
                except Exception:
                    # parse()가 지원되지 않으면 기존 방식으로 시도
                    try:
                        media.parse_with_options(1)
                    except Exception:
                        pass
                length_ms = 0
                try:
                    length_ms = media.get_duration()
                except Exception:
                    length_ms = 0
                if length_ms and length_ms > 0:
                    length_sec = max(0.0, length_ms / 1000.0)
            except Exception:
                length_sec = 0.0

            self.video_lengths.append(length_sec)
            total_sec = int(length_sec)
            hours = total_sec // 3600
            mins = (total_sec % 3600) // 60
            secs = total_sec % 60
            label = f"{p.name}"

            it = QtWidgets.QListWidgetItem(label)
            it.setData(QtCore.Qt.ItemDataRole.UserRole, str(p))
            self.fileList.addItem(it)

        # 현재 재생중인 파일 강조 (기존 로직 유지)
        try:
            self.highlight_current_file()
        except Exception:
            pass

    def play_selected_item(self, it:QtWidgets.QListWidgetItem):
        # ensure markers refresh for new file
        try:
            QtCore.QTimer.singleShot(150, self._update_markers_for_current_file)
        except Exception:
            pass
        path=it.data(QtCore.Qt.ItemDataRole.UserRole); self.set_media_and_play(path)

    def open_file(self):
        path,_=QtWidgets.QFileDialog.getOpenFileName(self,"동영상 선택","","Video Files (*.mp4 *.avi *.mkv *.mov);;All Files (*)")
        if path: self.set_media_and_play(path)

    def set_media_and_play(self, path: str):
        """미디어를 설정하고 재생을 시작하며, 현재 재생 파일 라벨/목록을 갱신"""
        # 현재 재생 파일 경로 저장
        self.current_file = path
        # 파일명에서 시작 시각(HHMMSS)을 추정하여 방식 C용 기준초로 저장
        try:
            self.current_file_start_sec = self._guess_start_sec_from_filename(path)
        except Exception:
            self.current_file_start_sec = None

        # VLC 미디어 설정 및 재생
        self.video.set_media(path)
        self.video.play()

        # 예약된 carry 일시정지 정보 초기화
        self._carry_sched_file = None

        # 길이 준비가 늦는 경우를 대비해 폴링하여 총길이/현재시간 라벨 갱신
        try:
            def _poll_length_try(count=0):
                L = self.video.length_ms()
                cur = self.video.get_time_ms() if hasattr(self.video, "get_time_ms") else 0
                if L and L > 0:
                    self.update_time_labels(cur, max(0, L - cur))
                else:
                    if count < 20:
                        QtCore.QTimer.singleShot(150, lambda: _poll_length_try(count + 1))
            _poll_length_try(0)
        except Exception:
            pass

        # 파일명 라벨 갱신
        try:
            from pathlib import Path as _P
            name = _P(path).name
        except Exception:
            name = path
        if hasattr(self, "nowFileLbl"):
            self.nowFileLbl.setText(f"파일: {name}")
            self.nowFileLbl.setToolTip(path)

        # 파일 목록에서 현재 재생 파일을 파란색으로 강조 + 자동 스크롤
        try:
            self.highlight_current_file()
        except Exception:
            pass



    def highlight_current_file(self):
        """현재 재생 중인 파일 행 전체를 파란 배경 + 흰 글자로 강조"""
        # current_file과 리스트 항목의 경로를 모두 절대경로/대소문자 무시 형태로 맞춰 비교
        cur_norm = None
        if self.current_file:
            try:
                cur_norm = os.path.normcase(os.path.abspath(str(self.current_file)))
            except Exception:
                cur_norm = str(self.current_file)

        for i in range(self.fileList.count()):
            it = self.fileList.item(i)
            raw = it.data(QtCore.Qt.ItemDataRole.UserRole)
            try:
                item_norm = os.path.normcase(os.path.abspath(str(raw)))
            except Exception:
                item_norm = str(raw)

            if cur_norm is not None and item_norm == cur_norm:
                # 현재 재생중인 파일: 전체 행을 파란 배경 + 흰 글씨로 강조
                it.setBackground(QtGui.QBrush(QtGui.QColor(30,144,255)))
                it.setForeground(QtGui.QBrush(QtGui.QColor(255,255,255)))
                it.setSelected(True)
                self.fileList.setCurrentItem(it)
                try:
                    # 현재 파일이 리스트 중앙쯤에 오도록 자동 스크롤
                    self.fileList.scrollToItem(it, QtWidgets.QAbstractItemView.ScrollHint.PositionAtCenter)
                except Exception:
                    pass
            else:
                # 나머지 파일은 기본 배경/글씨색
                it.setBackground(QtGui.QBrush(QtCore.Qt.GlobalColor.transparent))
                it.setForeground(QtGui.QBrush(QtGui.QColor(0,0,0)))

    def current_file_index(self)->int:
        if not self.current_file: return -1
        for i in range(self.fileList.count()):
            if self.fileList.item(i).data(QtCore.Qt.ItemDataRole.UserRole)==self.current_file: return i
        return -1

    def on_media_ended(self):
        try:
            if self.chkAutonext.isChecked():
                self._request_next_file()
        except Exception:
            pass
    def _request_next_file(self):
        # Prevents double-jumps that skip a file
        if self._carry_next_pending:
            return
        self._carry_next_pending = True
        try:
            self.play_next_file()
        except Exception:
            self._carry_next_pending = False
            return
        # Allow next transition after a short delay to settle length/position
        QtCore.QTimer.singleShot(250, lambda: setattr(self, "_carry_next_pending", False))

    def play_next_file(self):
        i=self.current_file_index(); 
        if i>=0 and i+1<self.fileList.count(): 
            self.play_selected_item(self.fileList.item(i+1))

    def play_prev_file(self):
        i=self.current_file_index(); 
        if i>0: 
            self.play_selected_item(self.fileList.item(i-1))

    # header
    def update_header_from_folder(self):
        if not self.current_folder: return
        site=self.current_folder.name; parent=self.current_folder.parent.name if self.current_folder.parent else ""
        task=re.sub(r'^\d{8}_','',parent); self.headerTask.setText(task or "-"); self.headerSite.setText(site or "-")

    def update_header_from_file(self, file_path:str):
        p=Path(file_path); self.current_folder=p.parent; self.update_header_from_folder()

    # slot/combo
    def rebuild_slot_combo(self, select_start:int=None):
        items=[]
        for s,e in sorted(self.cfg.active_windows):
            t=s
            while t<e:
                items.append(t); t += SLOT_SEC
        items=list(dict.fromkeys(items)) or [0]
        self.slotCombo.blockSignals(True); self.slotCombo.clear()
        for t in items: self.slotCombo.addItem(slot_label(t), t)
        self.slotCombo.blockSignals(False)
        if select_start is not None:
            idx = next((i for i in range(self.slotCombo.count()) if self.slotCombo.itemData(i)==select_start), -1)
            if idx>=0: self.slotCombo.setCurrentIndex(idx)
        self.current_slot_start = select_start if select_start is not None else items[0]

    def on_slot_combo_changed(self, idx:int):
        start = self.slotCombo.itemData(idx); 
        if start is None: return
        self.current_slot_start = start; self.refresh_all_quick_counts()

    def move_slot(self, step:int):
        i=self.slotCombo.currentIndex()+step
        if 0<=i<self.slotCombo.count(): self.slotCombo.setCurrentIndex(i)

    def interval_index(self)->int: return slot_index(self.current_slot_start)
    def current_label(self)->str: return slot_label(self.current_slot_start)

    # playback/hotkeys
    def volume_up(self, step:int=5):
        """Increase volume and sync slider/icon."""
        try:
            cur = self.video.mediaplayer.audio_get_volume()
        except Exception:
            cur = getattr(self, "_last_volume_before_mute", 100)
        new_vol = min(200, max(0, cur + step))
        try:
            self.video.audio_set_volume(new_vol)
        except Exception:
            pass
        # 내부 상태 및 슬라이더 반영
        self._is_muted = (new_vol == 0)
        self._last_volume_before_mute = new_vol or getattr(self, "_last_volume_before_mute", 100)
        if hasattr(self, "volSlider"):
            try:
                self.volSlider.blockSignals(True)
                self.volSlider.setValue(new_vol)
                self.volSlider.blockSignals(False)
            except Exception:
                pass
        try:
            self.update_volume_icon(new_vol)
        except Exception:
            pass

    def volume_down(self, step:int=5):
        """Decrease volume and sync slider/icon."""
        try:
            cur = self.video.mediaplayer.audio_get_volume()
        except Exception:
            cur = getattr(self, "_last_volume_before_mute", 100)
        new_vol = min(200, max(0, cur - step))
        try:
            self.video.audio_set_volume(new_vol)
        except Exception:
            pass
        self._is_muted = (new_vol == 0)
        self._last_volume_before_mute = new_vol or getattr(self, "_last_volume_before_mute", 100)
        if hasattr(self, "volSlider"):
            try:
                self.volSlider.blockSignals(True)
                self.volSlider.setValue(new_vol)
                self.volSlider.blockSignals(False)
            except Exception:
                pass
        try:
            self.update_volume_icon(new_vol)
        except Exception:
            pass

    def on_volume_changed(self, value:int):
        """슬라이더에서 직접 음량을 변경할 때 호출."""
        v = int(max(0, min(200, value)))
        try:
            self.video.audio_set_volume(v)
        except Exception:
            pass
        self._is_muted = (v == 0)
        if v > 0:
            self._last_volume_before_mute = v
        try:
            self.update_volume_icon(v)
        except Exception:
            pass

    def update_volume_icon(self, volume:int):
        """현재 볼륨/음소거 상태에 따라 아이콘 텍스트 변경."""
        icon_text = "🔊"
        v = int(max(0, min(200, volume)))
        if getattr(self, "_is_muted", False) or v == 0:
            icon_text = "🔇"
        elif v < 60:
            icon_text = "🔈"
        elif v < 140:
            icon_text = "🔉"
        else:
            icon_text = "🔊"
        if hasattr(self, "muteBtn") and self.muteBtn is not None:
            try:
                self.muteBtn.setText(icon_text)
            except Exception:
                pass

    def stop_play(self):
        self.video.stop()
        self.video.stop()

    def toggle_mute(self):
        """음소거 / 해제 토글 (슬라이더, 아이콘 포함)."""
        # 현재 볼륨 조회
        try:
            cur = self.video.mediaplayer.audio_get_volume()
        except Exception:
            cur = getattr(self, "_last_volume_before_mute", 100)

        is_muted = getattr(self, "_is_muted", False)

        if not is_muted:
            # 음소거: 현재 볼륨 저장 후 0으로
            if cur <= 0:
                cur = getattr(self, "_last_volume_before_mute", 100)
            self._last_volume_before_mute = cur
            new_vol = 0
            self._is_muted = True
        else:
            # 해제: 이전 볼륨 복원
            new_vol = getattr(self, "_last_volume_before_mute", 100)
            if new_vol <= 0:
                new_vol = 100
            self._is_muted = False

        try:
            self.video.audio_set_volume(new_vol)
        except Exception:
            pass

        if hasattr(self, "volSlider"):
            try:
                self.volSlider.blockSignals(True)
                self.volSlider.setValue(new_vol)
                self.volSlider.blockSignals(False)
            except Exception:
                pass
        try:
            self.update_volume_icon(new_vol)
        except Exception:
            pass

        try: self.video.toggle_mute()
        except Exception: pass

    def play_pause(self):
        """Space/재생 버튼 토글
        - 일반 토글
        - 브레이크포인트 버튼이 ON이고 아직 시작점이 없다면,
          Space가 눌린 시점을 빨간 마커(0분 기준)로 사용해 자동멈춤을 세팅한다.
        """
        # 1) 브레이크포인트 '대기' 상태라면 지금 위치를 시작점으로 고정
        try:
            def _maybe_arm_breakpoint():
                try:
                    # 자동멈춤이 켜져 있고, 간격이 설정되어 있어야 동작
                    if not getattr(self, "auto_pause_enabled", False):
                        return
                    if int(getattr(self, "auto_pause_interval_ms", 0) or 0) <= 0:
                        return
                    btn = getattr(self, "btnBreakSet", None)
                    if btn is None or not btn.isChecked():
                        return
                    # 이미 시작점이 정해져 있으면 그대로 사용
                    if self.break_start_ms is not None and self.break_origin_index is not None:
                        return
                    cur_idx = self.current_file_index()
                    if cur_idx < 0:
                        return
                    try:
                        cur_ms = int(self.video.get_time_ms())
                    except Exception:
                        cur_ms = 0
                    # 지금 시점을 브레이크 0분 기준으로 사용
                    self.break_origin_index = cur_idx
                    self.break_start_ms = max(0, cur_ms)
                    self._origin_closed = False
                    self._awaiting_resume = False
                    try:
                        self._auto_pause_prev_elapsed = 0
                    except Exception:
                        pass
                    # 남은 시간/캐리 초기화 후 재계산
                    try:
                        self._carry_remain_ms = int(getattr(self, "auto_pause_interval_ms", 0) or 0)
                    except Exception:
                        self._carry_remain_ms = 0
                    self._carry_sched_file = None
                    try:
                        self._recalc_carry_on_origin()
                    except Exception:
                        pass
                    try:
                        self._update_markers_for_current_file()
                        self._update_break_info()
                    except Exception:
                        pass
                except Exception:
                    pass

            _maybe_arm_breakpoint()
        except Exception:
            pass

        # 2) 실제 재생/일시정지 토글
        if self.video.is_playing():
            self.video.pause()
            try:
                self.playBtn.setIcon(self.make_play_icon(self.playBtn.iconSize().width()))
            except Exception:
                pass
        else:
            # 재생 시작
            self.video.play()
            # A-mode: 자동멈춤 이후 사용자가 수동으로 재생을 눌렀을 때
            # → 현재 위치를 새로운 브레이크 시작지점으로 간주하고
            #    다음 N분 자동멈춤 구간을 자동으로 설정 (파란 마커 포함)
            try:
                if getattr(self, "_awaiting_resume", False) and int(getattr(self, "auto_pause_interval_ms", 0)) > 0:
                    self._awaiting_resume = False
                    self.break_origin_index = self.current_file_index()
                    try:
                        self.break_start_ms = int(self.video.get_time_ms())
                    except Exception:
                        self.break_start_ms = 0
                    self._origin_closed = False
                    # 다음 자동멈춤을 위해 기능 다시 활성화
                    self.auto_pause_enabled = True
                    # 새 사이클이므로 누적 시간 상태 초기화
                    try:
                        self._auto_pause_prev_elapsed = 0
                    except Exception:
                        pass
                    # N분 간격 기억
                    self._carry_remain_ms = int(self.auto_pause_interval_ms)
                    self._carry_sched_file = None
                    # 마커/정보 갱신 (빨간/파란 마커 모두 새 위치 기준)
                    try:
                        self._update_markers_for_current_file()
                        self._update_break_info()
                    except Exception:
                        pass
            except Exception:
                pass
            try:
                self.playBtn.setIcon(self.make_pause_icon(self.playBtn.iconSize().width()))
            except Exception:
                pass
    def set_rate(self, rate:float):
        # 배속 적용 및 라벨 업데이트
        try:
            self.rateLbl.setText(f"배속: {rate:.2f}x")
        except Exception:
            pass
        rate=max(0.25, min(12.0, rate)); self.video.set_rate(rate); self.rateLbl.setText(f"배속: {rate:.2f}x")

    def set_active_dir(self, idx:int):
        if not (0<=idx<len(self.cfg.directions)): return
        if idx not in self.get_enabled_indices():
            # if disabled, jump to nearest enabled
            enabled = self.get_enabled_indices()
            if not enabled: return
            idx = min(enabled, key=lambda x: abs(x-idx))
        self.active_dir_index = idx
        self.update_active_highlight()
        # 상태 복원은 초기 실행 시 한 번만 수행 (load_last_state_on_start에서 처리)
        # wire right actions exactly once (UniqueConnection to prevent duplicates)
        try:
            self.btnSheet.clicked.disconnect()
        except Exception:
            pass
        try:
            self.btnExcel.clicked.disconnect()
        except Exception:
            pass
        try:
            self.btnReset.clicked.disconnect()
        except Exception:
            pass
        self.btnExcel.clicked.connect(self.save_progress, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.btnSheet.clicked.connect(self.open_sheet, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.btnReset.clicked.connect(self.clear_current_counts, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        self.apply_fluent_dark()
        # v9.2 right actions

    def move_active_within_group(self, delta:int):
        """Tab / Shift+Tab: 현재 탭 내에서 활성 방향 간 이동.

        - group_tab_mapping을 사용하여, 해당 탭에 속한 활성 방향 인덱스만 순환한다.
        - 매핑이 없으면 기존 3개 그룹 로직으로 폴백한다.
        """
        cur_tab = self.tab.currentIndex()
        max_dirs = min(30, len(self.cfg.directions))
        enabled = set(self.get_enabled_indices())

        mapping = getattr(self, "group_tab_mapping", None)
        group = []

        if isinstance(mapping, list) and 0 <= cur_tab < len(mapping):
            group = [d for d in mapping[cur_tab] if d in enabled and d < max_dirs]
        else:
            # 폴백: 탭 인덱스 기준 3개 그룹 (이전 버전 호환용)
            base = cur_tab * 3
            group = [i for i in range(base, min(base+3, max_dirs)) if i in enabled]

        if not group:
            return

        cur = getattr(self, "active_dir_index", group[0])
        if cur not in group:
            cur = group[0]
        pos = group.index(cur)
        pos = (pos + delta) % len(group)
        self.set_active_dir(group[pos])

    def move_tab(self, delta:int):
        """Ctrl+Tab / Ctrl+Shift+Tab: 방향 그룹(탭) 이동.

        - group_tab_mapping을 기준으로, 해당 탭에서 첫 번째 활성 방향을 선택한다.
        - 매핑이 없거나 비어 있으면 전체 첫 활성 방향으로 폴백한다.
        """
        cur_tab = self.tab.currentIndex()
        tabs = self.tab.count()
        if tabs <= 0:
            return
        new_tab = (cur_tab + delta) % tabs
        self.tab.setCurrentIndex(new_tab)

        enabled = set(self.get_enabled_indices())
        mapping = getattr(self, "group_tab_mapping", None)

        target_idx = None
        if isinstance(mapping, list) and 0 <= new_tab < len(mapping):
            # 이 탭에 속한 방향 인덱스 중 현재 활성인 것만
            cand = [d for d in mapping[new_tab] if d in enabled]
            if cand:
                target_idx = cand[0]

        if target_idx is None:
            # 매핑이 없거나 비어 있으면 전체에서 첫 활성 방향 선택
            lst = self.get_enabled_indices()
            if lst:
                target_idx = lst[0]

        if target_idx is not None:
            self.set_active_dir(target_idx)

    def install_hotkeys(self, reinstall:bool=False):
        dlog(f"install_hotkeys called reinstall={reinstall} active_dir={getattr(self,'active_dir_index',None)}")
        if reinstall:
            for sc in getattr(self, "hot_shortcuts", []): sc.setParent(None)
            self.hot_shortcuts=[]
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("Space"), self, activated=self.play_pause))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("Ctrl+Space"), self, activated=self.stop_play))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("F1"), self, activated=lambda: HelpDialog(self).exec()))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("F11"), self, activated=self.open_sheet))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("F2"), self, activated=self.choose_folder))
        for i in range(1,31):
            self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence(f"F{i}"), self, activated=lambda ii=i: self.set_active_dir(ii-1)))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("Tab"), self, activated=lambda: self.move_active_within_group(+1)))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("Shift+Tab"), self, activated=lambda: self.move_active_within_group(-1)))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("Ctrl+Tab"), self, activated=lambda: self.move_tab(+1)))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("Ctrl+Shift+Tab"), self, activated=lambda: self.move_tab(-1)))
        # Z/X/C 재정의: Z=1.0x 초기화 & 이전배속 토글, X=배속 감소, C=배속 증가
        if not hasattr(self, "_last_rate"):
            self._last_rate = 1.0

        def _change_rate(delta: float):
            try:
                cur = self.video.get_rate()
                new_r = max(0.25, min(12.0, cur + delta))
                self._last_rate = cur
                self.set_rate(new_r)
            except Exception:
                pass

        def _reset_or_previous():
            try:
                cur = self.video.get_rate()
                if abs(cur - 1.0) > 1e-6:
                    self._last_rate = cur
                    self.set_rate(1.0)
                else:
                    self.set_rate(getattr(self, "_last_rate", 1.0))
            except Exception:
                pass

        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("Z"), self, activated=_reset_or_previous))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("X"), self, activated=lambda: _change_rate(-0.25)))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("C"), self, activated=lambda: _change_rate(+0.25)))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("["), self, activated=lambda: self.move_slot(-1)))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence("]"), self, activated=lambda: self.move_slot(+1)))
        for key in ("PageDown","PgDown","PgDn"):
            self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence(key), self, activated=self.play_next_file))
        for key in ("PageUp","PgUp"):
            self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence(key), self, activated=self.play_prev_file))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key.Key_Up), self, activated=lambda: self.volume_up(+5)))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key.Key_Down), self, activated=lambda: self.volume_down(+5)))
        def bind_dir_keys():
            """방향별 단축키를 전역으로 바인딩하되,
            실제 계수는 '현재 탭(그룹)' 안에 속한 방향에만 적용되도록 한다.

            예:
              - 1-2-3 탭에서 Q → 2번 방향
              - 4-5-6 탭에서 Q → 5번 방향
              - 7-8-9 탭에서 Q → 8번 방향
            """
            vc = self.cfg.vehicle_count()
            enabled_dirs = self.get_enabled_indices()
            # key(대문자) -> [(direction_index, vehicle_index), ...]
            key_map: Dict[str, List[Tuple[int,int]]] = {}

            for d in enabled_dirs:
                if d >= len(self.cfg.dir_hotkeys):
                    continue
                keys = self.cfg.dir_hotkeys[d]
                if d in (9,10,11):
                    dlog(f"install_hotkeys: using dir {d+1} keys={keys}")
                for vi, key in enumerate(keys[:vc]):
                    if not key:
                        continue
                    k = key.upper()
                    key_map.setdefault(k, []).append((d, vi))

            def make_handler(key: str, delta: int):
                def _handler():
                    k = key.upper()
                    matches = key_map.get(k, [])
                    if not matches:
                        return

                    # 현재 탭(그룹)에 속한 방향만 남기기
                    group_dirs = None
                    try:
                        cur_tab = self.tab.currentIndex()
                        mapping = getattr(self, "group_tab_mapping", None)
                        if isinstance(mapping, list) and 0 <= cur_tab < len(mapping):
                            group_dirs = set(mapping[cur_tab])
                    except Exception:
                        group_dirs = None

                    if group_dirs:
                        matches_use = [(d, v) for (d, v) in matches if d in group_dirs]
                        if not matches_use:
                            return
                    else:
                        matches_use = matches

                    cur = getattr(self, 'active_dir_index', None)
                    # 기본값: 현재 그룹 안 첫 매칭 사용
                    target_dir, veh_idx = matches_use[0]

                    # 현재 활성 방향이 그룹 안에 있고, 해당 키를 가진 경우 우선 사용
                    if cur is not None:
                        for d, v in matches_use:
                            if d == cur:
                                target_dir, veh_idx = d, v
                                break

                    enabled_set = set(self.get_enabled_indices())
                    if target_dir not in enabled_set:
                        return
                    if not (0 <= veh_idx < vc):
                        return

                    # 방향 자동 전환 후 계수
                    if cur != target_dir:
                        try:
                            self.set_active_dir(target_dir)
                        except Exception:
                            pass
                    try:
                        self.quick_add(target_dir, veh_idx, delta)
                    except Exception:
                        pass
                return _handler

            # 중복 키 없이 한 번만 단축키 등록
            for key in key_map.keys():
                # 기본(+1) 계수
                self.hot_shortcuts.append(
                    QtGui.QShortcut(QtGui.QKeySequence(key), self, activated=make_handler(key, +1))
                )
                # Shift+key 는 -1 계수
                self.hot_shortcuts.append(
                    QtGui.QShortcut(QtGui.QKeySequence('Shift+' + key), self, activated=make_handler(key, -1))
                )

        bind_dir_keys()
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key.Key_Left), self, activated=lambda: self.seek_rel(-5000)))
        self.hot_shortcuts.append(QtGui.QShortcut(QtGui.QKeySequence(QtCore.Qt.Key.Key_Right), self, activated=lambda: self.seek_rel(+5000)))
        self._refresh_bottom_hotkey_labels()



    def _refresh_bottom_hotkey_labels(self):
        """cfg.dir_hotkeys 값으로 하단(방향별) 단축키 라벨을 즉시 갱신"""
        try:
            vtypes = [vt.get("name", "") for vt in getattr(self.cfg, "vehicle_types", [])]
        except Exception:
            vtypes = []
        if not hasattr(self, "shortcut_lbls"):
            return
        try:
            dir_hotkeys = getattr(self.cfg, "dir_hotkeys", [])
        except Exception:
            dir_hotkeys = []
        for didx, keys in enumerate(dir_hotkeys):
            if keys is None:
                keys = []
            for vidx, vtype in enumerate(vtypes):
                lbl = self.shortcut_lbls.get((didx, vtype))
                if lbl is None:
                    continue
                key = keys[vidx] if vidx < len(keys) else ""
                try:
                    key_s = str(key)
                except Exception:
                    key_s = ""
                if lbl.text() != key_s:
                    lbl.setText(key_s)

    # time/tick
    @staticmethod
    def ms_to_hms(ms:int)->str:
        s = max(0, int(ms/1000)); h=s//3600; m=(s%3600)//60; ss=s%60; return f"{h:02d}:{m:02d}:{ss:02d}"

    def _guess_start_sec_from_filename(self, path: str):
        """파일명에서 HHMMSS 형태의 시간을 추정하여 초(0~86399) 단위로 반환.
        예: 20251128_071404.mp4 -> 07:14:04 -> 7*3600+14*60+4
        찾지 못하면 None 반환.
        """
        try:
            import os, re as _re
            base = os.path.basename(path)
            # 뒤에서부터 6자리 숫자를 찾아 시각으로 해석
            cand = None
            for m in _re.finditer(r"(\d{6})", base):
                cand = m.group(1)
            if not cand:
                return None
            hh = int(cand[0:2]); mm = int(cand[2:4]); ss = int(cand[4:6])
            if not (0 <= hh < 24 and 0 <= mm < 60 and 0 <= ss < 60):
                return None
            return hh*3600 + mm*60 + ss
        except Exception:
            return None

    def _update_slot_from_playback_time(self, ms: int):
        """방식 C: 재생 중인 실제 시각 기준으로 계수시간(슬롯) 콤보를 자동 이동.

        - current_file_start_sec: 파일명에서 얻은 시작 시각(초, 0~86399)
        - ms: 현재 재생 위치(ms)
        - cfg.active_windows 를 기준으로 생성된 slotCombo 중, 해당 시각이 포함되는 슬롯이 있으면
          그 슬롯을 자동 선택한다.
        """
        try:
            start_sec = getattr(self, "current_file_start_sec", None)
            if start_sec is None:
                return
            combo = getattr(self, "slotCombo", None)
            if combo is None or combo.count() == 0:
                return
            # 현재 재생 시각(초) -> 0~86399
            cur_ms = max(0, int(ms))
            cur_sec = (int(start_sec) + cur_ms // 1000) % 86400
            # 이 시각이 속한 슬롯 시작 시각 계산
            new_start = (cur_sec // SLOT_SEC) * SLOT_SEC

            # 현재 콤보에 존재하는 슬롯들 중 new_start 를 찾는다.
            target_index = -1
            for i in range(combo.count()):
                if combo.itemData(i) == new_start:
                    target_index = i
                    break
            if target_index < 0:
                # 활성 조사시간(윈도우)에 포함되지 않으면 아무 것도 하지 않음
                return

            # 이미 선택된 슬롯이면 건너뜀
            if combo.currentIndex() == target_index and getattr(self, "current_slot_start", None) == new_start:
                return

            # on_slot_combo_changed 시그널을 그대로 사용해서 내부 상태/집계까지 갱신
            combo.setCurrentIndex(target_index)
        except Exception:
            # 어떤 오류가 나더라도 재생 자체는 방해하지 않도록 방어
            pass



    def on_time_changed(self, ms: int):
        """
        VLC 재생 위치 변경 콜백
        - 시간 라벨 갱신
        - N분 자동 멈춤 지점 도달 시 자동 일시정지
        - 파란/빨간 마커 갱신
        """
        # 재생 시간 라벨
        self._update_time_label(ms)
        # 방식 C: 재생 시각 기준으로 계수시간(슬롯) 자동 이동
        try:
            self._update_slot_from_playback_time(ms)
        except Exception:
            pass

        # 이미 자동정지 후, 사용자가 수동으로 다시 재생할 때까지 대기하는 상태라면
        if getattr(self, "_awaiting_resume", False):
            try:
                self._update_markers_for_current_file()
            except Exception:
                pass
            return

        # --- 자동 멈춤 조건 검사 ---
        try:
            if self._auto_pause_should_stop_here(ms):
                try:
                    self.video.pause()
                except Exception:
                    pass
                # 한 번 멈춘 뒤에는 일시정지 상태로 두되,
                # 자동멈춤 설정(N분 간격)과 버튼 상태는 그대로 유지한다.
                # 사용자가 다시 재생(▶/Space)을 눌렀을 때 현재 위치를
                # 새로운 시작 지점으로 사용하여 다음 N분 후에도 자동으로 멈추게 된다.
                self._awaiting_resume = True
                # auto_pause_enabled / btnAutoPause 상태는 건드리지 않는다 (연속 동작용)
                try:
                    self._update_markers_for_current_file()
                    self._update_break_info()
                except Exception:
                    pass
                return
        except Exception:
            # 계산 중 오류가 나더라도 재생 자체는 계속되도록 보호
            pass

        # 일반적인 경우: 마커만 갱신
        try:
            self._update_markers_for_current_file()
        except Exception:
            pass


    def update_time_labels(self, cur_ms:int, remain_ms:int):
        total = self.video.length_ms()
        total_txt = self.ms_to_hms(total)
        if self.timeMode==0:
            self.playTimeLbl.setText(f"{self.ms_to_hms(cur_ms)} / {total_txt}")
        else:
            self.playTimeLbl.setText(f"-{self.ms_to_hms(remain_ms)} / {total_txt}")

    def on_time_label_clicked(self, e):
        self.timeMode = 1 - getattr(self, "timeMode", 0)
        self.update_time_labels(self.video.get_time_ms(), max(0, self.video.length_ms()-self.video.get_time_ms()))

    def on_tick(self):
        # Clean build: 자동정지/책갈피 없음. 여기서는 계수/상태 자동 저장만 수행.
        self.autosave_timer += 0.5
        if self.autosave_timer >= AUTOSAVE_S:
            self.autosave_timer = 0.0
            try:
                self.save_csv(auto=True)
            except Exception:
                pass
            try:
                self.save_state(reason="auto")
            except Exception:
                pass

    def closeEvent(self, event: QtGui.QCloseEvent) -> None:
        """
        창 닫기(X 버튼) 시, 저장 여부를 확인하고 선택에 따라 저장 후 종료.
        """
        try:
            resp = QtWidgets.QMessageBox.question(
                self,
                "종료",
                "현재 계수 내용을 저장하고 종료하시겠습니까?",
                QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No,
                QtWidgets.QMessageBox.StandardButton.Yes,
            )
        except Exception:
            # 메시지 박스 표시 실패 시에는 저장 후 종료
            resp = QtWidgets.QMessageBox.StandardButton.Yes

        if resp == QtWidgets.QMessageBox.StandardButton.Yes:
            try:
                self.save_state(reason="exit")
            except Exception:
                pass
            try:
                # 자동 저장 CSV도 같이 남김
                self.save_csv(auto=True)
            except Exception:
                pass

        try:
            super().closeEvent(event)
        except Exception:
            try:
                event.accept()
            except Exception:
                pass


    def seek_rel(self, delta_ms:int):
        t=self.video.get_time_ms(); L=self.video.length_ms()
        if L<=0: return
        t=max(0, min(L-1, t+delta_ms)); self.video.set_time_ms(t)

    # save
    def state_path(self) -> Path:
        """자동 저장용 상태 파일 경로 (계수/폴더/재생위치)."""
        base = Path.home() / "Documents"
        try:
            base.mkdir(parents=True, exist_ok=True)
        except Exception:
            base = Path.home()
        return base / "traffic_counter_state.json"

    def save_state(self, reason: str = "auto"):
        """
        현재 계수/조사시간/폴더/파일/재생위치를 JSON으로 저장.
        - reason: "auto" | "exit" 등 (현재 로직에서는 구분만 기록용)
        """
        try:
            path = self.state_path()
        except Exception:
            return
        try:
            # 현재 재생 위치
            try:
                cur_ms = int(self.video.get_time_ms())
            except Exception:
                cur_ms = 0

            # 계수 데이터 직렬화
            table_out = {}
            for idx, counts in getattr(self.counts, "table", {}).items():
                key = str(idx)
                inner = {}
                for (d, v), c in counts.items():
                    try:
                        # 현재 설정에 존재하는 방향/차종만 저장
                        if d in self.cfg.directions and v in self.cfg.vehicle_types:
                            inner[f"{d}|{v}"] = int(c)
                    except Exception:
                        continue
                if inner:
                    table_out[key] = inner

            labels_out = {}
            for k, v in getattr(self.counts, "labels", {}).items():
                try:
                    labels_out[str(int(k))] = str(v)
                except Exception:
                    continue

            data = {
                "version": 1,
                "reason": reason,
                "user": (self.user.get("username") if isinstance(getattr(self, "user", None), dict) else None),
                "current_folder": str(self.current_folder) if getattr(self, "current_folder", None) else None,
                "current_file": getattr(self, "current_file", None),
                "current_file_index": int(self.current_file_index()) if hasattr(self, "fileList") else None,
                "video_ms": cur_ms,
                "slot_start": int(getattr(self, "current_slot_start", 0) or 0),
                "counts": {
                    "table": table_out,
                    "labels": labels_out,
                },
                "cfg": {
                    "directions": list(getattr(self.cfg, "directions", [])),
                    "enabled_directions": list(getattr(self.cfg, "enabled_directions", [])),
                    "vehicle_types": list(getattr(self.cfg, "vehicle_types", [])),
                    "active_windows": [
                        [int(s), int(e)]
                        for (s, e) in getattr(self.cfg, "active_windows", [])
                    ],
                },
            }

            try:
                with path.open("w", encoding="utf-8") as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)
            except Exception:
                # 저장 실패는 앱 동작에 영향 주지 않도록 무시
                pass
        except Exception:
            # 어떤 예외도 앱을 멈추지 않도록 보호
            pass


    def load_last_state(self):
        """마지막 자동 저장 상태에서 폴더/파일/재생위치/계수 복원."""
        # 한 번만 복원하도록 가드
        if getattr(self, "_loaded_last_state_once", False):
            return

        try:
            path = self.state_path()
        except Exception:
            return

        try:
            if not path.exists():
                # 더 이상 시도하지 않도록 플래그만 설정
                self._loaded_last_state_once = True
                return

            # 이전 작업을 불러올지 사용자에게 확인
            try:
                resp = QtWidgets.QMessageBox.question(
                    self,
                    "이전 작업 불러오기",
                    "이전에 작업한 내용을 불러오시겠습니까?",
                    QtWidgets.QMessageBox.StandardButton.Yes | QtWidgets.QMessageBox.StandardButton.No,
                    QtWidgets.QMessageBox.StandardButton.Yes,
                )
            except Exception:
                resp = QtWidgets.QMessageBox.StandardButton.No

            if resp != QtWidgets.QMessageBox.StandardButton.Yes:
                # 사용자가 아니오를 선택한 경우에도 다시 묻지 않도록 플래그 설정
                self._loaded_last_state_once = True
                return

            with path.open("r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception:
            return

        # 실제로 복원을 한 번 수행했으므로 플래그 설정
        self._loaded_last_state_once = True

        # --- 설정 복원 (방향/차종/조사시간 구간) ---
        try:
            cfg_in = data.get("cfg") or {}
            if isinstance(cfg_in, dict):
                dirs = cfg_in.get("directions")
                if isinstance(dirs, list) and dirs:
                    self.cfg.directions = list(dirs)

                enabled = cfg_in.get("enabled_directions")
                if isinstance(enabled, list) and enabled:
                    flags = [bool(x) for x in enabled]
                    max_len = max(len(self.cfg.directions), len(flags))
                    if len(flags) < max_len:
                        flags.extend([False] * (max_len - len(flags)))
                    self.cfg.enabled_directions = flags

                vehicles = cfg_in.get("vehicle_types")
                if isinstance(vehicles, list) and vehicles:
                    self.cfg.vehicle_types = list(vehicles)

                aw = cfg_in.get("active_windows")
                if isinstance(aw, list) and aw:
                    ranges = []
                    for se in aw:
                        if isinstance(se, (list, tuple)) and len(se) == 2:
                            try:
                                s = int(se[0]); e = int(se[1])
                            except Exception:
                                continue
                            ranges.append((s, e))
                    if ranges:
                        self.cfg.active_windows = ranges

                # CountTable 도 방향/차종 정보 동기화
                try:
                    self.counts.directions = self.cfg.directions
                    self.counts.vehicle_types = self.cfg.vehicle_types
                except Exception:
                    pass
                # UI 패널도 현재 설정에 맞게 다시 구성
                try:
                    self.rebuild_panels_after_change()
                except Exception:
                    pass
        except Exception:
            pass

        # --- 계수 복원 ---
        try:
            counts_data = data.get("counts") or {}
            labels_in = counts_data.get("labels") or {}
            table_in = counts_data.get("table") or {}

            # 기존 데이터 초기화 후 재구성
            self.counts.table = {}
            self.counts.labels = {}

            for idx_str, inner in table_in.items():
                try:
                    idx = int(idx_str)
                except Exception:
                    continue
                if not isinstance(inner, dict):
                    continue
                new_inner = {}
                for key, val in inner.items():
                    try:
                        d, v = key.split("|", 1)
                    except Exception:
                        continue
                    # 현재 설정에 존재하는 방향/차종만 반영
                    if d in self.cfg.directions and v in self.cfg.vehicle_types:
                        try:
                            new_inner[(d, v)] = int(val)
                        except Exception:
                            continue
                if new_inner:
                    self.counts.table[idx] = new_inner
                    lbl = labels_in.get(str(idx), labels_in.get(idx, ""))
                    self.counts.labels[idx] = lbl
            try:
                self.counts.changed.emit()
            except Exception:
                pass
            try:
                self.refresh_all_quick_counts()
            except Exception:
                pass
        except Exception:
            pass

        # --- 슬롯(조사시간) 콤보 복원 ---
        try:
            slot_start = int(data.get("slot_start", 0) or 0)
            if hasattr(self, "slotCombo"):
                # active_windows 를 먼저 복원했으므로, 해당 시간대가 포함되도록 콤보를 재구성
                self.rebuild_slot_combo(select_start=slot_start)
        except Exception:
            pass

        # --- 폴더/파일/재생 위치 복원 ---
        try:
            folder_path = data.get("current_folder") or None
            file_path = data.get("current_file") or None
            video_ms = int(data.get("video_ms") or 0)
            file_index = data.get("current_file_index")
        except Exception:
            folder_path = None
            file_path = None
            video_ms = 0
            file_index = None

        try:
            from pathlib import Path as _P
            if folder_path:
                pf = _P(folder_path)
                if pf.is_dir():
                    self.current_folder = pf
                    self.refresh_file_list()
                    selected = None
                    if file_path and hasattr(self, "fileList"):
                        for i in range(self.fileList.count()):
                            it = self.fileList.item(i)
                            if it and it.data(QtCore.Qt.ItemDataRole.UserRole) == file_path:
                                selected = i
                                break
                    if selected is None and isinstance(file_index, int):
                        if hasattr(self, "fileList") and 0 <= file_index < self.fileList.count():
                            selected = file_index
                    if selected is not None and hasattr(self, "fileList"):
                        self.fileList.setCurrentRow(selected)
                    # 동영상 위치 복원 (자동 재생은 하지 않고 미디어/시간만 맞춤)
                    if file_path:
                        try:
                            self.current_file = file_path
                            if hasattr(self, "video"):
                                self.video.set_media(file_path)
                                if video_ms > 0:
                                    self.video.set_time_ms(int(video_ms))
                                    try:
                                        self._update_time_label(int(video_ms))
                                    except Exception:
                                        pass
                        except Exception:
                            pass
        except Exception:
            pass


    def autosave_path(self)->Path:
        base=Path.home()/ "Documents"
        try: base.mkdir(parents=True, exist_ok=True)
        except Exception: base=Path.home()
        return base/"traffic_counter_autosave.csv"


    def save_csv(self, auto:bool=False):
        df_long=self.counts.to_long_df()
        if df_long.empty and not auto:
            QtWidgets.QMessageBox.information(self,"안내","저장할 데이터가 없습니다."); return
        labels=[]
        for s,e in sorted(self.cfg.active_windows):
            t=s
            while t<e:
                labels.append(slot_label(t)); t+=SLOT_SEC
        labels=list(dict.fromkeys(labels)) or ["00:00~00:15"]
        if df_long.empty:
            df_out = pd.DataFrame({"시간대": labels})
        else:
            df_long=df_long.copy()
            df_long["시간대"] = df_long["slot_label"]
            # 방향명을 안전하게 번호로 매핑 (정규식 추출 대신 cfg 기준 매핑)
            _dir_map = {name: i+1 for i, name in enumerate(self.cfg.directions)}
            df_long["방향번호"] = df_long["direction"].map(_dir_map)
            df_long = df_long.dropna(subset=["방향번호"])
            df_long["방향번호"] = df_long["방향번호"].astype(int)
            pv=df_long.pivot_table(index="시간대", columns=["방향번호","vehicle"], values="count", aggfunc="sum", fill_value=0)
            cols=[]; vehicles=self.cfg.vehicle_types[:self.cfg.vehicle_count()]
            enabled_dirs = [i+1 for i, ok in enumerate(self.cfg.enabled_directions) if ok and i < len(self.cfg.directions)]
            if not enabled_dirs:
                enabled_dirs = [1]
            for d in enabled_dirs:
                for v in vehicles:
                    if (d,v) in pv.columns:
                        cols.append((d,v))
            pv=pv.reindex(columns=cols, fill_value=0).reset_index()
            df_out=pv
        if auto:
            path=self.autosave_path(); df_out.to_csv(path, index=False, encoding="utf-8-sig"); return
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"CSV 저장(시트형)","traffic_counts_sheet.csv","CSV (*.csv)")
        if path: df_out.to_csv(path, index=False, encoding="utf-8-sig"); QtWidgets.QMessageBox.information(self,"저장됨", f"저장 완료: {path}")

    def save_progress(self):
        """현재 진행 중인 내역을 저장하는 자리(추후 구현)."""
        try:
            QtWidgets.QMessageBox.information(self, "안내", "진행내역 저장 기능은 추후에 구현됩니다.")
        except Exception:
            pass


    def save_xlsx(self):
        if not _HAS_XLSX:
            QtWidgets.QMessageBox.warning(self,"안내","openpyxl 설치가 필요합니다: pip install openpyxl"); return
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"엑셀 저장(방향별 시트)","traffic_counts_by_direction.xlsx","Excel Workbook (*.xlsx)")
        if not path: return
        with pd.ExcelWriter(path, engine="openpyxl") as writer:
            enabled_dirs = [i+1 for i, ok in enumerate(self.cfg.enabled_directions) if ok and i < len(self.cfg.directions)]
            if not enabled_dirs:
                enabled_dirs = [1]
            for dirno in enabled_dirs:
                df=self.counts.to_sheet_df_per_direction(self.cfg, dirno)
                sheet_name=f"{dirno}"
                df.to_excel(writer, sheet_name=sheet_name, index=False)
        QtWidgets.QMessageBox.information(self,"저장됨", f"엑셀 저장 완료: {path}")

# ==== Users/Admin ====
class LoginDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent); self.setWindowTitle("로그인")
        f=QtWidgets.QFormLayout(self); self.u=QtWidgets.QLineEdit(); self.p=QtWidgets.QLineEdit(); self.p.setEchoMode(QtWidgets.QLineEdit.EchoMode.Password)
        f.addRow("아이디", self.u); f.addRow("비밀번호", self.p)
        bb=QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.StandardButton.Ok|QtWidgets.QDialogButtonBox.StandardButton.Cancel); f.addRow(bb)
        bb.accepted.connect(self.accept); bb.rejected.connect(self.reject)
    def get(self): return self.u.text().strip(), self.p.text().strip()

class UserEditor(QtWidgets.QDialog):
    def __init__(self, parent=None, username="", role="operator", ask_pw=True):
        super().__init__(parent); self.setWindowTitle("사용자 정보")
        form=QtWidgets.QFormLayout(self)
        self.username=QtWidgets.QLineEdit(username); self.role=QtWidgets.QComboBox(); self.role.addItems(["admin","operator"]); self.role.setCurrentText(role)
        form.addRow("아이디", self.username); form.addRow("권한", self.role)
        self.pw=None
        if ask_pw:
            self.pw=QtWidgets.QLineEdit(); self.pw.setEchoMode(QtWidgets.QLineEdit.EchoMode.Password); form.addRow("비밀번호", self.pw)
        bb=QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.StandardButton.Ok|QtWidgets.QDialogButtonBox.StandardButton.Cancel); form.addRow(bb)
        bb.accepted.connect(self.accept); bb.rejected.connect(self.reject)

class UserManagerDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent); self.setWindowTitle("사용자 계정 관리 (Admin)")
        v=QtWidgets.QVBoxLayout(self)
        self.table=QtWidgets.QTableWidget(); self.table.setColumnCount(4); self.table.setHorizontalHeaderLabels(["ID","아이디","권한","생성일자"]); v.addWidget(self.table)
        h=QtWidgets.QHBoxLayout(); self.addBtn=QtWidgets.QPushButton("추가"); self.editBtn=QtWidgets.QPushButton("수정"); self.delBtn=QtWidgets.QPushButton("삭제"); self.resetBtn=QtWidgets.QPushButton("비밀번호 재설정"); self.exportBtn=QtWidgets.QPushButton("로그 CSV 내보내기")
        for w in (self.addBtn,self.editBtn,self.delBtn,self.resetBtn): h.addWidget(w); h.addStretch(1); h.addWidget(self.exportBtn); v.addLayout(h)
        self.addBtn.clicked.connect(self.on_add); self.editBtn.clicked.connect(self.on_edit); self.delBtn.clicked.connect(self.on_del); self.resetBtn.clicked.connect(self.on_reset_pw); self.exportBtn.clicked.connect(self.on_export)
        self.reload()
    def reload(self):
        rows=users_all(); self.table.setRowCount(len(rows))
        for r,(uid,un,role,created) in enumerate(rows):
            self.table.setItem(r,0,QtWidgets.QTableWidgetItem(str(uid))); self.table.setItem(r,1,QtWidgets.QTableWidgetItem(un))
            self.table.setItem(r,2,QtWidgets.QTableWidgetItem(role)); self.table.setItem(r,3,QtWidgets.QTableWidgetItem(created))
        self.table.resizeColumnsToContents()
    def selected(self): 
        items=self.table.selectedItems(); 
        return None if not items else int(self.table.item(items[0].row(),0).text())
    def on_add(self):
        dlg=UserEditor(self, ask_pw=True)
        if dlg.exec()==QtWidgets.QDialog.DialogCode.Accepted:
            u=dlg.username.text().strip(); role=dlg.role.currentText(); p=dlg.pw.text().strip()
            if not u or not p: QtWidgets.QMessageBox.warning(self,"경고","아이디/비밀번호 입력"); return
            try: user_add(u,p,role); self.reload()
            except sqlite3.IntegrityError: QtWidgets.QMessageBox.warning(self,"경고","중복 아이디")
    def on_edit(self):
        uid=self.selected(); 
        if not uid: return
        rows=users_all(); row=[r for r in rows if r[0]==uid][0]; dlg=UserEditor(self, username=row[1], role=row[2], ask_pw=False)
        if dlg.exec()==QtWidgets.QDialog.DialogCode.Accepted: user_update(uid, dlg.username.text().strip(), dlg.role.currentText()); self.reload()
    def on_del(self):
        uid=self.selected(); 
        if not uid: return
        if QtWidgets.QMessageBox.question(self,"확인","삭제할까요?")==QtWidgets.QMessageBox.StandardButton.Yes: user_delete(uid); self.reload()
    def on_reset_pw(self):
        uid=self.selected(); 
        if not uid: return
        pw,ok=QtWidgets.QInputDialog.getText(self,"비밀번호 재설정","새 비밀번호:", QtWidgets.QLineEdit.EchoMode.Password)
        if ok and pw: user_reset_password(uid,pw); QtWidgets.QMessageBox.information(self,"완료","변경됨")
    def on_export(self):
        path,_=QtWidgets.QFileDialog.getSaveFileName(self,"로그 CSV 내보내기","counter_logs.csv","CSV (*.csv)")
        if path: logs_export_csv(path); QtWidgets.QMessageBox.information(self,"완료", f"저장: {path}")


    # ===== ENV 연동: hotkeys_db.json 로부터 과업/지점/방향/차종/단축키 적용 =====
    def apply_env_defaults_if_available(self):
        """hotkeys_db.json이 있으면, 첫 과업/첫 지점을 기본으로 적용(사용자가 나중에 메뉴에서 변경 가능)."""
        db = getattr(self, "hkdb", None) or {}
        surveys = db.get("surveys", []) or []
        if not surveys:
            return
        # 첫 과업에서 첫 지점 찾기
        s0 = surveys[0]
        sites = (s0.get("sites") or [])
        if not sites:
            return
        self.apply_env_selection(0, 0)

    def open_env_hotkeys_db(self):
        """환경설정(과업/지점) 목록을 로드하여 상단 콤보를 채웁니다."""
        try:
            self.hkdb = load_hotkeys_db()
        except Exception:
            self.hkdb = {}

        surveys = (self.hkdb or {}).get("surveys", []) or []
        if isinstance(surveys, dict):
            surveys = list(surveys.values())

        if not surveys:
            QtWidgets.QMessageBox.information(
                self,
                "환경설정 불러오기",
                "환경설정 DB를 찾지 못했습니다.\n\n1) Y:\\Survey 또는 NAS Survey 폴더에 env_data_plus_allinone.json 이 존재하는지 확인\n2) (선택) hotkeys_db.json 이 생성되어 있으면 함께 적용됩니다."
            )
            return

        try:
            self._populate_env_project_site_combos()
        except Exception:
            pass

    def _pick_survey_site_dialog(self):
        db = getattr(self, "hkdb", None) or {}
        surveys = db.get("surveys", []) or []
        dlg = QtWidgets.QDialog(self)
        dlg.setWindowTitle("환경설정 선택")
        v = QtWidgets.QVBoxLayout(dlg)
        form = QtWidgets.QFormLayout()
        cb_s = QtWidgets.QComboBox(dlg)
        cb_t = QtWidgets.QComboBox(dlg)

        def _survey_title(s):
            # 가능한 키들을 최대한 넓게 지원
            info = s.get("info") if isinstance(s.get("info"), dict) else {}
            sn = s.get("survey_no") or info.get("survey_no") or info.get("sn") or ""
            name = s.get("name") or info.get("name") or info.get("title") or ""
            base = (sn or "").strip()
            if name:
                return f"{base}  {name}".strip()
            return base or "(과업)"

        def _site_title(t):
            jibun = t.get("jibun") or t.get("지번") or ""
            nm = t.get("name") or t.get("지점명") or t.get("site_name") or ""
            if jibun and nm:
                return f"{jibun}_{nm}"
            return nm or jibun or "(지점)"

        for s in surveys:
            cb_s.addItem(_survey_title(s))

        def _reload_sites():
            cb_t.clear()
            sidx = cb_s.currentIndex()
            if not (0 <= sidx < len(surveys)):
                return
            sites = surveys[sidx].get("sites") or []
            for t in sites:
                cb_t.addItem(_site_title(t))

        cb_s.currentIndexChanged.connect(_reload_sites)
        _reload_sites()

        form.addRow("과업:", cb_s)
        form.addRow("지점:", cb_t)
        v.addLayout(form)

        btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.StandardButton.Ok | QtWidgets.QDialogButtonBox.StandardButton.Cancel)
        btns.accepted.connect(dlg.accept)
        btns.rejected.connect(dlg.reject)
        v.addWidget(btns)

        if dlg.exec() != QtWidgets.QDialog.DialogCode.Accepted:
            return (None, None)
        return (cb_s.currentIndex(), cb_t.currentIndex())

    def open_env_settings_window(self):
        """환경설정 UI를 별도 창으로 실행합니다(동일 폴더의 env_*.py 우선)."""
        import subprocess
        import sys
        base_dir = os.path.dirname(os.path.abspath(__file__))

        # 1) 같은 폴더의 대표 env 파일 우선 탐색
        candidates = [
            os.path.join(base_dir, "env_hotkey97_fixed_displayname_export_hotkeys_v2.py"),
            os.path.join(base_dir, "env_hotkey97_fixed_displayname_export_hotkeys.py"),
            os.path.join(base_dir, "env_hotkey97_fixed_displayname.py"),
        ]
        env_py = None
        for p in candidates:
            if os.path.isfile(p):
                env_py = p
                break

        # 2) 없으면 파일 선택
        if env_py is None:
            env_py, _ = QtWidgets.QFileDialog.getOpenFileName(
                self, "환경설정 파일 선택", base_dir, "Python (*.py)"
            )
            if not env_py:
                return

        try:
            subprocess.Popen([sys.executable, env_py], cwd=base_dir)
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "환경설정 실행 실패", str(e))



    def apply_env_selection(self, survey_index: int, site_index: int):
            """
            환경설정(JSON) 기반으로 선택된 과업/지점의
            - 상단 과업/지점 표시
            - 입력그룹 탭(예: 1-2-3 / 4-5-6 ...)
            - 각 방향별(1~12) 차종/단축키(방향별 sheet) 적용
            을 계수 화면에 반영합니다.
            """
            envdb = getattr(self, "envdb", None) or {}
            hkdb  = getattr(self, "hkdb", None) or {}  # 보조(향후 site별 override 용)
            surveys = envdb.get("surveys", []) or []
            projects = envdb.get("projects", []) or []

            if not (0 <= survey_index < len(surveys)):
                return
            survey = surveys[survey_index]
            sites = survey.get("sites") or []
            if not (0 <= site_index < len(sites)):
                return
            site = sites[site_index]

            # --- hotkeys_db.json(보조)에서 site override가 있으면 적용 ---
            
            def _find_override_site(hkdb_obj, survey_obj, site_obj):

                """hotkeys_db.json 구조가 버전마다 달라서, 가능한 한 유연하게 '해당 지점' override를 찾습니다.

                - 1순위: 작업번호(work_no) 일치

                - 2순위: 지번+지점명 일치

                - candidates: counters/groups(또는 입력그룹)/dir_hotkeys/group_dir_hotkeys/hotkeys 키가 있는 dict

                """

                try:

                    target_wno = site_obj.get('작업번호') or site_obj.get('work_no') or site_obj.get('id')

                    target_jibun = site_obj.get('지번') or site_obj.get('jibun')

                    target_nm = site_obj.get('지점명') or site_obj.get('name')


                    def _iter_dicts(o):

                        if isinstance(o, dict):

                            yield o

                            for v in o.values():

                                yield from _iter_dicts(v)

                        elif isinstance(o, list):

                            for v in o:

                                yield from _iter_dicts(v)


                    for d in _iter_dicts(hkdb_obj):

                        if not isinstance(d, dict):

                            continue

                        has_override = (

                            isinstance(d.get('counters'), list)

                            or isinstance(d.get('groups'), list)

                            or isinstance(d.get('입력그룹'), list)

                            or isinstance(d.get('dir_hotkeys'), dict)

                            or isinstance(d.get('group_dir_hotkeys'), dict)

                            or isinstance(d.get('hotkeys'), (dict, list))

                        )

                        if not has_override:

                            continue


                        wno = d.get('작업번호') or d.get('work_no') or d.get('id')

                        if target_wno and wno and str(wno) == str(target_wno):

                            return d


                        jb = d.get('지번') or d.get('jibun')

                        nm = d.get('지점명') or d.get('name')

                        if (target_jibun is not None) and (target_nm is not None) and (jb is not None) and (nm is not None):

                            if (str(jb) == str(target_jibun)) and (str(nm) == str(target_nm)):

                                return d


                    return None

                except Exception:

                    return None
                except Exception:
                    return None

            ov_site = _find_override_site(hkdb, survey, site)
            if isinstance(ov_site, dict):
                # counters / groups 등 override가 있으면 덮어쓰기
                if isinstance(ov_site.get('groups'), list):
                    site['groups'] = ov_site.get('groups')
                if isinstance(ov_site.get('counters'), list):
                    site['counters'] = ov_site.get('counters')
                # 차량 단축키 시트(프로젝트) override가 있으면 env projects보다 우선 사용
                if isinstance(hkdb.get('projects'), list):
                    projects = hkdb.get('projects') or projects

            # -----------------------------
            # 1) 상단 표시
            # -----------------------------
            try:
                info = survey.get("info") if isinstance(survey.get("info"), dict) else {}
                work_name = (info.get("name") or "").strip()
                jibun = str(site.get("지번") or site.get("jibun") or site.get("address") or "").strip()
                sname = str(site.get("지점명") or site.get("name") or site.get("site_name") or "").strip()
                site_disp = (f"{jibun}_{sname}" if (jibun or sname) else "").strip("_")
                if hasattr(self, "projectCombo"):
                    # 표시만(선택은 콤보 자체가 관리)
                    pass
                if hasattr(self, "siteCombo"):
                    pass
                # 상단 라벨/입력칸(있으면)
                if hasattr(self, "editProject") and self.editProject:
                    self.editProject.setText(work_name)
                if hasattr(self, "editSite") and self.editSite:
                    self.editSite.setText(site_disp)
            except Exception:
                pass

            # -----------------------------
            # 2) cfg: 차종명 / 방향 타이틀 / enabled_directions
            try:
                # 현재 지점(site)의 counters 이름들과 project의 (vehicle_set / hotkey sheet) 이름을 비교하여
                # 가장 잘 맞는 project를 자동 선택합니다.
                counter_names = []
                for c in (site.get("counters") or []):
                    if isinstance(c, dict):
                        nm = str(c.get("name") or c.get("display") or "").strip()
                        if nm:
                            counter_names.append(nm)

                def _proj_names(pobj):
                    vnm = []
                    for it in (pobj.get("vehicle_set") or []):
                        if isinstance(it, dict):
                            n = str(it.get("차종명") or it.get("차종구분") or it.get("name") or "").strip()
                            if n:
                                vnm.append(n)
                    snm = []
                    for it in (pobj.get("hotkey_sheets_global") or []):
                        if isinstance(it, dict):
                            n = str(it.get("name") or it.get("sheet") or "").strip()
                            if n:
                                snm.append(n)
                    return set(vnm), set(snm)

                best_proj = projects[0] if projects else {}
                best_score = -1
                for pobj in (projects or []):
                    vs, ss = _proj_names(pobj)
                    score = 0
                    # site의 counter sheet명이 project의 hotkey sheet명과 일치하면 강하게 가산
                    score += len(set(counter_names) & ss) * 10
                    # site의 counter sheet명이 project의 vehicle_set명과 일치하는 경우(유출입 등) 가산
                    score += len(set(counter_names) & vs) * 5
                    if score > best_score:
                        best_score = score
                        best_proj = pobj

                self._active_project = best_proj or {}
                self._active_project_name = str((best_proj or {}).get("name") or "").strip()

                # 차종명: active project의 vehicle_set을 우선 사용
                vnames = []
                for it in ((best_proj or {}).get("vehicle_set") or []):
                    if isinstance(it, dict):
                        nm = (it.get("차종명") or it.get("차종구분") or it.get("name") or "")
                        nm = str(nm).strip()
                        if nm:
                            vnames.append(nm)
                if vnames:
                    self.cfg.vehicle_types = vnames
            except Exception:
                pass

            try:
                # 방향수(예: 12)
                n_dir = int(site.get("방향수") or 0)
                if n_dir <= 0:
                    # counters에서 최대 dir로 추정
                    mx = 0
                    for c in (site.get("counters") or []):
                        try:
                            mx = max(mx, int(str(c.get("dir") or 0)))
                        except Exception:
                            pass
                    n_dir = mx or 12

                # cfg.directions는 index 기반(0은 미사용일 때가 많음)
                # build_dir_panel이 didx=1..n을 사용하므로 길이를 넉넉히 확보
                need_len = max(30, n_dir + 1)
                if not hasattr(self.cfg, "directions") or len(self.cfg.directions) < need_len:
                    # 기존 유지하며 확장
                    cur = list(getattr(self.cfg, "directions", []))
                    if not cur:
                        cur = [""] * need_len
                    else:
                        cur += [""] * (need_len - len(cur))
                    self.cfg.directions = cur
                for d in range(1, n_dir + 1):
                    self.cfg.directions[d] = f"{d}번방향"

                # enabled_directions도 동일하게
                if not hasattr(self.cfg, "enabled_directions") or len(self.cfg.enabled_directions) < need_len:
                    cur = list(getattr(self.cfg, "enabled_directions", []))
                    if not cur:
                        cur = [False] * need_len
                    else:
                        cur += [False] * (need_len - len(cur))
                    self.cfg.enabled_directions = cur
                for d in range(1, need_len):
                    self.cfg.enabled_directions[d] = (d <= n_dir)
            except Exception:
                pass

            # -----------------------------
            # 3) 방향별 차종 단축키 적용
            #    - site.counters: dir별 counter sheet name(방향(숫자)/방향(Q)/방향(A)...)
            #    - project.hotkey_sheets_global: sheet name -> 차량별 단축키
            # -----------------------------
            try:
                # 어떤 project를 쓸지(작업참조 == project.name)
                ref = ""
                try:
                    ref = (survey.get("vehicle") or {}).get("작업참조") or ""
                except Exception:
                    pass
                proj = getattr(self, '_active_project', None) or (projects[0] if projects else None)

                sheets = {}
                if proj:
                    for sh in (proj.get("hotkey_sheets_global") or []):
                        nm = (sh.get("name") or "").strip()
                        if nm:
                            sheets[nm] = sh

                # counters에서 dir->sheetname
                dir_to_sheet = {}
                for c in (site.get("counters") or []):
                    try:
                        d = int(str(c.get("dir") or 0))
                    except Exception:
                        continue
                    nm = (c.get("name") or "").strip()
                    if d > 0 and nm:
                        dir_to_sheet[d] = nm

                # cfg.dir_hotkeys[dir] = [차종별 키들]
                if not hasattr(self.cfg, "dir_hotkeys") or not self.cfg.dir_hotkeys:
                    self.cfg.dir_hotkeys = [[] for _ in range(30)]

                # 차량 순서(현재 cfg.vehicle_types 순서) 기준으로 키를 정렬
                vorder = list(getattr(self.cfg, "vehicle_types", []))
                for dir_no in group_dirs:
                    sheet_name = dir_to_sheet.get(str(dir_no)) or dir_to_sheet.get(dir_no)
                    if not sheet_name:
                        continue
                    sh = sheets.get(sheet_name, {})
                    # keys 정렬: vehicle_types 순서를 우선(없으면 dict 순서)
                    keys = []
                    if vorder:
                        for vname in vorder:
                            if vname in sh:
                                keys.append(str(sh.get(vname, '')))
                    if not keys:
                        # fallback
                        keys = [str(v) for v in sh.values()]
                    # 방향 번호 기준으로 저장(중요! slot 인덱스가 아니라 dir_no)
                    idx = max(0, int(dir_no) - 1)
                    # 길이 확보
                    while len(self.cfg.dir_hotkeys) <= idx:
                        self.cfg.dir_hotkeys.append([])
                    self.cfg.dir_hotkeys[idx] = keys

# UI 갱신(단축키 라벨 포함)
                try:
                    self.refresh_all_quick_counts()
                except Exception:
                    pass
            except Exception:
                pass

            # -----------------------------
            # 4) 입력그룹 탭 재구성
            #    - site.groups: ["1-2-3", "4-5-6", ...]
            # -----------------------------
            try:
                groups = site.get("groups") or []
                if not groups:
                    # 기본 생성(3개씩)
                    groups = []
                    n_dir = 12
                    for a in range(1, n_dir + 1, 3):
                        b = min(n_dir, a + 1)
                        c = min(n_dir, a + 2)
                        groups.append(f"{a}-{b}-{c}")

                # 메인 탭(self.tab) 재구성
                if hasattr(self, "tab") and self.tab:
                    self.tab.blockSignals(True)
                    try:
                        while self.tab.count():
                            w = self.tab.widget(0)
                            self.tab.removeTab(0)
                            if w:
                                w.deleteLater()
                    except Exception:
                        pass

                    for gtxt in groups:
                        parts = [p for p in str(gtxt).split("-") if p.strip().isdigit()]
                        nums = [int(p) for p in parts]
                        if len(nums) == 3:
                            a, b, c = nums
                        elif len(nums) == 2:
                            a, b = nums; c = nums[-1]
                        elif len(nums) == 1:
                            a = nums[0]; b = a; c = a
                        else:
                            continue
                        page = self._make_group_page(a, b, c)
                        self.tab.addTab(page, str(gtxt))

                    self.tab.setCurrentIndex(0)
                    self.tab.blockSignals(False)

                    # 미러 탭 동기화
                    try:
                        self._sync_group_tabs()
                    except Exception:
                        pass
            except Exception:
                pass

    def _format_site_label(self, site: dict) -> str:
        """지점 표기: 지번_지점명 (한국어 키/영문 키 모두 대응)"""
        try:
            if not isinstance(site, dict):
                site = {}
            # Korean-first
            jibun = (site.get("지번") or site.get("jibun") or site.get("jibeon") or site.get("address") or site.get("addr") or "")
            name = (site.get("지점명") or site.get("name") or site.get("site_name") or site.get("title") or "")
            jibun = str(jibun).strip()
            name = str(name).strip()
            if jibun and name:
                return f"{jibun}_{name}"
            return (jibun or name or "지점").strip()
        except Exception:
            return "지점"

    def _populate_env_project_site_combos(self):
        """env_data_plus_allinone.json 또는 hotkeys_db.json 로드 결과로 과업/지점 콤보를 채웁니다."""
        db = getattr(self, "hkdb", None) or {}
        surveys = db.get("surveys", []) or []
        if isinstance(surveys, dict):
            surveys = [{"project": k, **(v if isinstance(v, dict) else {})} for k, v in surveys.items()]
        self._env_surveys_cache = surveys

        self.projectCombo.blockSignals(True)
        self.siteCombo.blockSignals(True)
        self.projectCombo.clear()
        self.siteCombo.clear()

        for sidx, s in enumerate(surveys):
            if not isinstance(s, dict):
                continue
            proj = (s.get("info") or {}).get("name") or s.get("project") or s.get("name") or s.get("title") or ""
            proj = str(proj).strip()
            if proj:
                # itemData는 index로 고정 (중요)
                self.projectCombo.addItem(proj, sidx)

        self.projectCombo.blockSignals(False)
        self.siteCombo.blockSignals(False)

        if self.projectCombo.count() > 0:
            self.projectCombo.setCurrentIndex(0)
            try:
                self._on_env_project_changed(0)
            except Exception:
                pass

    def _on_env_project_changed(self, _idx: int = 0):
        """과업 콤보 변경 시: env_data_plus_allinone.json 기반으로 지점 콤보를 채웁니다."""
        try:
            sidx = self.projectCombo.currentData()
            if sidx is None:
                sidx = 0
            try:
                sidx = int(sidx)
            except Exception:
                sidx = 0

            surveys = getattr(self, "_env_surveys_cache", None)
            if not isinstance(surveys, list):
                surveys = (getattr(self, "hkdb", None) or {}).get("surveys", []) or []
            if not (0 <= sidx < len(surveys)):
                sidx = 0

            survey = surveys[sidx] if surveys else {}
            sites = (survey.get("sites") or (survey.get("site_data") or {}).get("sites") or []) if isinstance(survey, dict) else []
            if isinstance(sites, dict):
                sites = list(sites.values())

            # fill site combo
            self.siteCombo.blockSignals(True)
            self.siteCombo.clear()
            self._env_sites_cache = sites

            for tidx, st in enumerate(sites):
                if not isinstance(st, dict):
                    st = {}
                label = self._format_site_label(st)
                self.siteCombo.addItem(label, tidx)

            self.siteCombo.blockSignals(False)

            # auto select first
            if self.siteCombo.count() > 0:
                self.siteCombo.setCurrentIndex(0)
                try:
                    self._on_env_site_changed(0)
                except Exception:
                    pass
        except Exception:
            try:
                self.siteCombo.blockSignals(False)
            except Exception:
                pass

    def _on_env_site_changed(self, _idx: int = 0):
        """지점 콤보 변경 시: 상단 텍스트(과업/지점)를 갱신합니다."""
        try:
            surveys = getattr(self, "_env_surveys_cache", None)
            if not isinstance(surveys, list):
                surveys = (getattr(self, "hkdb", None) or {}).get("surveys", []) or []
            sidx = self.projectCombo.currentData()
            try:
                sidx = int(sidx) if sidx is not None else 0
            except Exception:
                sidx = 0
            survey = surveys[sidx] if surveys and 0 <= sidx < len(surveys) else {}
            proj_name = ""
            if isinstance(survey, dict):
                proj_name = (survey.get("info") or {}).get("name") or survey.get("project") or survey.get("name") or ""
            tidx = self.siteCombo.currentData()
            try:
                tidx = int(tidx) if tidx is not None else 0
            except Exception:
                tidx = 0
            sites = getattr(self, "_env_sites_cache", None)
            if not isinstance(sites, list):
                sites = (survey.get("sites") or []) if isinstance(survey, dict) else []
            site = sites[tidx] if sites and 0 <= tidx < len(sites) else {}
            label = self._format_site_label(site if isinstance(site, dict) else {})
            # update top line edits if exist
            if hasattr(self, "projectEdit"):
                self.projectEdit.setText(str(proj_name))
            if hasattr(self, "siteEdit"):
                # 지번_지점명
                self.siteEdit.setText(str(label))
        except Exception:
            pass

    def _extract_dir_numbers(self, site_cfg: dict) -> list[int]:
        nums = set()
        # groups 탭 라벨에서 숫자 추출
        for label in (site_cfg.get("groups") or []):
            for part in _re.split(r"[^0-9]+", str(label)):
                if part.isdigit():
                    try: nums.add(int(part))
                    except Exception: pass
        # counters에서도 추출
        for c in (site_cfg.get("counters") or []):
            try:
                d = int(str(c.get("dir", "")).strip())
                if d: nums.add(d)
            except Exception:
                pass
        return sorted(n for n in nums if 1 <= n <= 30)

    def _project_index_for_dir(self, dir_no: int, site_cfg: dict, group_projects: dict) -> int:
        # group_projects: {"1-2-3": 0, "4-5-6": 1, ...}
        try:
            for grp_label, pidx in (group_projects or {}).items():
                for part in _re.split(r"[^0-9]+", str(grp_label)):
                    if part.isdigit() and int(part) == int(dir_no):
                        return int(pidx)
        except Exception:
            pass
        return 0

    def _items_from_project_sheet(self, projects: list, pidx: int, sheet_name: str) -> list:
        if not projects:
            return []
        if not (0 <= pidx < len(projects)):
            pidx = 0
        sheets = projects[pidx].get("hotkey_sheets_global", []) or []
        if not sheet_name:
            # 시트명이 없으면 첫 시트
            if sheets:
                return (sheets[0].get("items") or [])
            return []
        for s in sheets:
            if str(s.get("name", "")).strip() == str(sheet_name).strip():
                return (s.get("items") or [])
        # 못 찾으면 이름에 숫자 포함 시 인덱스 추정
        m = _re.search(r"(\d+)", str(sheet_name))
        if m:
            idx = int(m.group(1)) - 1
            if 0 <= idx < len(sheets):
                return (sheets[idx].get("items") or [])
        return []

def apply_env_hotkeys_to_counter(self, site_json=None, surveys=None, survey_index=0, site_index=0):
    """환경설정(env_data_plus_allinone / site json)에 저장된 '카운터-방향(시트명)' 및
    (선택적으로) site_hotkeys.by_dir(실제 키 리스트) 정보를 cfg.dir_hotkeys 로 반영한다.

    - 우선순위:
      1) site_json.site.site_hotkeys.by_dir (있으면 그대로 사용)
      2) envdb(=surveys)의 site.site_hotkeys.by_dir (있으면 그대로 사용)
      3) site.counters 의 '방향'(시트명)을 프로젝트의 hotkey_sheets_global에서 찾아 키 리스트로 변환
    """
    try:
        envdb = surveys or getattr(self, "envdb", None)
        if not envdb:
            return

        # --- target site 가져오기 (envdb는 dict 또는 surveys(list) 혼합 지원) ---
        target_site = None
        project0 = None

        # envdb가 전체 dict인 경우: {"projects":[...], "surveys":[...]}
        if isinstance(envdb, dict):
            project0 = (envdb.get("projects") or [None])[0]
            svs = envdb.get("surveys") or []
            if 0 <= int(survey_index) < len(svs):
                sites = svs[int(survey_index)].get("sites") or []
                if 0 <= int(site_index) < len(sites):
                    target_site = sites[int(site_index)]
        else:
            # surveys(list)만 들어온 경우
            svs = envdb
            if 0 <= int(survey_index) < len(svs):
                sites = svs[int(survey_index)].get("sites") or []
                if 0 <= int(site_index) < len(sites):
                    target_site = sites[int(site_index)]
            # projects 정보는 self.envdb에서 가져오기
            if isinstance(getattr(self, "envdb", None), dict):
                project0 = (self.envdb.get("projects") or [None])[0]

        if not target_site:
            return

        # --- 1) site_json override (가장 우선) ---
        hk_payload = None
        try:
            if isinstance(site_json, dict):
                hk_payload = (site_json.get("site") or {}).get("site_hotkeys")
        except Exception:
            hk_payload = None

        # --- 2) envdb site_hotkeys ---
        if not hk_payload:
            hk_payload = target_site.get("site_hotkeys")

        hk_by_dir = {}
        vehicle_names = []

        if isinstance(hk_payload, dict):
            hk_by_dir = hk_payload.get("by_dir") or {}
            vehicle_names = hk_payload.get("vehicle_names") or []

        # --- 3) 없으면 counters(시트명)로부터 계산 ---
        if not hk_by_dir:
            # 프로젝트의 hotkey_sheets_global: [{"name": "...", "items":[{"차종":"승용차","키":"Q"}, ...]}, ...]
            sheets = []
            if isinstance(project0, dict):
                sheets = project0.get("hotkey_sheets_global") or []
            # sheet name -> keys list(차종 순서대로)
            sheet_map = {}
            for sh in sheets:
                try:
                    name = sh.get("name")
                    items = sh.get("items") or []
                    # 순번 정렬(있으면)
                    try:
                        items = sorted(items, key=lambda x: int(x.get("순번", 0)))
                    except Exception:
                        pass
                    vnames = [it.get("차종") for it in items if it.get("차종")]
                    keys = [str(it.get("키","")).strip() for it in items]
                    if name:
                        sheet_map[name] = (vnames, keys)
                except Exception:
                    continue

            # site.counters: [{"dir":10,"name":"방향(Q)"}, ...] 또는 {"방향":"방향(Q)","dir":10} 형태
            counters = target_site.get("counters") or []
            for c in counters:
                try:
                    dirnum = c.get("dir")
                    sheet_name = c.get("name") or c.get("방향")
                    if dirnum is None or not sheet_name:
                        continue
                    dirnum = int(dirnum)
                    if sheet_name in sheet_map:
                        vnames, keys = sheet_map[sheet_name]
                        if not vehicle_names and vnames:
                            vehicle_names = vnames
                        hk_by_dir[str(dirnum)] = keys
                except Exception:
                    continue

        # --- cfg.dir_hotkeys 반영 (dirnum 1~12 => index dirnum-1) ---
        if not hasattr(self, "cfg") or not hasattr(self.cfg, "dir_hotkeys"):
            return
        if not isinstance(self.cfg.dir_hotkeys, list) or len(self.cfg.dir_hotkeys) < 12:
            return

        changed_any = False
        for dirstr, keys in (hk_by_dir or {}).items():
            try:
                dirnum = int(dirstr)
                if not (1 <= dirnum <= len(self.cfg.dir_hotkeys)):
                    continue
                if not isinstance(keys, (list, tuple)) or len(keys) < 6:
                    continue
                keys = [str(k).strip().upper()[:1] if str(k).strip() else "" for k in keys[:6]]
                self.cfg.dir_hotkeys[dirnum - 1] = keys
                changed_any = True
            except Exception:
                continue

        if changed_any:
            # 이 플래그가 True이면 set_vehicle_count_like에서 기본키 덮어쓰지 않음
            try:
                self._site_hotkeys_active = True
            except Exception:
                pass

            # UI에 즉시 반영
            try:
                self.install_hotkeys(reinstall=True)
            except Exception:
                pass
            try:
                # 버튼 텍스트 갱신(있을 경우)
                for didx, panel in getattr(self, "dir_panels", {}).items():
                    try:
                        if didx in (10,11,12):
                            panel["set_buttons"](self.cfg.dir_hotkeys[didx-1])
                    except Exception:
                        pass
            except Exception:
                pass

            try:
                self.update()
            except Exception:
                pass

    except Exception as e:
        if DEBUG:
            print("[DBG] apply_env_hotkeys_to_counter error:", e)
        return

# ==== Login & main ====
def do_login()->Optional[dict]:
    while True:
        dlg=LoginDialog()
        if dlg.exec()==QtWidgets.QDialog.DialogCode.Accepted:
            u,p=dlg.get(); info=user_verify(u,p)
            if info: return info
            QtWidgets.QMessageBox.warning(None,"로그인 실패","아이디 또는 비밀번호가 올바르지 않습니다.")
        else: return None

def main():
    db_init()
    app=QtWidgets.QApplication(sys.argv)
    # 귀여운 파스텔 스타일의 콤보박스 적용
    app.setStyleSheet(app.styleSheet() + """
QComboBox {
    border: 1px solid #c6d4ff;
    border-radius: 8px;
    padding: 2px 24px 2px 8px;
    background-color: #f7f9ff;
    color: #222;
    selection-background-color: #dbe5ff;
}
QComboBox:hover {
    border-color: #8ea7ff;
    background-color: #f0f4ff;
}
QComboBox:focus {
    border: 2px solid #5b7cff;
    padding: 1px 23px 1px 7px; /* border 두께 증가를 보정 */
}
QComboBox::drop-down {
    subcontrol-origin: padding;
    subcontrol-position: top right;
    width: 22px;
    border: 0px;
}
QComboBox::down-arrow {
    image: none;
}

QScrollBar:vertical {
    background: transparent;
    width: 12px;
    margin: 2px 2px 2px 0;
    border-radius: 6px;
}
QScrollBar::handle:vertical {
    background: #ffb6c1;               /* 파스텔 핑크 핸들 */
    border-radius: 6px;
    min-height: 24px;
}
QScrollBar::handle:vertical:hover {
    background: #ff9ab0;               /* 마우스 올리면 살짝 진하게 */
}
QScrollBar::add-line:vertical,
QScrollBar::sub-line:vertical {
    height: 0px;
    subcontrol-origin: margin;
    border: none;
    background: transparent;
}
QScrollBar::add-page:vertical,
QScrollBar::sub-page:vertical {
    background: transparent;
}
"""); app.setApplicationName(APP_NAME)
    user=do_login()
    if not user: return 0
    w=MainWindow(user); w.resize(1660, 1000); w.show()
    # 프로그램 최초 실행 시 한 번만 이전 작업 상태 복원
    try:
        w.load_last_state()
    except Exception:
        pass
    # --- 창을 모니터 가운데로 이동 ---
    try:
        screen = QtGui.QGuiApplication.primaryScreen()
        if screen is not None:
            avail = screen.availableGeometry()
            frame = w.frameGeometry()
            frame.moveCenter(avail.center())
            w.move(frame.topLeft())
    except Exception:
        # 어떤 이유로든 실패해도 실행은 계속되도록
        pass
    return app.exec()

# =========================
# ENV integration patch v7
# (Robustly bind missing methods to MainWindow even if merge/indentation glitches occur)
# =========================

def _mw_format_site_label(self, site: dict) -> str:
    """지점 콤보 표기: 지번_지점명 (가능하면)"""
    try:
        # env에서 쓰는 키(한글) + json export에서 쓰는 키(영문) 모두 대응
        jibun = (site.get("지번") or site.get("jibun") or site.get("번지") or site.get("addr") or site.get("주소") or "").strip()
        name  = (site.get("지점명") or site.get("name") or site.get("site_name") or site.get("title") or "").strip()
        if jibun and name:
            return f"{jibun}_{name}"
        return (jibun or name or "지점").strip()
    except Exception:
        return "지점"


def _mw_populate_env_project_site_combos(self):
    """Populate project/site combos from env_data_plus_allinone.json (정본).

    - 과업: surveys[].info.name
    - 지점: 선택된 surveys[].sites[] -> 지번_지점명

    hotkeys_db.json은 "단축키/차종/방향 설정값"만 보조로 사용하고,
    과업/지점 목록은 env_data_plus_allinone.json에서 항상 가져옵니다.
    """
    pc = getattr(self, "projectCombo", None)
    sc = getattr(self, "siteCombo", None)
    if pc is None or sc is None:
        return

    # 1) load env_data_plus_allinone.json
    env = None
    env_path = None
    try:
        # Prefer explicit root
        root = os.environ.get("COUNTERMAX_DATA_ROOT") or ""
        cand = []
        if root:
            cand.append(os.path.join(root, "env_data_plus_allinone.json"))
        # common roots
        for r in ["Y:\\Survey", "K:\\Survey", "Z:\\Survey", "C:\\Survey"]:
            cand.append(os.path.join(r, "env_data_plus_allinone.json"))
        # current script dir
        try:
            cand.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), "env_data_plus_allinone.json"))
        except Exception:
            pass
        # also allow under root/survey/
        if root:
            cand.append(os.path.join(root, "survey", "env_data_plus_allinone.json"))
        for p in cand:
            if p and os.path.exists(p):
                env_path = p
                break
        if env_path:
            with open(env_path, "r", encoding="utf-8") as f:
                env = json.load(f)
    except Exception:
        env = None

    if not isinstance(env, dict):
        # fallback to cached env if present
        env = getattr(self, "_env_data_cache", None)

    surveys = []
    if isinstance(env, dict):
        surveys = env.get("surveys", []) or []
        self._env_data_cache = env
        self._env_data_path = env_path
    self._env_surveys_cache = surveys

    # 2) fill project combo
    try:
        pc.blockSignals(True)
        pc.clear()
        for sidx, s in enumerate(surveys):
            info = (s.get("info") or {}) if isinstance(s, dict) else {}
            name = (info.get("name") or s.get("project") or s.get("name") or s.get("title") or "").strip()
            if not name:
                continue
            pc.addItem(name, int(sidx))
        if pc.count() > 0:
            pc.setCurrentIndex(0)
    finally:
        try: pc.blockSignals(False)
        except Exception: pass

    # 3) populate sites for current project
    _mw_on_env_project_changed(self, pc.currentIndex())

def _mw_on_env_project_changed(self, _idx: int = 0):
    """When project combo changes, rebuild site combo from env surveys cache."""
    surveys = getattr(self, "_env_surveys_cache", None) or []
    pc = getattr(self, "projectCombo", None)
    sc = getattr(self, "siteCombo", None)
    if pc is None or sc is None:
        return
    if pc.count() <= 0:
        return

    sidx = pc.currentData()
    if not isinstance(sidx, int):
        try: sidx = int(sidx)
        except Exception: sidx = pc.currentIndex()
    if sidx < 0 or sidx >= len(surveys):
        sidx = max(0, min(pc.currentIndex(), len(surveys)-1)) if surveys else 0
    survey = surveys[sidx] if surveys and 0 <= sidx < len(surveys) else None
    self._env_selected_survey = survey

    sites = []
    if isinstance(survey, dict):
        sites = survey.get("sites") or []
        if isinstance(sites, dict):
            sites = list(sites.values())
    # rebuild site combo
    try:
        sc.blockSignals(True)
        sc.clear()
        for tidx, site in enumerate(sites):
            label = _mw_format_site_label(self, site)
            sc.addItem(label, int(tidx))
        if sc.count() > 0:
            sc.setCurrentIndex(0)
    finally:
        try: sc.blockSignals(False)
        except Exception: pass

    # apply first site if exists
    _mw_on_env_site_changed(self, sc.currentIndex())

def _mw_on_env_site_changed(self, _idx: int = 0):
    """When site combo changes, store selected site and update header labels / hotkeys."""
    surveys = getattr(self, "_env_surveys_cache", None) or []
    pc = getattr(self, "projectCombo", None)
    sc = getattr(self, "siteCombo", None)
    if pc is None or sc is None or pc.count() <= 0 or sc.count() <= 0:
        return

    sidx = pc.currentData()
    if not isinstance(sidx, int):
        try: sidx = int(sidx)
        except Exception: sidx = pc.currentIndex()
    if sidx < 0 or sidx >= len(surveys):
        return
    survey = surveys[sidx]

    sites = []
    if isinstance(survey, dict):
        sites = survey.get("sites") or []
        if isinstance(sites, dict):
            sites = list(sites.values())
    tidx = sc.currentData()
    if not isinstance(tidx, int):
        try: tidx = int(tidx)
        except Exception: tidx = sc.currentIndex()
    if tidx < 0 or tidx >= len(sites):
        return
    site = sites[tidx]
    self._env_selected_site = site

    # update top header QLineEdit if present (task/site text fields)
    try:
        # project display
        info = (survey.get("info") or {}) if isinstance(survey, dict) else {}
        proj_name = (info.get("name") or survey.get("project") or survey.get("name") or "").strip()
        site_label = _mw_format_site_label(self, site)
        # attempt to find common widgets
        for attr in ["editProject", "txtProject", "leProject", "lineProject", "projectEdit"]:
            w = getattr(self, attr, None)
            if w is not None and hasattr(w, "setText"):
                w.setText(proj_name)
        for attr in ["editSite", "txtSite", "leSite", "lineSite", "siteEdit"]:
            w = getattr(self, attr, None)
            if w is not None and hasattr(w, "setText"):
                w.setText(site_label)
    except Exception:
        pass

    # apply hotkeys to counter if bridge exists
    try:
        if hasattr(self, "apply_env_hotkeys_to_counter"):
            self.apply_env_hotkeys_to_counter(site, survey)
    except Exception:
        pass

def _mw_apply_env_selection(self, survey_index: int, site_index: int):
    """Programmatically select survey/site by index and apply."""
    pc = getattr(self, "projectCombo", None)
    sc = getattr(self, "siteCombo", None)
    if pc is None or sc is None:
        return
    if survey_index < 0:
        survey_index = 0
    if site_index < 0:
        site_index = 0
    try:
        pc.setCurrentIndex(min(survey_index, pc.count()-1))
    except Exception:
        pass
    try:
        sc.setCurrentIndex(min(site_index, sc.count()-1))
    except Exception:
        pass
    _mw_on_env_site_changed(self, sc.currentIndex())


def _mw_open_env_settings_window(self):
    """⚙: open embedded env settings script (or external env_*.py if present)."""
    import os, sys, subprocess, glob
    base_dir = os.path.dirname(os.path.abspath(__file__))

    # prefer existing env file in same dir
    candidates = []
    candidates += sorted(glob.glob(os.path.join(base_dir, "env_hotkey*.py")))
    candidates += sorted(glob.glob(os.path.join(base_dir, "env_*displayname*.py")))
    env_py = candidates[0] if candidates else None

    # if none, try to write embedded env if available
    if not env_py:
        try:
            embedded = globals().get("_EMBEDDED_ENV_SOURCE", None)
            if embedded:
                env_py = os.path.join(base_dir, "_env_hotkey_embedded.py")
                if (not os.path.exists(env_py)) or (os.path.getsize(env_py) < 1000):
                    with open(env_py, "w", encoding="utf-8") as f:
                        f.write(embedded)
        except Exception:
            env_py = None

    if not env_py or not os.path.exists(env_py):
        try:
            from PyQt6 import QtWidgets
            QtWidgets.QMessageBox.information(self, "환경설정", "환경설정 파일을 찾거나 생성하지 못했습니다.\n(같은 폴더에 env_hotkey*.py를 두거나, 내장 소스가 포함되어야 합니다.)")
        except Exception:
            pass
        return

    try:
        subprocess.Popen([sys.executable, env_py], cwd=base_dir)
    except Exception as e:
        try:
            from PyQt6 import QtWidgets
            QtWidgets.QMessageBox.warning(self, "환경설정", f"환경설정 실행 실패:\n{e}")
        except Exception:
            pass


# Bind methods to MainWindow defensively
try:
    MainWindow._format_site_label = _mw_format_site_label
    MainWindow._populate_env_project_site_combos = _mw_populate_env_project_site_combos
    MainWindow._on_env_project_changed = _mw_on_env_project_changed
    MainWindow._on_env_site_changed = _mw_on_env_site_changed
    MainWindow.apply_env_selection = _mw_apply_env_selection
    MainWindow.open_env_settings_window = _mw_open_env_settings_window
except Exception:
    pass



# =========================
# v17 patch: env direction + vehicle linkage fix
# =========================
import copy
def _env_pick_vehicle_project(envdb: dict, preferred_name: str = "") -> dict:
    projects = envdb.get("projects") or []
    if preferred_name:
        for p in projects:
            if isinstance(p, dict) and (p.get("name") == preferred_name):
                return p
    # default: first project
    for p in projects:
        if isinstance(p, dict):
            return p
    return {}

def _env_vehicle_names_from_project(proj: dict) -> list:
    vs = proj.get("vehicle_set") or []
    if isinstance(vs, list) and vs:
        # sort by 번호 if present
        def keyf(x):
            try: return int(x.get("번호", 10**9))
            except Exception: return 10**9
        vs2 = [v for v in vs if isinstance(v, dict)]
        vs2.sort(key=keyf)
        names=[]
        for v in vs2:
            nm = v.get("차종명") or v.get("차종구분") or v.get("name")
            if nm:
                names.append(str(nm))
        if names:
            return names
    # fallback old default
    return ["승용차","소형버스","대형버스","소형화물","중형화물","대형화물"]

def _env_sheet_map_from_project(proj: dict) -> dict:
    out={}
    for sh in (proj.get("hotkey_sheets_global") or []):
        if not isinstance(sh, dict): 
            continue
        nm = sh.get("name")
        items = sh.get("items") or []
        if nm and isinstance(items, list):
            out[str(nm)] = [it for it in items if isinstance(it, dict)]
    return out

def _hk_find_site_override(hkdb: dict, survey: dict, site: dict) -> dict:
    # Match order: survey sn -> survey name ; site work_no -> jibun+name
    hs = hkdb.get("surveys") or []
    if isinstance(hs, dict):
        hs = [v for v in hs.values() if isinstance(v, dict)]
    s_sn = (survey.get("info") or {}).get("sn") or survey.get("sn") or ""
    s_name = (survey.get("info") or {}).get("name") or survey.get("name") or ""
    wno = site.get("작업번호") or site.get("work_no") or ""
    jibun = site.get("지번") if "지번" in site else site.get("jibun")
    nm = site.get("지점명") or site.get("name") or ""
    for sv in hs:
        if not isinstance(sv, dict):
            continue
        info = sv.get("info") or {}
        ok = False
        if s_sn and ((info.get("sn") == s_sn) or (sv.get("sn") == s_sn)):
            ok = True
        elif s_name and ((info.get("name") == s_name) or (sv.get("name") == s_name)):
            ok = True
        if not ok:
            continue
        ss = sv.get("sites") or []
        if isinstance(ss, dict):
            ss = [v for v in ss.values() if isinstance(v, dict)]
        for st in ss:
            if not isinstance(st, dict):
                continue
            if wno and ((st.get("작업번호") == wno) or (st.get("work_no") == wno)):
                return st
            # fallback
            try:
                if jibun is not None and nm:
                    if str(st.get("지번", st.get("jibun", ""))) == str(jibun) and (st.get("지점명") or st.get("name") or "") == nm:
                        return st
            except Exception:
                pass
    return {}

def _mw_apply_env_selection_v17(self, survey_index: int, site_index: int):
    """Fixed env apply:
    - vehicle_types from envdb.projects[*].vehicle_set (default first: '6종차종구분')
    - dir_hotkeys from site.counters (dir->sheet name) + project.hotkey_sheets_global
    - if hkdb has site override (same survey/site), override counters/groups first
    """
    envdb = getattr(self, "envdb", None) or {}
    hkdb  = getattr(self, "hkdb", None) or {}
    surveys = envdb.get("surveys") or []
    if not (0 <= survey_index < len(surveys)):
        return
    survey = surveys[survey_index]
    sites = survey.get("sites") or []
    if not (0 <= site_index < len(sites)):
        return
    site = copy.deepcopy(sites[site_index])

    # apply override from hkdb if present
    ov = _hk_find_site_override(hkdb, survey, site) if isinstance(hkdb, dict) else {}
    if isinstance(ov, dict) and ov:
        for k in ("groups","counters","방향수","vehicle","vehicle_project","vehicle_set_name"):
            if k in ov:
                site[k] = ov.get(k)

    # pick vehicle project name (if survey/site hints), else default first project
    preferred_proj = ""
    # common keys that might exist in future exports
    for k in ("vehicle_project","vehicle_set_name","차종유형","차종프로젝트","vehicle_type"):
        v = site.get(k) or (survey.get("vehicle") or {}).get(k) if isinstance(survey.get("vehicle"), dict) else ""
        if v:
            preferred_proj = str(v)
            break
    proj = _env_pick_vehicle_project(envdb, preferred_proj)
    # if still empty, prefer '6종차종구분' when exists
    if not proj or not isinstance(proj, dict) or not proj.get("name"):
        proj = _env_pick_vehicle_project(envdb, "6종차종구분")

    veh_names = _env_vehicle_names_from_project(proj)
    sheet_map = _env_sheet_map_from_project(proj)

    # build dir->sheetname map from site.counters
    dir_to_sheet = {}
    for c in (site.get("counters") or []):
        if not isinstance(c, dict):
            continue
        d = c.get("dir")
        nm = c.get("name")
        if d is None or nm is None:
            continue
        try:
            di = int(str(d))
        except Exception:
            continue
        dir_to_sheet[di] = str(nm)

    # apply to cfg
    try:
        self.cfg.vehicle_types = veh_names
    except Exception:
        pass

    # 방향수 반영
    try:
        dn = int(site.get("방향수") or 12)
        self.cfg.enabled_directions = [True]*max(0, min(dn, 30)) + [False]*max(0, 30-min(dn,30))
    except Exception:
        self.cfg.enabled_directions = [True]*12 + [False]*18

    # dir_hotkeys: 12 directions, each list aligned with vehicle_names
    new_dir_hotkeys=[]
    for dirno in range(1, 13):
        sheet_name = dir_to_sheet.get(dirno, "")
        items = sheet_map.get(sheet_name) or []
        # map by 차종명 -> 단축키
        m={}
        for it in items:
            vn = it.get("차종명") or it.get("vehicle") or it.get("name")
            hk = it.get("단축키") or it.get("hotkey") or it.get("key")
            if vn is not None and hk is not None:
                m[str(vn)] = str(hk)
        # produce in veh order; fallback to old pattern if missing
        if m:
            keys=[m.get(v, "") for v in veh_names]

        # fallback (기본) 키 세트: dirno(1~12) 기준으로 숫자/Q/A 패턴
        if (dirno-1)%3==0:
            fallback=[str(i) for i in range(1, len(veh_names)+1)]
        elif (dirno-1)%3==1:
            fallback=["Q","W","E","R","T","Y"][:len(veh_names)]
        else:
            fallback=["A","S","D","F","G","H"][:len(veh_names)]

        # sheet에서 읽은 키가 하나도 없으면 전부 fallback
        if not any(keys):
            keys=fallback
        else:
            # 일부만 비어있으면 비어있는 자리만 fallback로 채움
            keys=[(k if k else fallback[i]) for i,k in enumerate(keys)]

        new_dir_hotkeys.append(keys)
    try:
        self.cfg.dir_hotkeys = new_dir_hotkeys
    except Exception:
        pass

    # Update header text
    try:
        self.projectCombo.blockSignals(True)
        self.siteCombo.blockSignals(True)
        self.projectCombo.setCurrentIndex(survey_index)
        self.siteCombo.setCurrentIndex(site_index)
    except Exception:
        pass
    finally:
        try:
            self.projectCombo.blockSignals(False)
            self.siteCombo.blockSignals(False)
        except Exception:
            pass

    # rebuild panels to reflect new vehicle labels / hotkeys
    try:
        self.rebuild_panels_after_change()
        self._sync_group_tabs()
    except Exception:
        pass

    # Update title fields (top edits)
    try:
        self.projectEdit.setText((survey.get("info") or {}).get("name") or survey.get("name") or "")
    except Exception:
        pass
    try:
        jb = str(site.get("지번","")).strip()
        snm = str(site.get("지점명","")).strip()
        self.siteEdit.setText(f"{jb}_{snm}" if jb and snm else (snm or ""))
    except Exception:
        pass

# Monkey patch MainWindow methods
try:
    MainWindow.apply_env_selection = _mw_apply_env_selection_v17
except Exception:
    pass




# ===== PATCHES MOVED ABOVE __main__ FOR RUNTIME EFFECT =====

# ===================== v26 PATCH: site json 기반 방향/그룹/단축키 반영 =====================
def _mw_find_latest_file_recursive_v26(root_dir: str, filename: str):
    """root_dir 이하에서 filename(정확히 일치) 파일을 모두 찾고, 수정시간이 가장 최신인 경로를 반환."""
    try:
        import os
        best = None
        best_mtime = -1.0
        for base, _, files in os.walk(root_dir):
            if filename in files:
                p = os.path.join(base, filename)
                try:
                    mt = os.path.getmtime(p)
                except Exception:
                    mt = -1
                if mt > best_mtime:
                    best_mtime = mt
                    best = p
        return best
    except Exception:
        return None

def _mw_load_site_json_v26(survey_root: str, workno: str):
    """Survey/Sites/** 에서 site_{workno}.json을 찾아 로드. (없으면 None)"""
    try:
        import os, json
        sites_root = os.path.join(survey_root, "Sites")
        if not os.path.isdir(sites_root):
            return None, None
        fn = f"site_{workno}.json"
        p = _mw_find_latest_file_recursive_v26(sites_root, fn)
        if not p or not os.path.isfile(p):
            return None, None
        with open(p, "r", encoding="utf-8") as f:
            data = json.load(f)
        return data, p
    except Exception:
        return None, None

def _mw_template_keys_v26(template_name: str):
    """환경설정의 카운터 템플릿명(방향(숫자)/방향(Q)/방향(A)) -> 키 배열"""
    t = (template_name or "").strip()
    # 관용 표기 대응
    if "숫자" in t:
        return ["1","2","3","4","5","6"]
    if "(Q" in t or "Q)" in t or "Q" == t:
        return ["Q","W","E","R","T","Y"]
    if "(A" in t or "A)" in t or "A" == t:
        return ["A","S","D","F","G","H"]
    # fallback: 기존 기본 규칙(숫자/Q/A 순환)과 동일하게 처리
    return ["1","2","3","4","5","6"]

def _mw_apply_site_json_to_cfg_v26(self, site_json: dict):
    """
    site.json -> self.cfg 반영 (핫키/카운터명/방향템플릿)

    핵심 이슈(사용자 리포트):
    - 환경설정(관리자모드)에서 10/11/12 슬롯에 '방향(A/Q/숫자)'를 지정해도
      하단 계수 입력창(10번/11번/12번 방향)의 단축키가 바뀌지 않는 현상.
    - 원인: site.json의 counters[*].dir 값이 실제 10/11/12가 아닌
      '슬롯 번호(1,2,3...)'로 저장되는 케이스가 있고,
      기존 로직은 dir을 10/11/12로 가정해 cfg.dir_hotkeys 인덱스를 잘못 갱신.
    - 해결: dir 값이 1~12가 아닌 경우, self.cfg.group_dirs(기본 [10,11,12])의
      순서대로 매핑하여 적용.
    """
    try:
        if not isinstance(site_json, dict):
            return

        site = site_json.get("site") if isinstance(site_json.get("site"), dict) else site_json
        counters = site.get("counters", []) if isinstance(site, dict) else []
        if not isinstance(counters, list):
            counters = []

        # 어떤 '방향 슬롯'을 화면에 표시할지(기본 10/11/12)
        group_dirs = getattr(self.cfg, "group_dirs", None)
        if not isinstance(group_dirs, list) or not group_dirs:
            group_dirs = [10, 11, 12]
        group_dirs = [int(x) for x in group_dirs if str(x).isdigit()]

        # 차량 종류 개수(키 개수)만큼만 잘라서 적용
        vt_cnt = len(getattr(self.cfg, "vehicle_types", [])) or 6

        # counters를 안정적으로 정렬: counter 번호가 있으면 그 기준, 없으면 입력 순서
        def _counter_sort_key(c):
            try:
                v = c.get("counter", None)
                return int(v) if str(v).isdigit() else 10**9
            except Exception:
                return 10**9

        counters_sorted = sorted([c for c in counters if isinstance(c, dict)], key=_counter_sort_key)

        applied = []  # (target_dir, tname, keys)

        slot_pos = 0
        for c in counters_sorted:
            tname = c.get("name") or c.get("title") or c.get("template") or ""
            if not isinstance(tname, str):
                tname = str(tname)

            # 1) dir이 실제 1~12면 그대로 적용 (기존 호환)
            target_dir = None
            d_raw = c.get("dir", None)
            if d_raw is not None and str(d_raw).strip().isdigit():
                dnum = int(str(d_raw).strip())
                if 1 <= dnum <= 12:
                    target_dir = dnum

            # 2) dir이 1~12가 아닌 경우 -> 그룹 방향 슬롯 순서대로 매핑
            if target_dir is None:
                if slot_pos < len(group_dirs):
                    target_dir = group_dirs[slot_pos]
                    slot_pos += 1
                else:
                    # 남는 슬롯이 없으면 스킵
                    continue

            # 템플릿명 -> 키셋
            keys = self._mw_template_keys_v26(tname) if hasattr(self, "_mw_template_keys_v26") else []
            if not isinstance(keys, list):
                keys = []
            keys = [str(k) for k in keys][:vt_cnt]

            # cfg에 반영
            try:
                if hasattr(self.cfg, "dir_hotkeys") and isinstance(self.cfg.dir_hotkeys, list):
                    idx = int(target_dir) - 1
                    if 0 <= idx < len(self.cfg.dir_hotkeys):
                        self.cfg.dir_hotkeys[idx] = keys
            except Exception:
                pass

            applied.append((target_dir, tname, keys))

        # 디버그 로그(문제 재현/확인용)
        try:
            if hasattr(self, "dlog"):
                for (td, tn, ks) in applied:
                    self.dlog(f"[DBG] apply_site_json_to_cfg_v26: dir={td} tname={tn} keys={ks}")
        except Exception:
            pass

    except Exception as e:
        try:
            if hasattr(self, "dlog"):
                self.dlog(f"[DBG] _mw_apply_site_json_to_cfg_v26 error: {e}")
        except Exception:
            pass
def _mw_sync_sitejson_hotkeys_from_env_v1(site_json: dict, env_site: dict) -> bool:
    """Ensure legacy site_WN_*.json 'counters[].name' matches current envdb(hotkeys_db) site counters.
    Returns True if site_json was modified.
    """
    if not isinstance(site_json, dict) or not isinstance(env_site, dict):
        return False
    env_counters = env_site.get("counters") or []
    if not isinstance(env_counters, list):
        return False
    # build dir -> name map from env
    env_map = {}
    for c in env_counters:
        if not isinstance(c, dict):
            continue
        d = c.get("dir")
        n = c.get("name")
        if d is None or n is None:
            continue
        try:
            d_int = int(d)
        except Exception:
            continue
        env_map[d_int] = str(n)

    if not env_map:
        return False

    changed = False
    sc = site_json.get("counters")
    if not isinstance(sc, list):
        sc = []
        site_json["counters"] = sc
        changed = True

    # index existing
    by_dir = {}
    for item in sc:
        if not isinstance(item, dict):
            continue
        try:
            d_int = int(item.get("dir"))
        except Exception:
            continue
        by_dir[d_int] = item

    # update / create 1..12
    for d_int, name in env_map.items():
        item = by_dir.get(d_int)
        if item is None:
            sc.append({"dir": d_int, "name": name})
            changed = True
        else:
            if str(item.get("name","")) != str(name):
                item["name"] = name
                changed = True
    # (A) also sync per-direction hotkeys / group hotkeys into site json so counter UI can load it
    # env_site['dir_hotkeys'] is expected to be a 12x6 list (direction 1..12)
    dh = env_site.get("dir_hotkeys")
    if isinstance(dh, list) and len(dh) == 12:
        try:
            # normalize into site_hotkeys dict: {10:[...], 11:[...], ...}
            site_hotkeys = {}
            for i, row in enumerate(dh, start=1):
                if not isinstance(row, (list, tuple)):
                    continue
                norm = []
                for x in list(row)[:6]:
                    s = (str(x) if x is not None else "").strip()
                    if len(s) == 1 and s.isalpha():
                        s = s.upper()
                    norm.append(s)
                while len(norm) < 6:
                    norm.append("")
                site_hotkeys[i] = norm[:6]
            if site_json.get("site_hotkeys") != site_hotkeys:
                site_json["site_hotkeys"] = site_hotkeys
                changed = True
        except Exception:
            pass

    gdh = env_site.get("group_dir_hotkeys")
    if gdh is not None and site_json.get("group_dir_hotkeys") != gdh:
        site_json["group_dir_hotkeys"] = gdh
        changed = True

    vt = env_site.get("vehicle_types")
    if vt is not None and site_json.get("vehicle_types") != vt:
        site_json["vehicle_types"] = vt
        changed = True
    return changed


def _mw_rebuild_tabs_from_cfg_groups_v35(self):
    """cfg.group_dirs (예: [[10,11,12],[1,2,3]]) 를 기준으로 탭/매핑을 재구성한다.
    - group_tab_mapping: 각 탭에 속한 '방향 인덱스(0-based)' 목록
    - tab 텍스트: '10-11-12' 형식(원본 유지)
    """
    try:
        gdirs = getattr(self.cfg, "group_dirs", None)
        if not isinstance(gdirs, list) or not gdirs:
            return False

        # 탭 위젯이 없으면 중단
        if not hasattr(self, "tab") or self.tab is None:
            return False

        # 탭 초기화
        try:
            self.tab.blockSignals(True)
            while self.tab.count():
                self.tab.removeTab(0)
        except Exception:
            pass

        self.group_tab_mapping = []

        # group_dirs의 각 그룹은 [10,11,12] 같은 '방향번호(1-based)' 리스트
        for nums in gdirs:
            try:
                nums = [int(x) for x in (nums or [])]
            except Exception:
                continue
            if not nums:
                continue

            # 0-based 인덱스로 변환
            idxs = []
            for n in nums:
                if 1 <= n <= len(getattr(self.cfg, "directions", []) or []):
                    idxs.append(n - 1)

            if not idxs:
                continue

            # 그룹은 보통 3개이지만, 안전하게 3개 미만/초과도 처리
            a = idxs[0]
            b = idxs[1] if len(idxs) >= 2 else idxs[0]
            c = idxs[2] if len(idxs) >= 3 else idxs[-1]

            # enabled_directions도 그룹에 포함된 인덱스는 True로 보정(지점/그룹 기반 표시 보장)
            try:
                if hasattr(self, "enabled_directions") and isinstance(self.enabled_directions, list):
                    for di in idxs:
                        if 0 <= di < len(self.enabled_directions):
                            self.enabled_directions[di] = True
            except Exception:
                pass

            # 페이지 생성
            try:
                page = self._make_group_page(a, b, c)
            except Exception:
                # _make_group_page가 없으면 스킵
                continue

            tab_text = "-".join(str(x) for x in nums)
            try:
                self.tab.addTab(page, tab_text)
            except Exception:
                try:
                    self.tab.addTab(page, tab_text.replace("-", " - "))
                except Exception:
                    pass

            # 이 탭에 속한 실제 방향 인덱스 기억
            self.group_tab_mapping.append(list(dict.fromkeys(idxs)))

        # 첫 탭 선택
        try:
            if self.tab.count() > 0:
                self.tab.setCurrentIndex(0)
        except Exception:
            pass

        # groupTabs(하단 미니탭) 동기화
        try:
            if hasattr(self, "_sync_group_tabs"):
                self._sync_group_tabs()
        except Exception:
            pass

        # 그룹 탭 변경 시 실제로 단축키 재설치/표시 갱신되도록 연결
        try:
            if hasattr(self, "groupTabs") and self.groupTabs is not None:
                try:
                    self.groupTabs.currentChanged.disconnect(self._mw_on_group_tab_changed_v35)
                except Exception:
                    pass
                self.groupTabs.currentChanged.connect(self._mw_on_group_tab_changed_v35, getattr(QtCore.Qt, 'ConnectionType', QtCore.Qt).UniqueConnection)
        except Exception:
            pass

        try:
            self.tab.blockSignals(False)
        except Exception:
            pass

            # (A) apply site-level hotkeys (site_hotkeys) to cfg + bottom UI + hotkey bindings
            try:
                self.apply_env_hotkeys_to_counter(site_js)
            except Exception as _e:
                pass
        return True
    except Exception:
        try:
            self.tab.blockSignals(False)
        except Exception:
            pass
        return False


def _mw_on_group_tab_changed_v35(self, idx: int):
    """그룹(탭) 변경 시:
    - active_dir_index를 해당 그룹의 첫 방향으로 맞추고
    - UI 라벨/하단 버튼을 리프레시하고
    - QShortcut을 재설치하여 '현재 그룹 기준'으로 즉시 반영되게 한다.
    """
    try:
        mapping = getattr(self, "group_tab_mapping", None)
        if isinstance(mapping, list) and 0 <= idx < len(mapping) and mapping[idx]:
            # 탭의 첫 활성 방향으로 이동
            try:
                self.active_dir_index = int(mapping[idx][0])
            except Exception:
                pass

        # UI 갱신
        try:
            if hasattr(self, "refresh_all_quick_counts"):
                self.refresh_all_quick_counts()
        except Exception:
            pass
        try:
            if hasattr(self, "update_active_highlight"):
                self.update_active_highlight()
        except Exception:
            pass

        # 핵심: 단축키 재설치(기존 QShortcut 제거 후 재생성)
        try:
            if hasattr(self, "install_hotkeys"):
                self.install_hotkeys(reinstall=True)
        except Exception:
            pass

        try:
            if hasattr(self, 'install_hotkeys'):
                self.install_hotkeys(reinstall=True)
        except Exception:
            pass

    except Exception:
        return
# === end v35 PATCH ===

def _mw_apply_env_selection_v18(self):
    """
    v18: env_data_plus_allinone.json + site_{workno}.json을 함께 사용.
    - env DB에서 프로젝트/지점 선택 → workno(WN_...) 확보
    - Survey/Sites/**/site_{workno}.json을 찾아서 방향/그룹/템플릿(단축키)을 확정 적용
    """
    # 기존 v17이 먼저 해주던 기본 적용은 유지하고, 마지막에 site json으로 덮어쓴다.
    try:
        if hasattr(self, "_mw_apply_env_selection_v17"):
            self._mw_apply_env_selection_v17()
    except Exception:
        pass

    try:
        # 1) env 경로로 Survey 루트 결정
        env_path = None
        try:
            env_path = best_env_db_path()
        except Exception:
            env_path = None
        if not env_path:
            return
        import os
        survey_root = os.path.dirname(env_path)

        # 2) 현재 선택된 지점 → workno 추출
        proj_name = self.projectCombo.currentText().strip() if hasattr(self, "projectCombo") else ""
        site_name = self.siteCombo.currentText().strip() if hasattr(self, "siteCombo") else ""
        if not proj_name or not site_name:
            return

        env_db = load_env_db(env_path)
        proj = _mw_find_project_v17(env_db, proj_name)
        if not proj:
            return
        site = _mw_find_site_v17(proj, site_name)
        if not site:
            return

        workno = str(site.get("작업번호") or site.get("workno") or "").strip()
        if not workno:
            return

        # 3) site json 로드 및 적용
        site_json, site_json_path = _mw_load_site_json_v26(survey_root, workno)
        if site_json:
            # IMPORTANT: envdb(hotkeys_db.json) is the current source of truth for 'counters[].name' (방향(숫자)/방향(Q)/방향(A)).
            # site_WN_*.json may lag behind; sync it so that bottom UI + hotkey installation use the latest admin settings.
            try:
                env_site = None
                surveys = (self.envdb or {}).get("surveys") or []
                if 0 <= survey_index < len(surveys):
                    sites = (surveys[survey_index] or {}).get("sites") or []
                    if 0 <= site_index < len(sites):
                        env_site = sites[site_index]
                if env_site:
                    if _mw_sync_sitejson_hotkeys_from_env_v1(site_json, env_site):
                        try:
                            _save_json_utf8(site_json_path, site_json)
                            dlog(f"[MIGRATE] synced site json hotkeys -> {site_json_path}")
                        except Exception as e:
                            dlog(f"[WARN] failed to save synced site json: {e}")
            except Exception as e:
                dlog(f"[WARN] sync_sitejson_hotkeys_from_env failed: {e}")

            _mw_apply_site_json_to_cfg_v26(self, site_json)
            try:
                dlog(f"after apply_site_json_to_cfg: 10={self.cfg.dir_hotkeys[9]} 11={self.cfg.dir_hotkeys[10]} 12={self.cfg.dir_hotkeys[11]}")
            except Exception:
                pass

        # 상태표시
            try:
                if hasattr(self, "lblEnvState"):
                    tip = self.lblEnvState.toolTip() or ""
                    extra = f"\nSITE: {site_json_path}"
                    if "SITE:" not in tip:
                        self.lblEnvState.setToolTip(tip + extra)
            except Exception:
                pass
    except Exception:
        return

# monkey patch: v18 적용
try:
    MainWindow._mw_apply_env_selection_v18 = _mw_apply_env_selection_v18
    # 기존 _mw_apply_env_selection_v17 호출부가 있다면 v18로 교체
    # (예: project/site 콤보 변경 시 호출)
    MainWindow._mw_apply_env_selection = _mw_apply_env_selection_v18
except Exception:
    pass
# =================== /v26 PATCH ===================


# --- v26 추가 패치: site 콤보 변경 시 site json 적용 ---
def _on_env_site_changed(self, *args, **kwargs):
    try:
        # 원래 로직 수행
        try:
            _on_env_site_changed(self)
        except Exception:
            # 혹시 원본이 메서드로 존재할 수도
            try:
                MainWindow._on_env_site_changed(self)
            except Exception:
                pass
        # 마지막에 v18 적용
        try:
            if hasattr(self, "_mw_apply_env_selection_v18"):
                self._mw_apply_env_selection_v18()
            elif hasattr(self, "_mw_apply_env_selection"):
                self._mw_apply_env_selection()
        except Exception:
            pass
    except Exception:
        pass

try:
    MainWindow._on_env_site_changed = _on_env_site_changed
except Exception:
    pass
# --- /v26 추가 패치 ---


# --- v26 FIX: 원본 _on_env_site_changed 저장 후 래핑 ---
try:
    _ORIG_ON_ENV_SITE_CHANGED_V26 = MainWindow._on_env_site_changed
except Exception:
    _ORIG_ON_ENV_SITE_CHANGED_V26 = None

def _on_env_site_changed_wrap(self, *args, **kwargs):
    try:
        if _ORIG_ON_ENV_SITE_CHANGED_V26:
            _ORIG_ON_ENV_SITE_CHANGED_V26(self, *args, **kwargs)
    except Exception:
        pass
    try:
        if hasattr(self, "_mw_apply_env_selection_v18"):
            self._mw_apply_env_selection_v18()
    except Exception:
        pass

try:
    MainWindow._on_env_site_changed = _on_env_site_changed_wrap
except Exception:
    pass
# --- /v26 FIX ---

if __name__=="__main__":
    sys.exit(main())